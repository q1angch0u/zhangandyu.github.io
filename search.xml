<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Hive-SQL学习]]></title>
    <url>%2F2019%2F04%2F18%2FHive-SQL%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[数据库与表的增删改查数据库 create database-创建新数据库 12345--创建zhang数据库create database zhang --制定数据库的位置create database if not exists zhang location '/zhang.db' alter database-修改数据库 12---增加数据库属性alter database zhang set dbproperties("CTtime"= "2020-05-01") drop database -删除数据库 12345---数据库下无表drop database zhang;---数据库下有表，-强制删除drop database zhang cascade; 选择数据库 1use android; 12# 重置默认数据库use default android; 查看所在的数据库 123456789show databases;--模糊查询show databases like "s%"--- 查询数据库信息desc database zhang;---查询数据库扩展属性desc database extended zhang; 数据表 create table-创建新表 12345678910111213141516171819202122232425create [external] table [if not exists] table_name [(col_name data_type [comment col_comment],....)][partitioned by (col_name data_type [comment col_comment],..)][clustered by (col_name, col_name, ...)][row format row_format][stored as file_format][location hdfs_path]--- create table 创建指定名称的表，如果相同名称的表已存在，则用if not exists 选项来忽略这个异常。--extername 关键字让用户创建一个外部表---partitioned by 分区：分目录，把一个大的数据集根据业务需要分割成小的数据集。在查询时通过where子句的表达式来选择查询所需的指定分区，提高查询效率。--clustered by 分桶--row format 字段之间的分隔符---stored as 文件存储格式--location， 指定表在HDFS上的存储位置---在zhang库中创建test表create external table dept( deptid int, dname string, loc int) row format delimited fields terminated by '\t' update-更新数据库中的数据 1234567update 表名set 需更新的列名1= 新值1, 需更新的列名2=新值2,...where 列名 = 某个原有的值UPDATE Websites SET alexa='5000', country='USA' --更新的数据WHERE name='菜鸟教程'; insert into() -向数据库中插入新数据 12insert into 表名（列名1,列名2,列名3...)values(值1, 值2, 值3...) delete-从数据库中删除数据 12345678delete from 表名where column = value...DELETE FROM WebsitesWHERE name='Facebook' AND country='USA';--删除表中所有的行，表结果不变delete from table_name; alter table- 修改数据库表 123--清楚表中数据,删除掉指定分区ALTER TABLE shphonefeature DROP IF EXISTS PARTITION(year = 2015, month = 10, day = 1);---lter table test.mon_mau_list drop partition (hit_mon = '&#123;0&#125;') drop table - 删除表 create index -创建索引 drop index -删除索引 refresh table 表名 - 刷新数据表 1refresh table computer_log.client_ios_log 查看当前使用的数据库中有哪些表 1show tables; 查看非当前使用的数据库中有哪些表 1show tables in myhive; 查看数据库中以 android 开头的表 12use android;show tables like 'android*' 查看表的详细信息 1desc formatted android 查询分区表有多少分区 1show partitions dept_partition; 查看分区表结果 1desc formatted dept_partition 增加分区 1alter table dept_partition add partition(month=&apos;201705&apos;) partition(month=&apos;201704&apos;) 删除分区 1alter table dept_partition drop partition (month=&apos;201705&apos;) 内部表与外部表 内部表(管理表)：默认创建内部表， 删除表会删除所有数据 外部表： 删除表不会删除这份数据，不过描述表的元数据信息会被删除掉。 原始日志数据应该建立外部表（避免误删）， 用到的中间表、结果表使用内部表存储。 查看表是内部表还是外部表 12--查看表信息desc formatted table_name 内部表与外部表的相互转换 12345---内部表转换为外部表alter table student set tblproperties('EXTERNAL' = 'true') ---单引号、大小写不能变---外部表转化为内部表alter table student set tbproperties('EXTERNAL' = 'false') 查询select…from… 加入表中一列含有多个元素， 我们可以只查找此列的第一个元素 12select name, subord[0] from employees; 可以使用 “点” 符号， 类似：表的别名 . 列名 这样的用法 12select name, address.city from employees; 使用正则表达式，可以选出所有列名以 price 作为前缀的列 1select 'price.*' from stocks; 使用列值进行计算 1select count(distinct account), avg(salary) from employees; 使用别名 1select count(distinct acount) as uv from employees; 如果用 distinct, select 后面必须直接跟 distinct 1select distinct user_account, province from computer_viedata where 关系型运算符优先级高到低为：not - and - or 123select * from employees where country = 'us' and state = 'ca';select * from employees where country not in ('us', 'china') 数学运算符与关系运算符 运算符 描述 + 加法 - 减法 * 乘法 / 除法 % 取余 &amp; 与 \ 或 ^ 异或 ~ 取反 操作符 描述 A=B 如果A=B，则返回True,否则返回False A&lt;=&gt;B 如果A和B都为NULL，则返回True,其他的和等号操作结果一致，如果任意为Null,则结果为null A&lt;&gt;B,A!=B A或B为Null, 则返回Null,如果A不等于B，则返回True,否则返回False A&lt;B – A&lt;=B – A&gt;B – A&gt;=b – A[not] between B and C — A is null — A is not null — in – A [NOT] like B – A rlike B, A REGEXP B — 逻辑运算 描述 and — or – not — like、rlike 123456---like、 rlike select name, address.street from employees where address.street rlike '.*(beijing|shanghai).*';select name, address.street from employeeswhere address.street like '%beijing%' or address.street like '%shanghai%'; 通配符 含义 % 匹配0个或任意多个字符 _ 匹配任意一个字符 escape 转义字符，可匹配%和_。如SELECT * FROM table_name WHERE column_name LIKE ‘/%/_%_’ ESCAPE’/‘ — — . 匹配任意单个字 符 * 匹配0个或多个前一个得到的字符 [] 含有任意一个[]内的字符，[ab]*可匹配空串、a、b、或者由任意个a和b组成的字符串。 ^ 匹配开头，如^s匹配以s或者S开头的字符串 $ 匹配结尾，如s$匹配以s结尾的字符串。 {n} 匹配前一个字符反复n次。 group by1234567891011--- 对结果进行分类select year(ymd), avg(price_close) from stockswhere exchange = 'nasdaq' and symbol = 'aapl'group by year(ymd)order by year(ymd) desc; --desc 从高到低排列 order by1234567891011--对查询的所有结果进行排序, 可在字段加 DESC 关键字， 进行降序排序。 （默认 ASC， 升序）select year(ymd), avg(price_close) from stockswhere exchange = 'nasdaq' and symbol = 'aapl'group by year(ymd)order by year(ymd) desc; 12--先对code进行排序，然后对code里的姓名进行排序select * from a order by code, name desc; having1234567891011--- having 子句来限制输出结果--- 查找平均工资大于3000的部门select deparment, avg(salary) as average from salary_info group by deparment having average &gt; 3000 having 与 where 的区别： Where 是一个约束声明，使用Where约束来自数据库的数据，Where是在结果返回之前起作用的，Where中不能使用聚合函数。 Having是一个过滤声明，是在查询返回结果集以后对查询结果进行的过滤操作，在Having中可以使用聚合函数。 limit12---使用limit语句限制返回的行数，只显示 10 行select count(distinct account) as uv from employees limit 10; 表连接joinHive中Join的关联键必须在ON ()中指定，不能在Where中指定,ON 子句指定了两个表间数据进行连接的条件。 对于多张表进行连接查询12345678---为什么条件内不将表 b 和表 c 进行连接操作， 因为 Hive总是按照从左到右的顺序来执行SELECT a.ymd, a.price_close, b.price_close, c.price_closeFROM a JOIN b ON a.ymd = b.ymd JOIN c ON a.ymd = c.ymdWHERE a. symbol = 'Apple' AND b.symbol = 'Ibm' AND c.symbol = 'Google' 并集：union 与 union all12345678910111213141516171819202122with a1 as ( select user_account from data where hit_date between '2018-12-01' and '2018-12-02' and nbtn_name like "%支付宝%" union select user_account from data where hit_date between '2018-12-01' and '2018-12-02' and nbtn_name like "%手淘%")select count(user_account) as pvfrom a1 union 与 union all 的不同： union, 结果包含所有行， 并删除重复行 unoin all, 结果包含所有行， 但不删除重复行 交集：intersect12345678910111213141516171819202122with a1 as ( select user_account from data where hit_date between '2018-12-01' and '2018-12-02' and nbtn_name like "%支付宝%" intersect select user_account from data where hit_date between '2018-12-01' and '2018-12-02' and nbtn_name like "%手淘%")select count(user_account) as pvfrom a1 差集：except12345678910111213141516171819202122with a1 as ( select user_account from data where hit_date between '2018-12-01' and '2018-12-25' and nbtn_name like "%支付宝%" except select user_account from data where hit_date between '2018-12-01' and '2018-12-25' and nbtn_name like "%手淘%")select count(user_account) as pvfrom a1 函数聚合函数 函数名 定义 count() 个数统计函数 count(distinct ) 统计去重之后的个数 sum() 求和 sum(distinct ) 去重之后的和 avg() 平均值 avg(distinct) 去重之后的平均值 min() 最小值 max() 最大值 corr(A, B) 相关系数 var_pop() 方差 var_samp() 样本方差 stddev_pop() 标准偏差 stddev_samp() 标准样本偏差 covar_pop(A, B) 协方差 covar_samp(A, B) 样本协方差 RAND() 随机数 count(1)、count(*)、count(column) 之间的区别 执行效果上：count(*)包括了所有的列，相当于行数，在统计结果的时候，不会忽略列值为NULLcount(1)包括了忽略所有列，用1代表代码行，在统计结果的时候，不会忽略列值为NULLcount(列名)只包括列名那一列，在统计结果的时候，会忽略列值为空（这里的空不是只空字符串或者0，而是表示null）的计数，即某个字段值为NULL时，不统计。 执行效率上：列名为主键，count(列名)会比count(1)快列名不为主键，count(1)会比count(列名)快如果表多个列并且没有主键，则 count(1) 的执行效率优于count(*)如果有主键，则 select count(主键)的执行效率是最优的如果表只有一个字段，则 select count(*)最优。 时间函数 函数名 定义 语句 NOW ( ) 当前时间 select now() extract() 抽取具体的年、月、日 date() 返回时间的日期部分 year() 返回时间的年份 month() 返回时间的月份 day() 返回日期的天 hour() 返回时间的小时 minute() 返回时间的分钟 second() 返回时间的秒 week () 第几周 dayofweek() 返回星期几，1为星期天 dayofyear() 一年中的第几天 sec_to_time ( ) 秒数转成时间 date_add() 时间相加 date_add(dt,interval 1 day ) date_sub(date,INTERVAL expr（时间间隔） type（时间类型，天、月、年）) 时间相减 date_sub(‘2018-05-01’,interval -1 year) datediff() 时间的差值 date_format() 输出指定时间格式 date_format(hit_date, “%Y-%m-%d) datename() 返回日期部分的参数 datepart() 返回日期、时间的单独部分 求留存率 datediff-求留存率 1234567891011121314151617181920212223242526272829---一次性求次1日，次3日， 次7日留存，此方法不能计算pv，会造成笛卡尔积with a1 as (select hit_date, user_accountfrom computer_view.datawhere hit_date between '2019-04-25' and '2019-05-13' and btn_information is not null),a2 as (select hit_date, user_accountfrom computer_view.datawhere hit_date between '2019-04-25' and '2019-05-13' and btn_information is not null)select a1.hit_date,count(distinct a1.user_account) uv,count(distinct case when datediff(a2.hit_date, a1.hit_date) = 1 then a1.user_account else null end ) next_day,count(distinct case when datediff(a2.hit_date, a1.hit_date) = 3 then a1.user_account else null end ) three_day,count(distinct case when datediff(a2.hit_date, a1.hit_date) = 7 then a1.user_account else null end ) seven_dayfrom a1 join a2 on a1.user_account = a2.user_accountgroup by a1.hit_dateorder by a1.hit_datelimit 100 date_add 求留存率 12345678910111213141516171819202122232425262728293031323334---步骤1：统计每天的uv---步骤2： - 统计10-15号每天的次日留存数， 统计次3、7日留存只需将1换为3、7with a1 as ( select user_account, hit_date from computer_view.data where hit_date between '2018-11-10' and '2018-11-15'),a2 as ( select user_account, hit_date from computer_view.data where hit_date between '2018-11-10' and '2018-11-25')select a1.hit_date, count(distinct a1.user_account) as uvfrom a1 join a2 on a1.user_account = a2.user_accountWHERE a2.hit_date = date_add(a1.hit_date, 1) group by a1.hit_dateorder BY a1.hit_date--步骤3：计算留存率 计算留存率的其他写法-迷神 1234567891011121314151617181920212223242526-- 留存sql优化select count(1)from( select userid, count(1) from( select t1.userid, t1.statdate from table1 t1 where t1.statdate = $&#123;上30天日期&#125; and t1.statdate &lt;= $&#123;上一天日期&#125; group by t1.userid, t1.statdate ) s1 group by userid having count(1) 2 ) R1--此sql为一个样例，计算连续跟任意都适用，至于计算第N天，只需要更改下日期过滤条件，变成=$[上N天日期]，=$&#123;上一天日期&#125;。 --另外，这种方式适合跑当前周期数据，如果跑历史数据，可以写个循环。当然，最暴力还是直接用userid 关联。--这种写法，更多是针对现在大部分分布式处理平台的特性，尽可能将数据合理均匀分片，每台服务器各自运算自己的，最后汇总。 尽可能少用 count distinct 这种写法，因为无法利用分片的特性。 留存率的另一种写法-勇哥 123456789101112131415161718192021222324252627282930313233343536373839404142with a1 as (select hit_date, user_account, count(1) as hit_countfrom apache_computer_view.client_android_logWHERE hit_date between '2020-04-01' and '2020-04-07' and btn_navigation like "%查询办理%"group by 1,2),a2 as (select hit_date, user_account, count(1) as hit_countfrom apache_computer_view.client_android_logWHERE hit_date between '2020-04-01' and '2020-04-07' and btn_navigation like "%查询办理%"group by 1,2)select a1.hit_date as one, a2.hit_date as two, datediff(a2.hit_date, a1.hit_date) as cha, count(distinct a2.user_account), sum(a2.hit_count)from a1 left join a2 on a1.user_account = a2.user_accountgroup by 1,2having cha &gt; 0order by 1,2 计算月留存率的简单写法：筛选出在两个月份出现的用户 12345678910111213141516171819202122232425262728with a1 as (select user_account, count(distinct month (hit_date)) as cfrom apache_computer_view.client_android_log where hit_date between '2019-03-01' and '2019-04-31'group by user_accounthaving c = 2union select user_account, count(distinct month (hit_date)) as cfrom apache_computer_view.client_ios_log where hit_date between '2019-03-01' and '2019-04-31'group by user_accounthaving c = 2 )select count(distinct user_account) as uv from a1 条件判断：case when 与 if IF( expr , v1 , v2 )函数 查出班级所有学生，如果年龄小于20，就标准为少年，否则标记为青年。12345select * if(age&lt;20,'少年','青年') AS ifage from student ifnull(V1,V2)函数 如果v1不为空，则直接返回v1;如果v1为空，则返回参数v2123select ifnull(1,2), ifnull(null,10); case when 函数 对不同字母进行省份转换 12345678910111213141516171819202122232425selectcase when province like 'ah' then '安徽' when province like 'fj' then '福建' when province like 'gd' then '广东' else 'm' end as province , count(distinct user_account) uv, count(page_name) pvfrom android_logwhere hit_date between '&#123;&#125;' and '&#123;&#125;'and page_name like '%Kefujh%'group by case when province like 'ah' then '安徽' when province like 'fj' then '福建' when province like 'gd' then '广东' else 'm' end order by case when province like 'ah' then '安徽' when province like 'fj' then '福建' when province like 'gd' then '广东' else 'm' end limit 1000 统计各部门男女分别有多少人 姓名 部门 性别 甲 A 男 乙 A 男 丙 B 女 丁 A 女 张 B 男 赵 B 女 1234567select 部门， sum (case 性别 when '男' then 1 else 0 end ) as male_count, sum (case 性别 when '女' then 1 else 0 end ) as male_countfrom table1group by 部门 范围转换12345678910select case when population &lt; 250 then '1' when population = 250 and population &lt; 500 then '2' when population = 500 and population &lt; 750 then '3' when population = 750 then '4' else null end as pop_classs, count(*) as cntfrom popgroup by district; 行转列 函数 case when concat(string A/col, string B/col…) ：函数在连接字符串时，只要其中一个是NUll，则返回NUll concat_ws(separator, str1, str2,…): 函数需要指定分隔符，只能接收 string或string类型的数组，只要有一个字符串不是NUll， 则不会返回NULL。 collect_set(col): 函数值接受基本数据类型，主要作用是将某字段的值进行去重汇总，产生array类型字段。 案例 多行转多列 年 季度 销售量 1991 1 11 1991 2 12 1991 3 13 1991 4 14 1992 1 21 1992 2 22 1992 3 23 1992 4 24 查询结果如下： 年 一季度 二季度 三季度 四季度 1991 11 12 13 14 1992 21 22 23 24 12345678910select 年, sum(case when 季度=1 then 销售量 else 0 end ) as 一季度, sum(case when 季度=2 then 销售量 else 0 end ) as 二季度, sum(case when 季度=3 then 销售量 else 0 end ) as 三季度, sum(case when 季度=4 then 销售量 else 0 end ) as 四季度,from salesgroup by 年 多行转单列 省-城市 uv 河北省-保定 11189 山西省-阳泉市 13 河南省-信阳 7462 1234567891011121314select concat(province,'-', city), uv --concat_ws('-', province, city), uv from (select province, city, count(distinct user_account) as uv from apache_computer_viewwhere hit_date = '2020-03-01'group by province, city) 多行转单列-复杂 name contellation blood_type 孙悟空 白羊座 A 猪八戒 射手座 A 宋宋 白羊座 B 唐僧 白羊座 A 张帅 射手座 A 把星座和血型一样的人归类到一起： 。。。 。。。 射手座,A 猪八戒\张帅 白羊座，A 孙悟空\唐僧 白羊座，B 宋 123456789101112select t1.c_b concat_ws("\", collect_set (t1.name))from ( select concat_ws(',', constellation, blood_type) c_b, name from person_info) t1group by t1.c_b;) 求将每个省的城市列出来 12345678910111213select province, collect_set(city)from apache_computer_view.client_android_log where hit_date = '2020-03-01'and nbtn_name is not null group by province---辽宁省 ["营口市","大连","大连市","抚顺市","铁岭","盘锦","锦州","沈阳市","辽阳","鞍山","铁岭市","本溪市","丹东市","丹东","沈阳","朝阳市","锦州市","辽阳市","阜新市","鞍山市","盘锦市","葫芦岛","营口","抚顺","葫芦岛市","阜新","本溪","朝阳"] 求出一个月内活跃天数大于20天的用户数 1234567891011121314151617--先列出每个用户的所有登陆时间--选出需要的时间段select count(distinct user_account) as uv from (select user_account, collect_set(hit_date) as t from apache_computer_view.client_android_log where hit_date between '2020-03-01' and '2020-03-31' group by user_account) as awhere size(a.t) &gt;= 20--手机号对应日期长度 &gt;= 20 列转行 函数 explode(col): 将hive列中复杂的array或者map结构拆分成多行 lateral view用法： lateral view udtf(expression) tableAlias as columnAlias说明： 用户和split,explode 等UDTF一起使用，能够将一列数据拆分成多行数据， 在此基础上可以对拆分的数据进行聚合计算. 形成一个新的表，并对原来的表进行侧写 案例 需求1 movie category 《疑犯追踪》 悬疑,动作,科幻,剧情 《lie to me》 警匪,动作,心理 要求： movie category 《疑犯追踪》 悬疑 《疑犯追踪》 动作 《疑犯追踪》 科幻 《疑犯追踪》 剧情 《lie to me》 警匪 《lie to me》 动作 《lie to me》 心理 123456789select movie, category_namefrom movie_infolateral view explode(category) tmpTable as category_name---用分开的表，对要求的数据进行测写-- select movie,explode(category) from movie_info 会生成笛卡尔积，不能执行 需求2： 将 表 table 中的 adid_list 转换为单独的行。 表-table： pageid adid_list front_page [1,2,3] contact_page [3,4] 输出结果为： pageid adid_list front_page 1 front_page 2 front_page 3 contact_page 3 contact_page 4 12345SELECT pageid, adidFROM tablelateral view explode(adid_list) adTable as adid 需求3： 计算特定广告的展现次数 1234567SELECT adid, count(1)FROM tablelateral view explode(adid_list) adTable as adidGROUP BY adid 输出结果为： adid count(1) 1 1 2 1 3 2 4 1 需求4： 多个 lateral view 查询 表： table2 array col2 [1,2] [“a”，”b”] [3,4] [“c”, “d”] 输出结果为： myCol1 myCol2 1 “a” 1 “b” 2 “a” 2 “b” 3 “c” 3 “d” 4 “c” 4 “d” 123456SELECT myCol1, myCol2FROM baseTableLATERAL VIEW explode(col1) myTable1 AS myCol1LATERAL VIEW explode(col2) myTable2 AS myCol2 窗口函数 函数 函数名 定义 over() 指定分析函数工作的数据窗口大小，这个数据窗口大小可能会随着行的变化而变化 常跟的函数 说明 — — current row 当前行 n preceding 往前n行数据 n following 往后n行数据 unbounded 起点 uvbounded preceding 表示从前面的起点开始 unbounded following 表示到后面的终点 lag(col, n) 往前第n行数据 lead(col, n) 往后第n行数据 ntile(n) 把有序分区中的行分发到指定数据的组中， 各个组有编号，编号从1开始，ntile返回此行所属组的编号 first_value() 返回组中数据窗口的第一个值 last_value() 返回组中数据窗口的最后一个值 案例 name orderdate cost jack 2017-01-01 10 tony 2017-01-02 15 jack 2017-01-03 23 tony 2017-01-04 29 jack 2017-01-05 46 jack 2017-04-06 42 tony 2017-01-07 50 jack 2017-01-08 55 mart 2017-04-08 62 mart 2017-04-09 68 neil 2017-05-10 12 mart 2017-04-11 75 neil 2017-06-12 80 mart 2017-04-13 94 查询在2017年4月购买的顾客及总人数12345678select name,count(1)over() ----over全量， 如果不加over，就会按照name来划分from businesswhere substring_index(orderdate,'-',2) = '2017-04'group by name name c1 不加over jack 2 1 mart 2 4 查询顾客的购买明细及月购买总额 123456select *, sum(cost) over (distribute by month(orderdate))--- sum(cost) over (partition by month(orderdate))from business 要将cost按照日期进行累加 12345select *, sum(cost) over(order by orderdate rows between unbounded preceding and current row)from business 按照日期进行排序，并将当前日期和前一天、后一天数据求和 12345select *, sum(cost) over(order by orderdate rows between 1 preceding and 1 following)from business 求每个人将按照日期进行累加的消费金额 12345select *, sum(cost) over (partition by name order by orderdate rows between unbounded preceding and current row )from business 要将cost按照日期进行倒序累加 12345select *, sum(cost) over (order by orderdate rows between current now and unbounded following )from business 查询顾客上次购买的时间, 与下次购买时间。相邻两个时间戳如何相减，求时间 123456select *, lag(orderdate, 1) over (partition by name order by orderdate), lead(orderdate,1) over (partition by name order by orderdate)from business 查询前20%时间的订单信息 1234567891011select * from ( select name, orderdate, cost, ntile(5) over(order by orderdate) gid from business ) twhere git =1 ntile函数详解ntile函数可以将有序数据，根据指定的组数进行分组处理。 编号从1开始，对于每一行，ntile将返回此行所属的组编号。ntile函数的分组依据： 每组包含的数据个数不能大于它上一组 包含的数据个数 计算规则：1. 检查能不能对所有满足条件的记录进行平均分组，若能则直接平均分配完成分组。2. 若不能，则会先分出一个组，此组个数为（总个数/总组数）+1。3. 分配之后系统会继续比较余下的记录数与未分配的组数能不能进行平均分配，若不能，则根据上面条件再分配。 例如：将6个记录分为4组， 不能平均分配则，第一组记录数为 （6/4)+1 = 2条记录。剩余4条记录分为3组，不能平均分配，则第二组记录数为（4/3)+1=2条记录。剩余2条记录分为2组，则剩余2组各1条记录。 排序函数 函数 SQl 中用于排序的函数有：rank、dense_rank、row_number、ntile函数,其语法为：1234567891011rank() over ([partition by A] order by B DESC)dense_rank() over ([partition by A] order by B DESC)row_number() over ([partition by A] order by B DESC )ntile() over([partition by A] order by B desc)-- partition by A 表示 按照A进行分区。-- order by B 表示按照B进行排序。-- DESC 表示 从大到小降序排列。-- 其中[partition by col1]若不需要则可省略不写。 明确各函数之间的不同点rank函数， 数值相等的排序则会留下空位： 1、2、2、4dense_rank函数，数值相等的排序不会留下空位: 1、2、2、3row_number函数，则不区分数值是否相等，默认排序为： 1、2、3、4ntile函数，对有序行进行分组处理 **2.需求 如何找出各省点击人数Top10的按钮？ 对于这个问题，首先要理清自己的思路：1. 取出 省份、按钮和 uv;2. 各省分组内，按照uv进行从大到小排序，并输出一列排序序号;3. 根据排序序号，取出排序前10的按钮和省份。 1234567891011121314151617181920212223242526select province, nbtn_name from (select province, --省份 nbtn_name, --按钮 uv, --uv dense_rank()over(partition by province order by uv DESC) as ran --排序from (select province, nbtn_name, count(distinct user_account) as uvfrom apache_computer_view.client_android_log where nbtn_name is not null and hit_date = '2020-03-10'group by province, nbtn_name))where ran &lt;= 10 求连续4个月活跃的用户数 123456789101112131415161718192021---1月活跃的用户数， 在2月、3月、4月一直活跃的用户有多少？with a1 as(select user_account , month(hit_date) as monthfrom compu_view.ios_log_viewwhere hit_date between '2019-01-01' and '2019-04-30'group by user_account, month(hit_date) ),a2 as ( select user_account,a1.month, row_number() over(partition by user_account order by a1.month) as pxfrom a1) select count(distinct user_account) as uvfrom a2where a2.px = 4 求4月连续7天进行签到的用户数 12 字符串函数 函数 函数名 定义 concat() 拼接字符串 length() 计算字符串的长度，一个汉字算三个字符 instr (A ,B ) 返回字符B首次在A中出现的位置,不存在返回0 lcase() 转换成小写 left(string2 ,length ) 从string2中的左边起取length个字符 lower() 将字串转化为小写 upper() 将字符转化为大写 replace() 替换字符 split() hive字符串分割函数 substr() 返回字符串A从start位置开始，长度为len的字符串 substring() 截取字符串 substring_index() 通过截取获取不同索引位的字符 LTRIM (string2 ) 去除前端空格 RTRIM (string2 ) 去除后端空格 函数详解 substr函数与 substring函数用法相同: 1substr/substring( A, k开始截取的位置，截取长度) 举例：1234substr(string,4): 从右第4位置截取到最后，结果为：ingsubstr(string,1,3):取左边第1位置起，3字长的字符串，结果为：strsubstr(string,-3,3):取右边第1位置起，3字长的字符串,右边第一位置往右不够3字长，结果为：gsubstr(string,-3,3):取右边第1位置起，3字长的字符串，结果为：ing substring_index函数1substring_index(A, 分割的字符,截取字符的位置) 举例：123456789substring_index(&apos;15,151,152,16&apos;,&apos;,&apos;,1)：取第一个逗号前面的字符串，结果为：15substring_index(&apos;15,151,152,16&apos;,&apos;,&apos;,2)：取第二个逗号前面部分，结果为：15,151substring_index(&apos;15,151,152,16&apos;,&apos;,&apos;,-1)：取目标字符串中最后一个含 “,” 位子的后的部分，结果为：16substring_index(substring_index(&apos;15,151,152,16&apos;,&apos;,&apos;,2),&apos;,&apos;,-1):取第二个逗号前面部分,然后最后逗号的前面部分，结果为：151substring_index(substring_index(&apos;15,151,152,16&apos;,&apos;,&apos;,-2),&apos;,&apos;,1)：取倒数第二个逗号后面部分字符串，再去这部分里第一个都号前的部分，结果为：152 split函数 1split(A, 分割的字符) 举例： 12345678910split(&apos;a,b,c,d&apos;,&apos;,&apos;):根据逗号进行分割，结果为： [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;]split(&apos;a,b,c,d&apos;,&apos;,&apos;)[0]： 取结果数组中的某一项，结果为： asplit(&apos;192.168.0.1&apos;,&apos;\\.&apos;)： 点号这种特殊字符的时候需要做特殊的处理，结果为：[&quot;192&quot;,&quot;168&quot;,&quot;0&quot;,&quot;1&quot;]&quot;.... split(&apos;192.168.0.1&apos;,&apos;\\\\.&apos;) ... &quot;: split包含在 &quot;&quot; 之中时 需要加4个\,不然得到的值是null同样的 | 等特殊符号也需要做类似 处理。 3.区分函数之前的区别 substr函数与 substring函数是根据截取的位置来进行分割。 substring_index和split是根据特定的字符来进行分割。 需求 将一些字段拆解出来进行使用，比如：Syjh-sjsy-zygn-3_1字段，我们只需要Syjh-sjsy-zygn位置的所有按钮。 1234567891011select substring_index(nbtn_position, &apos;-&apos;,3) as position, count(distinct user_account) as uv from apache_computer_viewwhere hit_date = &apos;2020-03-01&apos; and nbtn_position like &apos;%Syjh%&apos;group by substring_index(nbtn_position, &apos;-&apos;,3) 空字段赋值NVL：给值为NULL的数据赋值，格式为NVL（string1, replace_with),功能为：如果string1为null，则NVL函数返回replace_with的值，否则返回string1的值，如果两个参数都为NULL，则返回NULL。1select nvl(comm, -1) from student; 查看系统内置函数 查看系统自带的函数 1show functions 显示自带的函数的用户 1desc function 函数名; 详细显示自带的函数用法 1desc function extended 函数名 Hive避免数据倾斜 数据倾斜：当我们在Hive上进行查询时，因为数据的分散度不够， 导致大量数据集中在一台或者几台服务器上， 导致数据的计算速度远远低于平均计算速度， 计算过程特别耗时。 数据倾斜的表现：任务进度长时间维持在99%，查看任务监控页面，发现只有少量子任务未完成。 小表Join大表 Hive 会假定查询中最后一个表是最大的表， 在对每行记录进行连续操作时， 它会尝试将其他表缓存起来，然后扫描最后那个表进行计算。因此，我们在查询时，要保证连续查询中的表的大小从左到右依次是增加的。 假如，在 a, b 两个表中，b表最小， 则 写sql时需让b表在左，a表在右： 123456789101112131415161718SELECT a.price_close, b.price_closeFROM b JOIN a ON b.ymd = a.ymd AND b.symbol = a.symbolWHERE a.symbol = 'APPLE'---Hive支持使用/*+STREAMTALBE*/语法指定哪张表是大表， 不需要排序SELECT /*+3`'LKLLGFG Streamtable(a)*/ a.price_close, b.price_closeFROM a JOIN B on a.ymd = b.ymd AND a.symbol = b.symbolWHERE a.symbol = 'Apple' 大表JOIN大表 空key过滤有时join超时是因为某些key对应的数据太多，而相同key对应的数据都会发送到相同的reducer上，从而导致内存不够。此时我们应该仔细分析这些异常的key，很多情况下，这些key对应的数据是异常数据，我们需要在sql语句中进行过滤。 123456789101112131415Select *From a Join bOn a.user_id is not nullAnd a.user_id = b.user_idUnion allSelect * from awhere a.user_id is null 空key转换有时虽然某个key为空对应的数据很多，但是相应的数据不是异常数据，必须要包含在join的结果中，此时我们可以表a中key为空的字段赋一个随机值，是的数据随机均匀地分布到不同的reducer上。 把空值的 key 变成一个字符串加上随机数，就能把倾斜的数据分到不同的 reduce 上 ,解决数据倾斜问题。 需要用到Case When … Else…End语法123select n.*from nullidtable n full join bigtable o oncase when n.id is null then concat('hive', rand()) else n.id end = o.id; count(distinct) 去重统计 数据量大时，由于count distinct 操作需要用一个 reduce task 来完成， 这一个reduce 需要处理的数据量太大，会导致整个job很难完成，一般 count distinct 使用先group by 再 count的方式替换。123select count(distinct id) from bigtableselect count(id) from (select id from bigtable group by id) a 避免笛卡尔积尽量避免产生笛卡尔积，如join时不加on条件，或无效的on条件。hive只能使用1个reducer来完成笛卡尔积 行列过滤 列处理： 在查询中， 避免使用 select *, 使用条件限制取需要的列。 行处理： 在分区剪裁中，当使用join外关联时，如果将副表的过滤条件写在where后面，那么就会先全表关联，之后再过滤, 这样会耗费资源。 123456select o.id from bigtable b join ori o on.id = b.id where o.id &lt;=10;select b.id from bigtable bjoin (select id from ori where id &lt;=10) o on b.id = o.id) 12345678910111213SELECT a.price_close, b.price_closeFROM b JOIN a ON b.ymd = a.ymd AND b.symbol = a.symbolWHERE s.symbol = 'APPLE'--正确的写法是将 where 条件写在 on 后面SELECT a.price_close, b.price_closeFROM b JOIN a ON ( b.ymd = a.ymd AND b.symbol = a.symbol and s.symbol = 'APPLE' union all 子查询避免中使用 group by等 union all 子查询避免中使用 group by【替换 count(distinct) 除外】、count(distinct)、max、min等。 123456789101112131415161718192021222324252627with a1 as ( select user_account, hit_date from data where hit_date between '2018-12-01' and '2018-12-13' and nbtn_name like "%支付宝%" union all select user_account, hit_date from data where hit_date between '2018-12-01' and '2018-12-13' and nbtn_name like "%支付宝%")select hit_date, count(user_account) as pvfrom a1group by hit_date 避免不同数据类型进行关联 使用CAST函数对数据类型进行转换，语法为cast(value AS TYPE)123456789select a.price_close, b.price_closefrom a join b on a.user_id = cast(b.user_id as string)where hit_date between &apos;2018-11-01&apos; and &apos;2018-11-02&apos; and a.symbol = &apos;apple&apos; Hive的查询注意事项以及优化总结： 尽量尽早过滤数据，减少每个阶段的数据量。对于分区表要加分区，同时只选择需要使用到的字段 对历史库的计算经验 尽量原子化操作，尽量避免一个SQL包含复杂逻辑，可以使用中间表来完成复杂的逻辑 join操作 小表要注意放在join的左边，否则会引起磁盘和内存的大量消耗 如果union all的部分个数大于2，或者每个union部分数据量大，应该拆成多个insert into语句，实际测试过程中，执行时间能提升50% 用python脚本连接数据库作为一名数据分析师，日报、周报、月报数据一个也不能少。 相应的， 就要在数据库中提取大量的数据， 并处理大量的Excel表格。 在提取和处理数据的过程中， 对于一些重复性的劳动， 写个Python脚本来实现半自动化， 能够大幅提高自己的工作效率。 以下是自己工作中的一点总结经验。 首先， 用Python连接数据库 对于数据库的ip地址，用户名，密码等， 如果不清楚，或数据库连接不上， 需要和开发人员对接 12345678from pyhive import hive import timeconn = hive.Connection(host='ip地址', port=10000, username='用户名', database = 'default', auth='NOSASL')cursor = conn.cursor()# 获得连接的游标 设置开始和结束时间可以用python中的time函数设置时间 12startdate = '2018-09-01'enddate = '2018-09-19' 用Python中的format函数将日期传入{}中 python中写sql脚本时， 需要用\来进行换行符的转换, \后面不能有空格。 日期用两个{}来代替， 用format函数将开始日期与结束日期传入 123456789101112131415161718192021222324# 提取积分类uv,pv数据sql_jifenxinxi_an = """select count(distinct user_account) as uv, count(1) as pv from computer_view.data where hit_date between "&#123;&#125;" and "&#123;&#125;" and (btn_position like "服务-查询-积分信息%" or btn_home = "积分-扇形左" ) limit 1000""".format(startdate,enddate)# format 插入时间cursor.execute(sql_jifenxinxi_an)# 运行此语句cursor.fetchall()#fetchall():接收全部的返回结果行. 我们可以按照这个格式写工作中需要运行的多个SQL语句。 这样， 当脚本运行的时候， 我们可以腾出时间来去干其他工作， 等过一段时间，所有的SQL语句都跑完了， 我们再进行统一的整理。 其他拓展group by 升级版 需求背景 通过 a1 明细表，获得每个店铺，每个城市，每个省份，每个大区以及全国5月的份的成交量情况。 order_id shop city province area hit_date 1 A 西安 陕西 西北大区 2019-05-04 2 B 上海 上海 华东大区 2019-05-01 3 C 安康 陕西 西北大区 2019-05-02 4 D 北京 北京 华中大区 2019-05-21 5 E 延安 陕西 西北大区 2019-05-03 6 F 成都 四川 西南大区 2019-05-19 7 G 汉中 陕西 西北大区 2019-06-04 … … … … … … 10000 H 郑州 河南 西北大区 2019-05-29 解法1： 分别写5个sql 1234567-- 全国成交量selectcount(order_id) as salesfroma1where hit_date between '2019-05-01' and '2019-05-31' 12345678910-- 大区成交量selectarea,count(order_id) as salesfrom a1where hit_date between '2019-05-01' and '2019-05-31'group byarea 123456789101112-- 省成交量selectarea,province,count(order_id) as salesfrom a1where hit_date between '2019-05-01' and '2019-05-31'group byarea,province 1234567891011121314-- 城市成交量selectarea,province,city,count(order_id) as salesfrom a1where hit_date between '2019-05-01' and '2019-05-31'group byarea,province,city 12345678910111213141516-- 店铺成交量selectarea,province,city,shop,count(order_id) as salesfrom a1where hit_date between '2019-05-01' and '2019-05-31'group byarea,province,city,shop 这种方法太低效了， 还需要在excel中进行合并，比较麻烦。 解法2： 通过 union 和 union all 对查询结果进行纵向合并 union: 对合并后的结果进行去重处理 union all : 返回合并后的所有数据 1234567891011121314151617select null,null,null,null,count(order_id) as sales from a1 where hit_date between '2019-05-01' and '2019-05-31' union all select area, null , null ,null, count(order_id) as sales from a1 where hit_date between '2019-05-01' and '2019-05-31' group by areaunion all select area, province , null ,null, count(order_id) as sales from a1 where hit_date between '2019-05-01' and '2019-05-31' group by area, provinceunion all select area, province, city ,null, count(order_id) as sales from a1 where hit_date between '2019-05-01' and '2019-05-31' group by area, province, cityunion all select area, province, city ,shop, count(order_id) as sales from a1 where hit_date between '2019-05-01' and '2019-05-31' group by area, province, city, shop 上述式中有很多 null, 这是因为 union all 拼接的两个表的列数需要相等。 结果如下： 解法3： 利用 union all 比写出5个sql 再在 Excel 中处理简单很多，但是代码比较冗余。可以用grouping sets来进行优化。 此函数可以根据不同维度组合进行聚合。 将union all 语句用grouping sets 进行改写： 1234567891011121314151617181920212223242526select null, area, province, city, shop, count(orderid) as sales, grouping_idfrom a1where hit_date between '2019-05-01' and '2019-05-31'group by null, area, province, city, shopgrouping sets (null, area, (area,province), (area,province,city), (area,province,city,shop)order by grouping_id 得到结果与利用 union all拼接结果相同。group by后面的字段表示要分组聚合的全部字段， grouping sets后面为 group by 后面各种字段的组合。 grouping_id表示每个分组的序号。 1 表示第一个分组、2表示第二个分组。我们可以根据grouping_id 选取我们需要的组合。如果我们需要全国的成交量，则让 grouping_id = 1, 需要每个省的成交量，让 grouping_id = 3。 解法4： cube函数， 对group by的维度的所有组合进行聚合。 123456789101112131415select area, province, count(orderid) as sales, grouping_idfrom a1where hit_date between '2019-05-01' and '2019-05-31'group by area, provincewith cubeorder by grouping_id 以上代码对区域和省份进行了聚合， cube 会先对全部数据进行聚合，即 null, null， 再对area,null进行聚合，然后再对null, province进行聚合，最后再对area,province进行聚合。 解法5：rollup函数， 和cube类似，是针对 group by所有维度的部分组合。 123456789101112131415select area, province, count(orderid) as sales, grouping_idfrom a1where hit_date between '2019-05-01' and '2019-05-31'group by area, provincewith rolluporder by grouping_id 对比cube和rollup得到的结果，我们发现rollup少了null province 这个组合，rollup 是以最左侧指标为主进行组合聚合。 参考资料：讲讲 group 的plus版-张俊红]]></content>
      <categories>
        <category>数据分析技能</category>
      </categories>
      <tags>
        <tag>Hive</tag>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python-Pandas库学习]]></title>
    <url>%2F2018%2F09%2F27%2F%E6%8A%80%E8%83%BD-pandas%E5%BA%93%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[Pandas简介 Pandas是python数据分析中一个非常核心的数据库， 在日常的工作中经常需要使用Pandas库来对数据进行处理分析。Pandas的核心为两大数据结构， Series和DataFrame，Series用于存储一维数据， 而DataFrame存储多维数据。 常用的软件-Anaconda是数据分析中运行python的一款利器， 安装教程可参考Anaconda入门使用指南 读取与写入Excel数据 相对路径与绝对路径 读取文件夹内容 r（转义符）避免路径中的\被转义。路径中不加 \ 则需要把所有的\写成/。 1234567891011import pandas as pdimport numpy as npfrom pandas import Series, DataFrameimport osfile_list = os.listdir(r'E:\工作文件\周报\周数据\测试\0902-0908')print(file_list, '\t')# 读取当前文件夹地址os.getcwd() 读取xls格式Excel表 123df = pd.read_excel('E:/工作文件/an-商品汇总-uv.xls')df = pd.read_excel(r'E:\工作文件\an-商品汇总-uv.xls') 读取csv格式Excel表 1234567df = pd.read_csv('E:/工作文件/周报/周数据/测试/0902-0908/商品汇总.csv')# 读取csv文件，并用 分隔符分割df = pd.read_csv(r'E:\商品汇总.csv', sep = " ")# 只读取文件前两行df = pd.read_csv(r'E:\商品汇总.csv', nrows = 2) 读取显示编码错误 123456789101112131415# 显示错误为：# UnicodeDecodeError: 'utf-8' codec can not decode byte 0xb5 in position 0: invalid start byte# 修改方式df = pd.read_csv(path + '登记用户 20191127.csv',encoding="gbk" )# 当文件路径包含中文解析错误时，设置 engine 参数来消除这个错误# 错误原因， 当调用read_csv方法时，默认使用C语言作为解析语言，只需要将默认值c语言更改为python# 如果文件格式是 csv usf-8, 那么编码也改为 utf-8-sig# 如果文件格式是 csv格式， 则编码格式为 gbkdf = pd.read_csv('登记用户 20191127.csv', engine = 'python', encoding = 'utf-8-sig') 读取txt格式数据 123456df = pd.read_table(r'C:\Users\Administrator\Desktop\haha.txt', sep = ' ')with open(r'C:\Users\Administrator\Desktop\haha.txt', 'r') as f: df = f.readlines() df = np.loadtxt(r'C:\Users\Administrator\Desktop\haha.txt') # 将txt文件存为numpy数组 读取excel中的sheet名称 12345678910111213141516171819202122232425262728df = pd.read_Excel(r'E:\工作文件\an-商品汇总-uv.xlsx', sheet_name = 'sheet1')# 传入sheet的顺序，从0开始计数df = pd.read_Excel(r'E:\工作文件\an-商品汇总-uv.xlsx', sheet_name = 0)# 读取sheet,并制定文件中的第几行做行索引df = pd.read_Excel(r'E:\工作文件\an-商品汇总-uv.xlsx', sheet_name = 0, index_col = 0)# 读取sheet文件， 并制定文件中的第几列做列索引df = pd.read_Excel(r'E:\工作文件\商品汇总.xlsx', sheet_name = 0, head = 1)# 当本地文件过多时，可以通过设定 usecols 参数来指定要导入的列df = pd.read_Excel(r'E:\商品汇总.xlsx', usecols = 0)# uescols = [0,2]# 读取excel中所有sheet，并进行合并rbook = []kong_data = os.listdir(r'F:\省资源位')for file_name in kong_data: data_excel = pd.ExcelFile(r'F:\省资源位\\'+file_name) sheet = data_excel.sheet_names for i in sheet: data_button_rest = pd.read_excel(r'F:\省资源位\\'+file_name, sheet_name= i ) rbook.append(data_button_rest) result_df =pd.concat(rbook)datas_excel = pd.DataFrame(result_df) 将运行的所有数据都展现出来， 而不是只展现最后一条 12from IPython.core.interactiveshell import InteractiveShellInteractiveShell.ast_node_interactivity = "all" 将数据写入Excel表， 并输出 1234567891011121314151617181920212223242526# 写入数据df.to_excel('C:/Users/Administrator/Desktop/'+'商品分类.xlsx')df.to_excel(r'C:\Users\Administrator\Desktop\\'+'商品分类.xlsx')df.to_excel(r'C:\Users\Administrator\Desktop/'+'商品分类.xlsx')# 写入数据，且不带索引df.to_excel('C:/Users/商品分类.xlsx', sheet_name = '首页', index = False)# 设置要导出的列df.to_excel('C:/Users/商品分类.xlsx', sheet_name = '首页', index = False, columns = ['ID', '销量’])# 设置编码格式df.to_excel('C:/Users/商品分类.xlsx', sheet_name = '首页', index = False, encoding = 'utf-8')# 缺失值、无穷值处理df.to_excel('C:/Users/商品分类.xlsx', sheet_name = '首页', index = False, na_rep = 0, # 缺失值用0填充 inf_rep = 0 # 无穷之用0填充 )# 导出csv文件，设置分隔符df.to_excel('C:/Users/商品分类.xlsx', sheet_name = '首页', index = False, sep = ',' ) 将求出的数据存储在excel中的多个sheet中 123456789import pandas as pdfrom openpyxl import load_workbook writer = pd.ExcelWriter('F:/notebooks/zhoushuju.xlsx')btn_navigation.to_excel(writer, sheet_name = '底部导航')shouye_top20.to_excel(writer, sheet_name = '首页top20')writer.save()writer.close() 其他数据格式 12345678910111213141516171819# 从SQL表/库导入数据 import pymysqleng = pymysql.connet(host= '100.129', user = 'root', password = '1234', df = 'db', charset = 'ugf8')query = """select * from android_log """df = pd.read_sql(query, eng)# 导出数据到SQL表 df.to_sql(table_name, eng)``` 8. 常见问题* 当文件有中文时， 可能会出现错误：Initializing from file failed 有中文， 可以用此方法解决```pythonf = open(‘我的文件.csv’)res = pd.read_csv(f) 查看大文件有多少列 1234data = open('E:/用户明细.csv')data1 = pd.read_csv(data, iterator=True)data2 = data1.get_chunk(5)print(data2) 迭代器 对输出数据进行处理pandas的数据输出显示设置 对表中某一列元素进行相同操作 123df[&apos;金额&apos;].apply(lambda x:x+1)df[&apos;金额&apos;] +2 对表中每一个元素进行相同操作 1df.applymap(lambda x:x+1) 123456789101112131415import numpy as npimport pandas as pddf = pd.DataFrame(np.random.randn(150, 150))# pd.set_option('expand_frame_repr', False) #数据超过总宽度后，是否折叠显示pd.set_option('display.width', 100) #数据显示总宽度pd.set_option('max_rows', 100) #显示最多行数，超出该数以省略号表示pd.set_option('max_columns', 100) #显示最多列数，超出该数以省略号表示pd.set_option('max_colwidth', 16) #设置单列的宽度，用字符个数表示，单个数据长度超出该数时以省略号表示pd.set_option('large_repr', 'truncate') #数据超过设置显示最大行列数时，带省略号显示/若是info则是统计信息显示pd.set_option('show_dimensions', True) #当数据带省略号显示时，是否在最后显示数据的维度print(df)pd.set_option('max_info_columns', 100) #当列数超过这个值时，调用df.info()函数时不会统计每列的非空值。print(df.info()) 将数据变成小数形式12345678910import pandas as pd inputfile = '../data/electricity_data.xls'outputfile = './electricity_data_analyze1.xls' data = pd.read_excel(inputfile)data[u'线损率'] = (data[u'供入电量']-data[u'供出电量'])/data[u'供入电量'] #data[u'线损率']的类型为series； data[u'线损率']为小数data[u'线损率'] = data[u'线损率'].apply(lambda x: format(x, '.2%')) #Series.apply()让序列的值依次在lambda函数中执行； data['线损率']由小数转化为百分数 data.to_excel(outputfile, index=False) 描述数据 表信息 1df.info() 显示数据的行列数 1df.shape 查看数据格式dtpyes 1df.dtypes 显示列名、元素 12df.columnsdf.values 添加默认列名 12# 如果数据没有标题行，可用pandas添加默认的列名df = pd.read_excel('x.xlsx', header = None) 显示前数据前5行 12df.head(5)df[['标题', '客户端uv']].head() 显示数据后5行 1df.tail(5) 值 1df.values 读取a列 1df['a'] 找到重复值 1df.duplicated() 显示数据唯一值（unique函数） 12# 数据有0， 是因对缺失值进行了填充df['经纪人级别'].unique() 对第几行数据不读取 12#不读取哪里数据，可用skiprows=[i]，跳过文件的第i行不读取df = pd.read_excel('x.xlsx',skiprows=[2] ) 对缺失值进行识别 12# 所有缺失值显示为Truepd.insull(df) # df.isnull() 计算 1234567891011#计算此data的数量df['data'].value_counts()# 升序计数df['data'].value_counts(ascending = True)# 升序计数并分组df['data'].value_counts(ascending = True, bins = 2)# 计数df['data'].count() 字符和数值之间的转化 1234int() # 转化成整数float() # 转化成浮点数str() # 转化成字符type() # 查看格式 获取数据分布情况 1data.describe() 数据清晰 删除空值 （dropna函数） DataFrame中的空值处理 1234df.dropna(how='any')df.dropna(how = 'all') 123456789用法：DataFrame.drop(labels=None,axis=0, index=None, columns=None, inplace=False)参数说明：labels 就是要删除的行列的名字，用列表给定axis 默认为0，指删除行，因此删除columns时要指定axis=1；index 直接指定要删除的行columns 直接指定要删除的列inplace=False，默认该删除操作不改变原数据，而是返回一个执行删除操作后的新dataframe；inplace=True，则会直接在原数据上进行删除操作，删除后无法返回。 123# 删除包含 集团 二字 的行read_data = df[- df[&apos;所属省份名称&apos;].isin([&apos;集团&apos;])] 数值删除 删除列 1234567# 删除列, axis=1表示删除列df.drop(["销售额", "ID"], axis = 1)df.drop(columns = ["销售额", "ID"])# 传入列位置df.drop(df.columns[[4,5]], axis =1) 删除行 1234567891011# 删除行，筛选行名df.drop([&apos;一&apos;,&apos;二&apos;], axis = 0)df.drop(index = [&apos;一&apos;, &apos;二&apos;])# 删除行，筛选行索引df.drop(df.index[[0,1]], axis = 0)# 只要年龄小于40的用户df[df[&apos;ID&apos;] &lt; 40] 填充（fillna函数） 123456789# 空值用0填充df.fillna(value=0)df.replace(np.NaN, 0)# 用均值对空值进行填充df['时长'].fillna(df['时长'].mean())# 按照不同列进行填充df.fillna(&#123;'性别' : '男'&#125;) 更改数据格式，更改数据类型 123# 将数据格式int64,改为float格式df['大区'].astype('float64') 更改列名称, 修改列名。 123df.columns = [['导航','uv', 'pv','户均点击']]df.rename(columns=&#123;'IM渠道': '渠道'&#125;) 添加修改索引 12345678# 添加索引df.index = [1,2,3,4]# 修改索引,重新设置df = df.set_index['标题']# 重命名索引df.rename (index = &#123;1: '一'&#125;) 重置索引 12345678910DataFrame.reset_index(level=None, drop=False, inplace=False)# 默认将所有index转化成columnsdf.reset_index()#将第0级索引转化为 columnsdf.reset_index(level=0)# 将原索引删除，不加入columnsdf.reset_index(drop = True) 删除重复值 Pandas删除数据的几种情况 12345678# 默认第一次出现的保留，其余删除df['门店'].drop_duplicates()# 最后一次出现的保留，其余删除df['门店'].drop_duplicates(keep = 'last')# 多列去重df.drop_duplicates(subset = ['姓名', '唯一识别码']) 对列表内的值进行替换 123456789# 一对一替换df['ID'].replace('1053', '110')# 多对一替换df['ID'].replace(&#123;'1053': '110', '230': '33'&#125;)df.columns.str.replace(' ', '_') 对数据进行处理 对两个数据进行合并- merge, join, concat函数 merge 123456789101112131415161718192021222324252627# 按照轴把多个对象拼接起来pd.concat(df1, df2)# join函数适合根据索引进行合并，合并索引相同但列不同的对象# merge函数，根据一个或多个键连接多行, 相当于excel中的vlookup# 将left和right进行合并pd.merge(left, right)# 指定以key为键进行合并pd.merge(left, right, on = 'key') pd.merge(name_3, name_1, left_on = ['ming'], right_on = ['标记'])# key2列不相同的部分会直接舍弃掉pd.merge(left, right, on = ['key', 'key2'])# 保留key2列不相同的部分pd.merge(left, right, on = ['key', 'key2'], how = 'outer')# 不相同的部分指定以左表为基准pd.merge(left, right, on = ['key', 'key2'], how = 'left')# 重复列名处理# pd.merge()会自动给这些重复名添加后缀_x、_y，也可以自己命名。pd.merge(df1,df2, on = 'id', suffixes= ['_L', '_R']) concat函数, 按照标题进行拼接 12345678# 普通合并pd.concat([df1, df2])# 索引设置pd.concat([df1, df2], ignore_index= True)# 合并后删除重复值pd.concat([df1, df2], ignore_index = True).drop_duplicates() 对数据进行排序 12345678910111213# 按照ID进行升序排列# 按照ID进行降序排列df.sort_values(by = ['ID'], ascending = False)# 在保证销售额列降序的情况下，对ID列进行升序处理data.sort_values(by = ['销售额', 'ID'],ascending = [False, True], inplace = True)# 默认将ID是缺失值的列显示在最后面df.sort_values(by = ['ID'])# 将ID是缺失值的列显示在最前面df.sort_values(by = ['ID'], na_position = 'first') 对数值进行排名 1234567891011# 对应Excel中的 rank.avg函数df['ID'].rank(method= 'average')# 按值在所有的排列数据中出现的先后顺序排名df['ID'].rank(method = 'first')# 与Excel中rank.eq 函数的功能一样df['ID'].rank(method = 'min')# 与min相反，取重复值对应的最大排名df['ID'].rank(method = 'max') 对数据进行分组 123456789# 如果price列的值&gt;3000，group列显示high，否则显示lowdf[&apos;group&apos;] = np.where(df[&apos;客户当天发送消息数&apos;] &gt; 5,&apos;high&apos;,&apos;low&apos;)# 对符合多个条件进行分组# 符合经纪人级别为A1且经纪人响应时长&gt;24的在sign列显示为1df.loc[(df[&apos;经纪人级别&apos;] == &apos;A1&apos;) &amp; (df[&apos;经纪人响应时长&apos;]&gt;= 24.0), &apos;sign&apos;]=1 对数据进行分列 12345678pd.DataFrame((x.split('网') for x in df['客户注册渠道']), index=df.index,columns=['客户注册渠道','size'])&lt;!-- df = pd.DataFrame((x.split('.') for x in 首页jhrj_1['所属省份编码']), index=df.index,columns=['客户注册渠道','size']) --&gt;# 分列完对数据进行合并df1 = pd.merge(首页jhrj_1, df, left_index = True, right_index = True) 新增一列 123data = data.assign(ration = [4, 2, 5, 6, 7, 8, 2, 9, 4])data[&apos;rations&apos;] = [5, 2, 5, 6, 7, 8, 2, 9, 4] 对数据进行切分 123456# 指明切分区间pd.cut(df[&apos;年龄&apos;], bins = [0,3,6,10])# 将数据切成3份pd.qcut(df[&apos;年龄&apos;],3 ) 取出的数据， 指定取到小数点几位数？ 123456# 取到小数点后3位for i in a : print(&quot;%.3f&quot;%c)# 设置小数点位数，四舍五入df[&apos;cnts&apos;].round( decimals = 2) 将 list 格式转化成 DataFrame 格式 1df = pd.DataFrame(data, columns = [&apos;省份&apos;, &apos;按钮名称&apos;, &apos;uv&apos;, &apos;pv&apos;] ) 数据选择 选择某一列/ 某几列 123456789101112# 普通索引- 根据名称进行选择df['客户端uv']df[['标题', '客户端uv']]# 位置索引 / 切片索引， 根据所在第几列进行选择# : 表示选择所有的行， 逗号后面表示要选择列的位置区域df.iloc[:, [0,2]] # 获取第1列和第3列的数值 选择某一行/某几行 12345678910111213# 普通索引-locdf.loc['第一行']df.log[['第一行', '第二行']]# 位置索引，切片索引 # 选择第一行df.iloc[0]# 选择第一行和第二行df.iloc[[0,1]] 根据指定条件进行筛选 123456789101112131415161718# 选择年龄小于200的数据df[df['年龄'] &lt; 200] #年龄小于200，且id小于300df[(df['年龄'] &lt; 200) &amp; (df['id'] &lt; 300)]df[np.logical_and(df['年龄'] &gt; 10, df['id'] &gt; 5)]# A列值大于10，或 B列值大于5df[(df['A'] &gt; 10) | (df['C'] &gt;20)]df[np.logical_or(df['A'] &gt; 10, df['C'] &gt; 20)]# 当 A列的值大于13时， 显示B，c列的值df[['B','C']][df['A']&gt;13] 行列同时选择 普通索引+普通索引选择指定的行和列 1df.loc[['第一行', '第三行'], ['订单号’, 'ID']] 位置索引 + 位置索引选择指定的行和列 123df.iloc[[0,1], [0,2]]df.iloc[0:2, 1:2] 布尔索引+ 普通索引 1df[df['年龄']&lt; 200][['订单编号', 'ID']] 切片索引+ 普通索引 1df.ix[0:2, ['订单变化', 'ID']] 按条件进行提取 12345678910111213# 用isin函数进行判断# 使用isin函数根据特定值筛选记录。筛选A值等于10或者13的记录df[df.A.isin((10, 13))]# 查看这一列是否包含某个值df['级别'].isin(['A3']) # 先判断是否包含，然后将符合条件的数据提取出来。df.loc[df['级别'].isin(['A3','M4'])] 数据汇总 对数据进行分类 - group by函数 12345678# 按照某列分组求和df.groupby('渠道').sum()# 按照多列分组求和df.groupby(['渠道', 'ID']).sum()# 对分组后的结果进行重新索引df.groupby('渠道').sum().reset_index() aggregate方法 12345678# 对同一列 先做计数汇总运算，再做汇总运算df.group('渠道').aggregate(['count', 'sum'])# 针对不同的列做不同的汇总运算df.groupby('渠道').aggregate(&#123;'ID' : 'count', '销量' : 'sum'&#125;) pivot_table-数据透视表 123# 为方便处理， 一般需要对结果进行重置索引pd.pivot_table(df, values = 'ID', columns = '渠道', index = '客户分类', aggfun = 'count').reset_index() pd.pivot_table(data, values, index, columns, aggfunc, fill_value, margins, dropna, margins_name = ‘All’) data: 数据values: 对应的值index: 对应的行columns: 对应的列aggfunc : 对values的计算类型fill_value : 对空值的填充值margins: 是否显示合计列dropna: 是否删除缺失值，如果为真，则一整行全删除margins_name: 合计列的列名 对数据进行映射 12# 用map函数对字典进行映射， 新加一列data[&apos;upper&apos;] = data[&apos;group&apos;].map(dataUpper) 数据采样 12345678910111213# 简单随机抽取sampledf.sample(n=3)# 设置采样权重# 需要对每一行进行权重设置，列表行数少可行，过多不可行# 假设有4行数据，设置采样权重weights = [0, 0, 0.5, 0.5]df.sample(n=4, weights=weights)## 确定采样后是否放回# 采样后放回，Truedf.sample(n=6, replace=True) 统计计算 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849# 计算每一列的个数df.count()# 计算每一行的个数df.count(axis = 1)# 求和df.sum()df.sum(axis = 1)# 中位数df.median()# 求和df.sum()# 求最大值df.max()# 求最小值df.min()# 求众数df.mode()# 求方差df.var()# 求标准差df.std()# 求分位数df.quantile(0.75, axis = 1)# 描述统计 describe函数#自动生成数据的数量，均值，标准差等数据#round（2）,显示小数点后面2位数，T转置df.describe().round(2).T# 标准差std()df['经纪人响应时长'].std()# 协方差covdf['经纪人当天发送消息数'].cov(df['客户当天发送消息数']# 相关性分析corrdf['客户当天发送消息数'].corr(df['经纪人当天发送消息数']) 数值计数 123456789# 查看不同值出现的次数， #默认进行排列df['ID'].value_counts()# 查看不同值出现的占比, #默认进行排列df['ID'].value_counts(normalize = True)# 查看不同值出现的占比， 不进行排列df['ID'].value_counts(normalize = True, sort = False) 插入数据 12# 在 insert方法中，指明要插入的位置、插入新列的列名，以及要插入的数据df.insert(2, '销售品id', ['01', '02']) 对数据进行转置 1df.T 索引重塑 12345# 将表格型数据转化成树形数据df.stack()# 将树形数据转化成表格型数据df.stack().unstack() 长宽表转换 宽表 长表 将长表转化成宽表,对数据进行透视, 相当于Excel中的数据透视表功能。 1df.pivot_table(index = ['computer','name'], columns = 'year', values = 'sale') 将宽表转换成长表 12# 方法1： melt()df.melt(id_vars = ['company', 'name'], var_name = 'year', value_name = 'sale') 12# 方法1： stack()# 在保持行索引不变的前提下，将列索引转化成行索引 对字符串进行操作 大小写 12a.lower()a.upper() 长度 12# 长度a.len() 去除空格 123a.strip()a.lstrip()alrstrip() 切分与分列、 合并 123456789101112131415161718192021222324252627282930313233343536#切分a.split('_')# 切分， 且成为新列a.split('_', expand = True)# 对切分进行限制, 只切1次a.split('_', expand = True, n=1)# 查看是否包含a.str.contains('A')# 分列s.str.get_dummies(sep= '|')df = 首页jhrj_1['所属省份编码'].str.split('.') # expand=True 可以把用分割的内容直接分列首页jhrj_1["所属省份编码1"]=df[0]# 切分并在原表中进行合并首页jhrj_2 = pd.merge(首页jhrj_1, pd.DataFrame(首页jhrj_1['所属省份编码'].str.split('.', expand = True) ), how = 'left', left_index = True, right_index = True)# pandas对dataframe中的某一列使用split做字符串切割：# words = df['col'].split()# 报错：# AttributeError: 'Series' object has no attribute 'split'# 原因是df['col']返回的是一个Series对象，需要先把Series对象转换为字符串：pandas.Series.str.split# words = df['col'].str.split()对两列数据进行合并df['省份_名称'] = df['省份'].str.cat(df['名称'],sep = '_')首页jdt_1['省份_标题'] = 首页jdt_1['所属省份编码'].astype(str).str.cat(首页jdt_1['标题'],sep = '_') 日期-时间 当前日期 123456789101112131415161718192021import timefrom datetime import datetime, time, timedelta# 返回当前日期和时间datetime.now()# 返回当前时间的年datetime.now().year# 返回当前时间的月份datetime.now().month# 返回当前日期的日期datetime.now().day# 返回当前时刻在周几# python周几默认是从0开始的datatime.now.weekeday() + 1# 返回当前时间所在周的周数datatime.now.isocalendar()[1] 返回指定日期 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263# 只展现日期datetime.now.date()# 只展示时间datetime.now.time()# 显示当前日期datetime.now().strftime('%Y-%m-%d')#2018-12-22datetime.now.strftime('%Y-%m-%d %H:%M:%S")# 将时间格式转化成字符串格式now=str( datetime.now())# 将字符串格式转化为时间格式parse(str_now) # 往后推一天date+ Day(1)# 往后推一个小时date + Hour(1)# 往前推一天date - Day(1)# 昨天ysd = now - timedelta(days = 1)#本月第一天ysd = now.replace(day = now.day-1)# 上月最后一天lastmonth_end = now.replace(day = now.day-1) - timedelta(days=1)# 上月第一天lastmonth_first = now.replace(month = now.month-1, day =1)lastmonth_first = lastmonth_end.replace(day=1)#提取2016年11月2号的数据df['2016-11-02' : '2016-11-02']dt_time = dt.datetime(year = 2018, month=9, day = 17, hour = 22, minute = 43)# 构造时间序列， 构造十个日期， 每12分钟一次pd.Series(pd.date_range(start = '2018-09-17 22:43:00', periods = 10, freq = '12min'))# 取所有8点到12点之间的数据, 不包含8点和12点data[(data.index.hour &gt; 8) &amp; (data.index.hour &lt; 12)]# 包含8点到12点data.between_time('08:00', '12:00')import datetimefrom dateutil.relativedelta import relativedelta begin = datetime.date(2019,1,1)end = datetime.date(2019,1,31)for i in range(1,10): first = d + relativedelta(months=i) last = end + relativedelta(months=i) 处理月与月之间时间不连续问题 1234567891011121314151617181920212223import time from datetime import datetime, time,timedelta# 指定昨天df = datetime.now() - timedelta(days = 1)# 月初第一天startdates = (df.replace(day = 1)).strftime('%Y-%m-%d')# 昨天enddates = (df - timedelta(days = num)).strftime('%Y-%m-%d')# 上月第一天last_moth_f = df.replace(month =df.month-1, day=1).__format__("%Y-%m-%d")# 上月最后一天last_moth_e = df.replace(month = df.month-1, day =1).strftime('%Y-%m-31')# 目标值月份mubiao_dates = startdates[0:7]# 将字符串转换为日期df = datetime.now() - timedelta(days = 1)day1 = (df.replace(day = 1)).strftime('2019-11-%d')first = datetime.strptime(day1, "%Y-%m-%d") 自动发送邮件12import smtplibfrom email import encoders]]></content>
      <categories>
        <category>数据分析技能</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python基础学习]]></title>
    <url>%2F2018%2F07%2F25%2F%E6%8A%80%E8%83%BD-python%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[数 整数-int 123i = 1# 查看变量的类型type(i) 浮点数-float 12340.2 * 0.10.020000000000000004 浮点数在计算机中表输入的十进制浮点数仅由实际存储在计算机中的近似的二进制浮点数表示,二进制来表达 1/10 是一个无限循环小数:0.0001100110011001100110011001100110011001100110011…,Python 只打印机器中存储的二进制值的十进制近似值。 如何限制显示的小数点个数 1print(&quot;&#123;:.4f&#125;&quot;.format(0.1*0.4)) 字符串-str 字符串的表示方式： python中有3种表示字符串的方式——单引号，双引号，三引号。 单引号和双引号的作用是相同的, 但双引号中可以将包含的特殊字符单引号输出，而单引号要输出’需要/转义 123456str = &apos; \&apos;hello world\&apos; &apos;print(str)str = &quot;&apos;hello python&apos;&quot;print(str) 三引号的用法特殊，三引号中可以输入单引号、双引号或换行符等字符,也可用作制作文档字符串 123str = &apos;&apos;&apos;&apos;hello&apos;/&quot;world&quot;&apos;&apos;&apos;print(str) 常用的字符串处理方法 1234# 重复字符串sta = &apos;hi&apos;print (sta * 2) 1234# 切片sta = &apos;1234567890&apos;print(sta[2:9:2]) 123456789#去除空格name = &apos; zhang yu &apos;# 去除左侧空格print(name.lstrip())# 去除右侧空格print(name.rstrip())# 去除两侧空格print(name.strip()) 123456789101112# 分割字符串#split()函数通过制定分隔符对字符串进行切片name = &quot;zhang and yu and han&quot;print(name.split())print(name.split(&apos; &apos;,2))print(name.split(&apos; and &apos;))# partition()函数将目标字符串分割为两个部分，返回一个三元元组（head,sep,tail），包含分割符url = &quot;https://zhangandyu.github.io//2018&quot;print( url.partition(&quot;//&quot;))print(url.rpartition(&quot;//&quot;)) 1234567# 替换字符串#str.replace(old, new,max)# max 可选字符串不能超过max次str = &quot;this is a apple&quot;print (str.replace(&quot;is&quot;, &quot;was&quot;)) print (str.replace(&quot;is&quot;, &quot;was&quot;, 1)) 1234# 拼接字符串a = &apos;_&apos;name = (&apos;zhang&apos;, &apos;and&apos;, &apos;yu&apos;)print(a.join(name)) 12345678910#查找字符串是否包含子字符串#str.find(str, beg=0, end=len(string))a = &apos; this is a apple&apos;b = &apos;is&apos;#从下标3开始，查找在字符串里第一个出现的子串，返回结果：3print(a.find(b,2)) #从下标5开始，查找在字符串里第一个出现的子串，返回结果：6print(a.find(b,5)) 12345678910111213#判断字符串是否以指定的前后缀结尾# str.startswith(str, beg=0,end=len(string))a = &apos;this is a apple&apos;b = &apos;th&apos;c = &apos;is&apos;print(a.startswith(b))print(a.startswith(c,2))a = &apos;this is a apple&apos;b = &apos;le&apos;c = &apos;app&apos;print(a.endswith(b))print(a.endswith(b,10)) 1234567891011121314151617181920212223#其他函数# 检测数字str.isdigit() # 检测字符串是否只由数字组成str.isnumeric() # 检测字符串是否只由数字组成,这种方法是只针对unicode对象str.isdecimal() # 检查字符串是否只包含十进制字符。这种方法只存在于unicode对象# 检测字母str.isalpha() # 检测字符串是否只由字母组成# 检测字母和数字str.isalnum() # 检测字符串是否由字母和数字组成# 检测其他str.isspace() # 检测字符串是否只由空格组成str.islower() # 检测字符串是否由小写字母组成str.isupper() # 检测字符串中所有的字母是否都为大写str.istitle() # 检测字符串中所有的单词拼写首字母是否为大写，且其他字母为小写str.capitalize() # 将字符串的第一个字母变成大写,其他字母变小写str.lower() # 转换字符串中所有大写字符为小写str.upper() # 将字符串中的小写字母转为大写字母str.swapcase() # 对字符串的大小写字母进行转换max(str) # 返回字符串 str 中最大的字母min(str) # 返回字符串 str 中最小的字母len(str) # 返回字符串的长度str(arg) # 将 arg 转换为 string 布尔值 and-逻辑与 or-逻辑或 not-逻辑非 not的优先级大于and和or的优先级，而and和or的优先级相等。 逻辑运算符的优先级低于关系运算符，必须先计算关系运算符，再计算逻辑运算符。 变量命名规则 只能包含字母、数字和下划线 不能包含空格 不能将python关键字和函数名用作变量名 变量名应简短又具有描述性 慎用小写字母l和大写字母O 序列 什么是序列 序列是Python中最基本的数据结构。 python中有6个序列的内置类型,包括列表、元组、字符串、Unicode字符串、buffer对象和xrange对象。 对于序列，都可以使用一下操作： 索引 切片 加 乘 成员检查in和not in 计算序列的长度len() 取序列中的最大、最小值max()和min() 列表 列表是最常用的Python数据类型，它可以作为一个方括号内的逗号分隔值出现 列表适合用于存储在程序运行期间可能变化的数据集。 列表是可以修改的， 这对处理网站的用户列表或游戏中的角色列表至关重要。 列表对象方法 12 list.append(x)# 把一个元素添加到列表的结尾 12 list.extend(x)# 将一个给定列表中的所有元素都添加到另一个列表中 12 list.insert(i,x)# 在指定位置插入一个元素 12list.remove(x)# 删除列表中值为 x 的第一个元素 12list.pop(i)# 从列表的指定位置删除元素，并将其返回 12 list.clear()# 从列表中删除所有元素 12list.index(x)# 返回列表中第一个值为 x 的元素的索引 12list.count(x)# 返回 x 在列表中出现的次数 12 list.sort()# 对列表中的元素进行排序 12list.sorted()# 对列表中的元素进行临时排序 12list.reverse()# 倒排列表中的元素 12list.copy()# 返回列表的一个浅拷贝 12list.len(x)#返回列表的长度 用列表实现栈和列队 栈是一种后进先出的数据结构，我们可以使用列表的append()和pop()方法了实现 123a = [1,2]a.append(3) #入栈a.pop() # 最后一个元素出栈 队列是一种先进先出的数据结构，我们可以使用列表的append()和pop(0)方法了实现 123a = [2,1]a.append(1) # 入队列a.pop(0) # 第0个元素出队列 列表推导式 为从序列中创建列表提供了一个简单的方法。 普通方法 12345a = []for i in range(20): a.append(i ** 2)print(a)# i 依然存在 123456b = []for x in [1,2,3,4]: for y in [2,3,4]: if x !=y: b.append((x,y))print(b) 推导式 12a = [i**2 for i in range(20)]print(a) 1[(x,y) for x in [1,2,3,4] for y in [2,3,4] if x !=y] 12from math import pi[str(round(pi, i)) for i in range(1, 16)] 12345matrix = [ [1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]][[row[i] for row in matrix] for i in range(4)] 元组 元组为不可变得列表， 在需要创建一系列不可修改的元素时使用。 只有一个元素元组中只包含一个元素时， 需要在元素后面添加逗号，否则括号会被当做运算符使用 12zy = (2,)zy[0] 修改元组 对元组进行连接组合 1234na = (&apos;z&apos;, &apos;y&apos;)me = (&apos;y&apos;, &apos;u&apos;)name = na + meprint(name) 给元组变量赋值 123na = (&apos;zy&apos;, &apos;yu&apos;)na = (&apos;y&apos;, &apos;u&apos;)print(na) 元组运算符 123456789101112# 计算元组个数len((2,45, 67, 8, 9))# 连接(1,2,3, 4) + (4, 5, 6)# 复制(1,2,3, 4)* 3#迭代 for i in (12, 3,4 , 5): print(i) 将列表转换为元组 123list = [ &apos;z&apos;, 1, 2, 3, 4, &apos;u&apos;]tup = tuple(list)print(tup) 映射和集合字典 字典：将相关信息关联起来 访问字典 12man = &#123;&apos;name&apos;:&apos;zhangyu&apos;, &apos;xingbie&apos;:&apos;man&apos;, &apos;hige&apos;:165&#125;print(man[&apos;name&apos;]) 添加键-值对 12man[&apos;home&apos;] = &apos;xian&apos;man 修改字典中的值 123man = &#123;&apos;name&apos;:&apos;zhangyu&apos;, &apos;xingbie&apos;:&apos;man&apos;, &apos;hige&apos;:165&#125;man[&apos;hige&apos;] = 170man 删除键-值对 123man = &#123;&apos;name&apos;:&apos;zhangyu&apos;, &apos;xingbie&apos;:&apos;man&apos;, &apos;hige&apos;:165&#125;del man[&apos;xingbie&apos;]man 遍历所有的键-值对 1234man = &#123;&apos;name&apos;:&apos;zhangyu&apos;, &apos;home&apos;:&apos;xian&apos;, &apos;hige&apos;:165, &apos;girfriend&apos;:&apos;null&apos;&#125;for key, value in man.items(): print( key,&quot;:&quot; , value) 分别遍历所有的键-值 1234567man = &#123;&apos;name&apos;:&apos;zhangyu&apos;, &apos;home&apos;:&apos;xian&apos;, &apos;hige&apos;:165, &apos;girfriend&apos;:&apos;null&apos;&#125;for key in man.keys(): print( key) for value in man.values(): print(value) 按倒序顺序遍历分别遍历所有的键-值 12for key in sorted(man.keys()): print( key) 字典列表 12345678man = &#123;&apos;name&apos;:&apos;zhangyu&apos;, &apos;home&apos;:&apos;xian&apos;, &apos;hige&apos;:165, &apos;girfriend&apos;:&apos;null&apos;&#125;alien = &#123;&apos;color&apos;:&apos;green&apos;, &apos;points&apos;:5&#125;computer = &#123;&apos;name&apos;:&apos;wangzhou&apos;, &apos;num&apos;: 40&#125;alients = [man, alien, computer]for i in alients: print(i) 在字典中存储列表 12345678910province = &#123; &apos;name&apos;:[&apos;zhangyu&apos;, &apos;han&apos;, &apos;dou&apos;], &apos;home&apos;:[&apos;xian&apos;, &apos;beijing&apos;], &apos;hige&apos;:[165, 170, 370, 2389]&#125;for na, las in province.items(): for la in las: print(na, la) 在字典中存储字典 12345678province = &#123; &apos;man&apos; :&#123;&apos;name&apos;:&apos;zhangyu&apos;, &apos;home&apos;:&apos;xian&apos;, &apos;hige&apos;:165, &apos;girfriend&apos;:&apos;null&apos;&#125;, &apos;alien&apos; : &#123;&apos;color&apos;:&apos;green&apos;, &apos;points&apos;: 5&#125;, &apos;computer&apos; : &#123;&apos;name&apos;:&apos;wangzhou&apos;, &apos;num&apos;: 10&#125;&#125;for i, a in province.items(): print(i, a) 字典键的特性 不允许同一键出现两次，创建时如果同一键被赋值两次， 后一个值会被记住。键必须不可变， 可以用数字，字符串，或元组充当，但不能用列表 12dict = &#123;&apos;name&apos;: &apos;zhang&apos;, &apos;name&apos;:&apos;yu&apos;&#125;dict python中关于字典的函数 1234567891011121314151617181920212223242526272829303132333435# 删除字典内所有元素dict.clear()#返回一个字典的浅复制dict.copy()# 创建字典seq = (&apos;Google&apos;, &apos;Runoob&apos;, &apos;Taobao&apos;)dict = dict.fromkeys(seq,10)dict#返回指定键的值，如果值不在字典中返回设定值dict1.get(&apos;Google&apos;, 40)#和get()类似, 但如果键不存在于字典中，将会添加键并将值设为设定值dict1.setdefault(&apos;google&apos;, &apos;20&apos;)dict1#把字典dict2的键/值对更新到dict里dict1=&#123;&apos;Google&apos;: 10, &apos;Runoob&apos;: 10, &apos;Taobao&apos;: 10&#125;dict2 =&#123;&apos;na&apos;: &apos;zhang&apos;, &apos;name&apos;:&apos;yu&apos;&#125;dict1.update(dict2)dict1#以列表返回可遍历的(键, 值) 元组数组dict.items()#以列表返回一个字典所有的键dict.keys()#以列表返回字典中的所有值dict.values() 集合类型 集合是一个无序的，不重复的数据集合。集合作用有以下两点： 去重： 把一个还有重复元素的列表或元组等数据类型变成集合， 其中的重复元素只出现一次，用set()方法 1234567891011121314#使用大括号之间创建集合f = &#123;1, 2, 2, 2, &apos;a&apos;&#125;print(f)print(type(f))# 用set()方法a = [1, 2, 2, &apos;a&apos;, &apos;a&apos;]b = (1,2,2, &apos;a&apos;, &apos;a&apos;)c = set(a)d = set(b)e = set()print(c)print(d)print(e) 进行关系测试：测试两组数据之间的交集，差集，并集等数据关系 12345678910111213141516171819202122232425262728293031323334# 查看集合的相关函数help(set)a = [1,2,2,&apos;a&apos;,&apos;a&apos;,&apos;d&apos;,&apos;e&apos;]b = [1,2,2,&apos;a&apos;,&apos;a&apos;,&apos;b&apos;,&apos;b&apos;]c = set(a)d = set(b)# 取交集e = c.intersection(d)print(e)# 取并集f = c.union(d)print(f)# 取差集（无重复）g = c.difference(d)print(g)#对称差集&quot;（不同时在c,d中存在）h = c.symmetric_difference(d)print(h)#判读是否为子集i = c.issubset(d)print(i)# &quot;判读是否为超集&quot;j = c.issuperset(d) #检查是否有相同元素,没有返回Truek = c.isdisjoint(d) 条件和循环if语句 if-else语句 12345age = 17if age &gt;= 18: print( &quot;you can seee six video&quot;)else: print(&quot; you should study&quot;) if-elif-else 语句 1234567age = 18if age == 18: print( &quot;you should find girlfriend&quot;)elif age&gt; 18: print(&quot;you can see six video&quot;) else: print(&quot; you should study&quot;) 多个elif 1234567891011age = 80if age == 18: print( &quot;you should find girlfriend&quot;)elif 18&lt;age&lt;30: print(&quot;you can see six video&quot;) elif 30&lt; age &lt; 60: print( &quot;you should go to work&quot;)elif age&gt; 60: print(&quot;you should go to tourism&quot;)else: print(&quot; you should study&quot;) if语句中的and和or 1234567num = 9if num &gt;= 0 and num &lt;= 10: print (&apos;hello&apos;)num = 10if num &lt;= 0 or num &gt;= 10: print(&apos;zy&apos;) while语句 for循环主要用于遍历迭代的对象， while循环主要用于条件判断 1234567891011numbers = [12, 21, 48, 8, 1230, 5, 7]even =[]odd = []while len(numbers) &gt; 0 : number = numbers.pop() if(number % 2 == 0): even.append(number) else: odd.append(number) print(even) continue 用于跳过该次循环 123456789101112numbers = [12, 21, 48, 8, 1230, 5, 7]even =[]odd = []while len(numbers) &gt; 0 : number = numbers.pop() if(number % 2 == 0): even.append(number) else: odd.append(number) continue print(even) break 用于退出循环 12345678910111213numbers = [12, 21, 48, 8, 1230, 5, 7]even =[]odd = []while len(numbers) &gt; 0 : number = numbers.pop() if(number % 2 == 0): even.append(number) else: odd.append(number) continue print(even) break 循环使用 else 语句 123456count = 0while count &lt; 5: print (count, &quot; is less than 5&quot;) count = count + 1else: print (count,&quot; is not less than 5&quot; ) for语句for 循环可以遍历任何序列的项目 12for letter in &apos;python&apos;: print(letter) 函数 函数是组织好， 可重复使用的，用来实现有关功能的代码段。函数能提高应用的模块行，和代码的重复利用率。 定义函数123456def zhangyu(): &quot;&quot;&quot;显示名称&quot;&quot;&quot; print(&quot;zhangandyu&quot;) # return[&apos;a&apos;] zhangyu() 向函数传入参数 1234567def zy(name): print(&apos;Hello, &apos; + name.title() + &apos;!&apos;)zy(&apos;zhangyu&apos;)# name 为形参#&apos;zhangyu&apos;为实参 位置实参 1234567def describe_pet(animal_type, name): print(&apos;I have a &apos; + animal_type) print(&apos;My &apos; + animal_type + &apos;is name is &apos; + name.title() + &apos;.&apos;)describe_pet(&apos;dog&apos;, &apos;huabao&apos;)# 警惕位置混淆describe_pet(&apos;huabao&apos;, &apos;dog&apos;) 关键字实参 123456def describe_pet(animal_type, name): print(&apos;I have a &apos; + animal_type) print(&apos;My &apos; + animal_type + &apos;is name is &apos; + name.title() + &apos;.&apos;)describe_pet(name = &apos;huabao&apos;, animal_type = &apos;dog&apos;)# 位置混淆也没有关系 设置默认值 12345678910def describe_pet(name,animal_type=&apos;dog&apos;): &quot;&quot;&quot;设置animal_type的默认参数是dog&quot;&quot;&quot; print(&apos;I have a &apos; + animal_type) print(&apos;My &apos; + animal_type + &apos;is name is &apos; + name.title() + &apos;.&apos;)# 默认参数不改变describe_pet(name = &apos;huabao&apos;)# 默认参数改变describe_pet(&apos;huxbao&apos;, &apos;cat&apos;) 返回值函数返回的值可以使用return语句将值返回到调用函数的代码行中。从而将程序的大部分繁重工作移到函数中取完成。 12345def zy_name(first_name, last_name): name = first_name + last_name return name.title()zy_name(&apos;zhang&apos;, &apos;yu&apos;) 让实参变成可选的 12345678910def zy_name(first_name, last_name, middle_name =&apos; &apos;): if middle_name: name = first_name +&apos; &apos;+ last_name +&apos; &apos; + middle_name else: name = first_name + &apos; &apos; + last_name return name.title()zy_name(&apos;zhang&apos;, &apos;yu&apos;)zy_name(&apos;zhang&apos;, &apos;and&apos;, &apos;yu&apos;) 返回字典 1234567def build_person(first_name, last_name, age=&apos;&apos;): person = &#123;&apos;first&apos; : first_name, &apos;last&apos;: last_name&#125; if age: person[&apos;age&apos;] = age return personbuild_person(&apos;zhang&apos;, &apos;yu&apos;, age=25) 传递列表 12345def get_user(names): for name in names: print(name.title())zy = [&apos;a&apos;, &apos;b&apos;, &apos;v&apos;]get_user(zy) 传递任意数据的实参 12345def get_world(* names): for i in names: print(i)get_world(&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;) 使用位置实参和任意数量实参 必须将接纳任意数量实参的形参放到最后 1234def get_world(size, *names): for i in names: print(str(size) + i)get_world( 1,&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;) 使用任意数量的关键字实参 1234567def get_user(**user_info): profile = &#123;&#125; for key, value in user_info.items(): profile[key] = value return profileuser_profile = get_user(location = &apos;princeton&apos;, field = &apos;physics&apos;, home = &apos;xian&apos;)print(user_profile) 递归函数如果一个函数在函数内部，调用自己本身，这个函数就是递归函数。 12345def fan(n): if n == 1: return 1 else: return n * fan (n-1) 但递归函数在数特别大的情况下会导致栈溢出， 例如： 1fan(10000) 变量的作用域 局部作用域 1234def func(): name = &quot;zhangyu&quot;print(name) 运行报错， 因为name变量只在func()函数中生效，而在全局无法调用。 作用域链 12345678name = &quot;lzl&quot;def f1(): name = &quot;Eric&quot; def f2(): name = &quot;Snor&quot; print(name) f2()f1() f1()函数执行，最后输出snor，Python中有作用域链， 变量会由内到外找，先去自己作用域找，自己没有再去上级找，直到找不到报错。 终极作用域 1234567891011name = &apos;zhang&apos;def f1(): print(name)def f2(): name = &apos;yu&apos; return f1 ret = f2()ret() 输出结果为zhang, 分析可知， f2()函数执行结果为函数f1的内存地址。执行ret()就是执行f1()，name =’zhang’与fi()在一个作用域链。 12345678910# 新浪面试题li = [lambda : x for x in range(10)]print(type(li))print(type(li[0]))#lambada 面试题 li = [lambda :x for x in range(10)]res = li[0]()print(res) Numpy库 Numpy是科学计算库,特点是有N维数组对象ndarray，是Scipy、Pandas等的基础 array结构 1234567891011121314151617181920212223import numpy as np# 给列表每个元素增加1zy = [1, 2, 3, 4, 5]zy = zy + 1# 错误， 因为列表不支持这样的错误# 用array函数zy = np.array(zy)zy += 1zy# 计算by = np.array([ 2, 3, 4, 5, 6])zy + byzy * byzy ** by# 取值zy[0] zy[2:] 底层为创建ndarray对象，有丰富的可选参数 12345zy.shape # 多维数组的形状type(zy) # 类型zy.dtype # 数组中元素的类型, array内部必须为同一类型， 不同类型会默认进行转换zy.size # 数组中元素个数zy.ndim # 数组的维度 索引 12345678tang_array = np.array([[1, 2, 3], [3, 4, 5], [6, 7, 8]])tang_array[1]tang_array[1, 1]tang_array[:,1]tang_array[1,0:2] 1234567891011tang_array2 = tang_arraytang_array2# 将tang_array2中的4 改为10tang_array2[1,1] = 10tang_array2tang_array# tang_array 中的4也改为了10， 修改tang_array2,实际是指向了tang_array中的内存# 要想修改tang_array2 而不改tang_arra, 需要用copy() 巧用布尔类型 1234567891011121314# 构造等差数组zy = np.arange(0, 100, 10)zy# array([ 0, 10, 20, 30, 40, 50, 60, 70, 80, 90])# 构造布尔类型by = np.array([0, 0, 1, 0, 1, 1, 1, 0, 1, 0], dtype=bool)by# array([False, False, True, False, True, True, True, False, True,False])zy[by]# array([20, 40, 50, 60, 80]) array数组的数值计算 123456789101112131415161718192021222324252627282930313233343536373839404142zy = np.array([[1, 2, 3, 4], [5, 6, 7, 8]])#所有数据求和 np.sum(zy)# 指定要按什么维度进行计算np.sum(zy,axis = 0)np.sum(zy,axis = 1)# 所有数据乘积zy.prod()zy.prod(axis = 0)zy.prod(axis = -1)# 最小最大值zy.min(axis = 0)zy.max()# 最大值的索引zy.argmax()# 均值zy.mean()zy.mean(axis = 0)# 标准差zy.std(axis = 1)# 方差zy.var()# 进行限制， 小于3的值都变成3， 大于7的值都变成7zy.clip(3, 7)# 进行四舍五入zy.round()# 进行四舍五入到第一个小数点zy.round(decimals = 1) 排序 12345678import numpy as nptang_array = np.array([[1.1, 4.3, 5.2 , 5.1], [5.2, 6.4, 2.3, 4.6]])# 排序np.sort(tang_array)np.sort(tang_array, axis = 0) 数组形状操作 123456789101112zy_num = np.arange(10)zy_num# array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])zy_num.shape = 2, 5zy_num# array([[0, 1, 2, 3, 4],[5, 6, 7, 8, 9]])zy_num.reshape(1,10)#array([[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]]) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465# 增加维度zy_num = np.arange(10)zy_num.shape#(10,)zy_num = zy_num[np.newaxis, :]zy_num.shape#(1, 10)zy_num = zy_num[ :, np.newaxis]zy_num.shape#(10, 1)# 压缩维度zy_num = zy_num.squeeze()zy_num#array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])zy_num.shape#(10,)# 转置zy_num.shape = 2,5zy_num#array([[0, 1, 2, 3, 4], [5, 6, 7, 8, 9]])zy_num.transpose() # zy_num.T#array([[0, 5],[1, 6], [2, 7], [3, 8], [4, 9]])# 数组的连接a = np.array([[1,2, 3, 4], [5, 6, 7, 8]])b = np.array([[0, 3, 5, 7], [8, 0, 10, 21]])c = np.concatenate((a, b))c# array([[ 1, 2, 3, 4], [ 5, 6, 7, 8],[ 0, 3, 5, 7], [ 8, 0, 10, 21]])c = np.confatenate((a, b), axis = 1)cnp.vstack((a,b))# array([[ 1, 2, 3, 4],[ 5, 6, 7, 8],[ 0, 3, 5, 7],[ 8, 0, 10, 21]])np.hstack((a,b))# array([[ 1, 2, 3, 4, 0, 3, 5, 7],[ 5, 6, 7, 8, 8, 0, 10, 21]])a# array([[1, 2, 3, 4],[5, 6, 7, 8]])a.flatten()a.ravel()# array([1, 2, 3, 4, 5, 6, 7, 8]) 生成数组 123456789101112131415161718192021222324252627282930np.arange(10)np.arange(2,20,2)# array([ 2, 4, 6, 8, 10, 12, 14, 16, 18])np.arange(2,20,2, dtype= np.float32)# array([ 2., 4., 6., 8., 10., 12., 14., 16., 18.], dtype=float32)# 构造等距数组np.linspace(0, 10, 5)# array([ 0. , 2.5, 5. , 7.5, 10. ])# 构造行向量，列向量np.r_[0:10:1]np.c_[0:10:1]np.zeros(3)# array([0., 0., 0.])np.zeros((3,3))np.ones(3)# array([1., 1., 1.])np.ones((3,3)) * 8zy_num = np.array([1,2,3, 4])np.zeros_like(zy_num)# array([0, 0, 0, 0]) 运算 12345678910111213141516171819202122232425# 乘法x = np.array([5,5])y = np.array([2,3])np.multiply(x,y)# array([10, 15])np.dot(x,y)# array([10, 15])x = np.array([1, 1, 1])y = np.array([[1, 2, 3],[4, 5, 6]])print(x * y)#[[1 2 3] [4 5 6]]x = np.array([1, 1, 2])y = np.array([1, 1, 1])x == y# array([ True, True, False])np.logical_and(x,y)np.logical_or(x,y)np.logical_not(x,y) 随机模块 123456789101112131415161718192021222324252627282930# 随机浮点数np.random.rand(3,2)# 随机整数np.random.randint(10, size = (2,4))# array([[4, 6, 7, 8], [7, 6, 2, 3]])# 随机数np.random.rand()np.random.random_sample()# 0-10中随机找三个数np.random.randint(0, 10, 3)# array([8, 6, 9])# 随机高斯分布mu, sigma = 0, 0.2np.random.normal(mu, sigma, 5)# 设置数字精度, 输出数精度为小数点后3位np.set_printoptions(precision = 3 )# 洗牌， 打乱排列顺序zy_num = np.arange(15)zy_num# array([ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14])np.random.shuffle(zy_num)zy_num# array([ 1, 5, 4, 11, 14, 9, 8, 6, 7, 3, 0, 2, 10, 12, 13]) 读取写入文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263# 写一个名为tang的txt文件%%writefile tang.txt1 2 3 4 5 6 2 3 4 5 5 7# 读取tang文件data = np.loadtxt(&apos;tang.txt&apos;)data# array([[1., 2., 3., 4., 5., 6.],[2., 3., 4., 5., 5., 7.]])%%writefile tang.txt1, 2, 3, 4, 5, 6 2, 3, 4, 5, 5, 7data = np.loadtxt(&apos;tang.txt&apos;, delimiter = &apos;,&apos;)%%writefile tang.txta, b, c, d, e, f1, 2, 3, 4, 5, 6 2, 3, 4, 5, 5, 7# 不读取第一行data = np.loadtxt(&apos;tang.txt&apos;, delimiter = &apos;,&apos;, skiprows =1)# 指定使用哪几列data = np.loadtxt(&apos;tang.txt&apos;, delimiter = &apos;,&apos;, skiprows =1, usecols = (0,1, 4))# 写入数组文件zy_num = np.array([[1, 2, 3], [4, 5, 6]])np.savetxt(&apos;tang.txt&apos;, zy_num)# 保存成指定格式np.savetxt(&apos;tang.txt&apos;, zy_num, fmt= &apos;%d&apos;)np.savetxt(&apos;tang.txt&apos;, zy_num, fmt= &apos;%.2f&apos;)# 指定分隔符np.savetxt(&apos;tang.txt&apos;, zy_num, fmt= &apos;%d&apos;, delimiter = &apos;,&apos;)# 读写文件zy_num = np.array([[1, 2, 3], [4, 5, 6]])np.save(&apos;zy_num.npy&apos;, zy_num)zy_num = np.load(&apos;zy_num.npy&apos;)# 将两个文件保存在同一文件夹，并进行读写zy_num2 = np.arange(10)np.savez(&apos;zy_npz&apos;, a = zy_num, b = zy_num2)data = np.load(&apos;zy.npz&apos;)data.keys()# [&apos;a&apos;, &apos;b&apos;]data[&apos;a&apos;]# array([[1, 2, 3],[4, 5, 6]])]]></content>
      <categories>
        <category>数据分析技能</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python爬虫学习]]></title>
    <url>%2F2018%2F07%2F12%2F%E6%8A%80%E8%83%BD-python%E7%88%AC%E8%99%AB%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[爬取英雄联盟-英雄皮肤图片 前言 最近自己在学爬虫， 有天朋友问我能否爬取英雄联盟的皮肤图片到本地，好实现快速浏览，折腾了半个小时，终于成功了。 过程 分析过程 找到皮肤图片链接， 研究规律。 在抓取图片之前，我们需要分析网址链接的构成， 以便找到其中的规律。 打开英雄联盟网站, 点击其中的一个英雄， 我们可以看到一个英雄有1-6个皮肤甚至更多，且我们很容易从每个皮肤链接中找到规律。 123456789# 英雄1http://ossweb-img.qq.com/images/lol/web201310/skin/small266000.jpghttp://ossweb-img.qq.com/images/lol/web201310/skin/small266001.jpghttp://ossweb-img.qq.com/images/lol/web201310/skin/small266002.jpg# 英雄2http://ossweb-img.qq.com/images/lol/web201310/skin/small103000.jpghttp://ossweb-img.qq.com/images/lol/web201310/skin/small103001.jpghttp://ossweb-img.qq.com/images/lol/web201310/skin/small103002.jp 从以上的链接中，我们可以知道英雄皮肤的链接规律为： 1&quot;http://ossweb-img.qq.com/images/lol/web201310/skin/small&quot; + &quot;英雄代号&quot; + &quot;0&quot; + &quot;01-10&quot; 找到每个英雄对应的数字代号 那么我们需要解决的问题就变成了到每个英雄对应的代号是多少？ 通过搜索，我们发现每个英雄对应的代号存在champion.js文件中 从Headers中， 我们可以看到champion.js 对应的url为： 12345678&gt;&gt;我们通过正则表达式， 把js中对应的英雄代号提取出来。&gt;&gt; 通过以上把链接拼凑起来，我们就可以把链接对应的图片皮肤下载到本地了。3. 代码&gt; import requestsimport reimport jsonimport urlliburl = “http://lol.qq.com/biz/hero/champion.js&quot;hd ={‘User-Agent’:”Mozilla/5.0 (Windows NT 6.1) AppleWebKit/535.1 (KHTML, like Gecko) Chrome/14.0.802.30 Safari/535.1 SE 2.X MetaSr 1.0”}data = requests.get(url,headers = hd).contentdatas = data.decode()pat = ‘“keys”:(.*?),”data”‘imglist = re.findall(pat,datas)datass = json.loads(imglist[0])for i in datass: try: for j in range(12): try: num = str(j) # print(num) if len(num) == 1: hero_num = &quot;00&quot; + num elif len(num) ==2: hero_num = &quot;0&quot; + num numstr = i + hero_num urls = &apos;http://ossweb-img.qq.com/images/lol/web201310/skin/big&apos;+ numstr +&apos;.jpg&apos; localfile = &quot;E:/张宇个人文件/英雄联盟/&quot; + str(i) + str(num) + &quot;.jpg&quot; urllib.request.urlretrieve(urls, filename = localfile) except Exception as err: pass except Exception as err: pass 12345678---# 爬取王者荣耀-英雄图片1. 代码&gt; 用python爬取王者荣耀皮肤import requestsimport reimport urllib url = “http://pvp.qq.com/web201605/herolist.shtml&quot;hd ={‘User-Agent’:”Mozilla/5.0 (Windows NT 6.1) AppleWebKit/535.1 (KHTML, like Gecko) Chrome/14.0.802.30 Safari/535.1 SE 2.X MetaSr 1.0”}data = requests.get(url,headers = hd)pat = ‘a href=”herodetail/(.*?).shtml’imglist = re.compile(pat, re.S).findall(data.text) for i in imglist: # print(i) try: for j in [1,2,3,4,5,6]: try: numstr = str(i)+&apos;/&apos; +str(i)+&apos;-mobileskin-&apos;+ str(j) # print(numstr) urls = &apos;https://game.gtimg.cn/images/yxzj/img201606/heroimg/&apos;+numstr+&apos;.jpg&apos; print(urls) localfile = &quot;E:/张宇个人文件/官网图片/&quot; + str(i)+ str(j)+ &quot;.jpg&quot; urllib.request.urlretrieve(urls, filename = localfile) except Exception as err: pass except Exception as err: pass 1234567------# 爬取网站图片1. 代码* 构建用户代理池&gt; 这里可以随意加多个浏览器uapools = [ “Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; WOW64; Trident/5.0)”, “Mozilla/5.0 (compatible; MSIE 10.0; Windows NT 6.2; WOW64; Trident/6.0)”, “Mozilla/5.0 (Windows NT 6.3; Trident/7.0; rv:11.0) like Gecko”, “Mozilla/5.0 (compatible; MSIE 10.0; Windows Phone 8.0; Trident/6.0; IEMobile/10.0; ARM; Touch; NOKIA; Lumia 920)”, “Mozilla/5.0 (Windows NT 6.1; WOW64; rv:6.0.2) Gecko/20100101 Firefox/6.0.2”, “Opera/9.80 (Windows NT 6.1; WOW64) Presto/2.12.388 Version/12.12”, “Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/28.0 Safari/537.36 OPR/15.0”, “Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.17 (KHTML, like Gecko) Chrome/24.0.1312.57 Safari/537.17”, “Mozilla/5.0 (X11; CrOS armv7l 3428.193.0) AppleWebKit/537.22 (KHTML, like Gecko) Chrome/25.0.1364.126 Safari/537.22”, “Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/534.57.2 (KHTML, like Gecko) Version/5.1.7 Safari/534.57.2”, “Mozilla/5.0 (Windows; U; Windows NT 5.1; zh-CN) AppleWebKit/533.9 (KHTML, like Gecko) Maxthon/3.0 Safari/533.9”,] 1232. 爬取并下载图片&gt; import reimport requestsimport urllib.request uapools 如上所示for ua in uapools: hd ={‘User-Agent’:ua} i = uapools.index(ua) # 限制爬取页数， 我们爬取前10页 if i &gt; 10: break try: url = &quot;http://www.iyuanqi.com/home/funimg/fun_list/m/Home/cp_uid/all/sort/30hot/p/&quot;+str(i)+&quot;.html&quot; data = requests.get(url, headers = hd) pat = &apos;class=&quot;lazy-img&quot; src=&quot;(.*?)&quot; data-original=&quot;&apos; imglist = re.compile(pat, re.S).findall(data.text) for j in range(0, len(imglist)): try: thisimg = imglist[j] thisimgurl = thisimg localfile = &quot;E:/张宇个人文件/网络图片/&quot; + str(i) + str(j) + &quot;.jpg&quot; urllib.request.urlretrieve(thisimgurl, filename = localfile) except Exception as err: pass except Exception as err: pass 12345678910111213141516-----------------# 爬取天善课程数据表存储到MYSQL1. 前言&gt; 天善智能是一个商业智能与大数据在线社区，有很多很好的学习课程。我们用爬虫来爬取网站的所有课程并存储到MYSQL数据库中， 以便于进一步的分析。2. 用python在MYSQL中创建名为zhanhyu的数据库 * 用python连接MYSQL数据库&gt; import pymysql 因为本地mysql没有设置密码， 所以没有加password参数db = pymysql.connect(host = ‘localhost’, user = ‘root’, port = 3306) 用cursor()方法获取MYSQL的操作游标， 利用游标来执行SQL语句cursor = db.cursor() 123 * 创建一个新的数据库， 名字叫做zhangyu&gt; cursor.execute 执行真正的sql语句, DEFAULT 指定默认值cursor.execute(“CREATE DATABASE zhangyu DEFAULT CHARACTER SET utf8”)123453. 在zhangyu库中创建tianshan2_datas的数据表 * 指定在zhangyu这个数据库中运行&gt; db = pymysql.connect(host = ‘localhost’, user = ‘root’, port = 3306, db=’zhangyu’)cursor = db.cursor()123* 用sql语句创建名为tianshan2_datas的表&gt; sql = ‘CREATE TABLE IF NOT EXISTS tianshan2_datas (name VARCHAR(255) NOT NULL, pirce VARCHAR(255) NOT NULL,numbers VARCHAR(255), PRIMARY KEY (name))’ curosr.exectute(sql) db.close() 12344. 爬取天善智能网站的数据&gt; import reimport requests for i in range(1,5): # 观察天善课程链接， 找出规律 thisurl = &quot;https://edu.hellobi.com/course/&quot; + str(i+1) # 用requests库抓取数据 hd ={&quot;user-agent&quot;: &quot;Mozilla/5.0 AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.87 Mobile Safari/537.36&quot;} data = requests.get(thisurl, headers = hd) #用正则表达式进行解析 title_pat = &apos;&lt;li class=&quot;active&quot;&gt;(.*?)&lt;/li&gt;&apos; price_pat = &apos;class=&quot;price-expense&quot;&gt;&lt;sub&gt;￥&lt;/sub&gt;(.*?)&lt;/span&gt;&apos; numb_pat = &apos;class=&quot;course-view&quot;&gt;(.*?)&lt;/span&gt;&apos; title = re.compile(title_pat, re.S).findall(data.text) if(len(title)&gt;0): title = title[0] else: continue price = re.compile(price_pat, re.S).findall(data.text) if(len(price)&gt;0): price = price[0] else: price = &apos;免费&apos; numb = re.compile(numb_pat, re.S).findall(data.text) if(len(numb)&gt;0): numb = numb[0] else: numb = &apos;缺失&apos; 1235. 将爬取的数据存储到名为zhangyu数据库的tianshan2_datas表中&gt; con = pymysql.connect(host = &apos;localhost&apos;, user = &apos;root&apos;, port = 3306, db = &apos;zhangyu&apos;) cursor = con.cursor() sql = &apos;insert into tianshan2_datas(name, pirce, numbers) values(%s,%s,%s)&apos; try: cursor.execute(sql, (title, price, numb)) con.commit() except: con.rollback() con.close() 12345----&gt; 这样，我们就成功的把爬取的数据保存到mysql数据库中，方便我们查询使用。6. 完整代码&gt; import pymysql 因为本地mysql没有设置密码， 所以没有加password参数db = pymysql.connect(host = ‘localhost’, user = ‘root’, port = 3306) 用cursor()方法获取MYSQL的操作游标， 利用游标来执行SQL语句cursor = db.cursor() cursor.execute 执行真正的sql语句, DEFAULT 指定默认值cursor.execute(“CREATE DATABASE zhangyu DEFAULT CHARACTER SET utf8”) db = pymysql.connect(host = ‘localhost’, user = ‘root’, port = 3306, db=’zhangyu’)cursor = db.cursor()sql = ‘CREATE TABLE IF NOT EXISTS tianshan2_datas (name VARCHAR(255) NOT NULL, pirce VARCHAR(255) NOT NULL,numbers VARCHAR(255), PRIMARY KEY (name))’cursor.execute(sql)db.close() import reimport pymysqlimport requests for i in range(0,284): thisurl = “https://edu.hellobi.com/course/&quot; + str(i+1) hd ={“user-agent”: “Mozilla/5.0 AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.87 Mobile Safari/537.36”} data = requests.get(thisurl, headers = hd) title_pat = ‘(.?)‘ price_pat = ‘class=”price-expense”&gt;￥(.?)‘ numb_pat = ‘class=”course-view”&gt;(.*?)‘ title = re.compile(title_pat, re.S).findall(data.text) if(len(title)&gt;0): title = title[0] else: continue price = re.compile(price_pat, re.S).findall(data.text) if(len(price)&gt;0): price = price[0] else: price = ‘免费’ numb = re.compile(numb_pat, re.S).findall(data.text) if(len(numb)&gt;0): numb = numb[0] else: numb = ‘缺失’ con = pymysql.connect(host = &apos;localhost&apos;, user = &apos;root&apos;, port = 3306, db = &apos;zhangyu&apos;) cursor = con.cursor() sql = &apos;insert into tianshan2_datas(name, pirce, numbers) values(%s,%s,%s)&apos; try: cursor.execute(sql, (title, price, numb)) con.commit() except: con.rollback() con.close() `]]></content>
      <categories>
        <category>数据分析技能</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
</search>
