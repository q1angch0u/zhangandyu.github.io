<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Hive 进阶查询]]></title>
    <url>%2F2019%2F05%2F07%2F%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E6%8A%80%E8%83%BD-Hive%E8%BF%9B%E9%98%B6%E6%9F%A5%E8%AF%A2%2F</url>
    <content type="text"><![CDATA[Hive查询性能优化什么是数据倾斜当我们在Hive上进行查询时，因为数据的分散度不够， 导致大量数据集中在一台或者几台服务器上， 导致数据的计算速度远远低于平均计算速度， 计算过程特别耗时。 数据倾斜的表现任务进度长时间维持在99%，查看任务监控页面，发现只有少量子任务未完成。 ##如何避免数据倾斜 sql优化 业务逻辑优化 方法1： 在查询中， 避免使用 select *, 使用条件限制取需要的列 方法2： 当数据量特别大时，用 group by 代替 count(distinct) count(distinct ),在数据量特别大的情况下，效率较低, 可以用先 group by 再 count 的方式进行代替。因为count(distinct)是按group by 字段分组，按distinct字段排序 123456789select hit_date, count(distinct user_account) as uvfromwhere hit_date between '2018-10-01' and '2018-10-02'group by hit_date 可以转换成： 123456789101112131415select hit_date, count(user_account) as uvfrom(select hit_date, user_accountfrom computer_view.datawhere hit_date between '2018-10-01' and '2018-10-02'group by hit_date, user_account) agroup by hit_date 方法3： join 优化 在使用 Join 进行外关联时， 将副表的过滤条件写在 where 后面，会先全表关联， 再进行过滤， 这样会耗费资源。 123456SELECT a.price_close, b.price_closeFROM b JOIN a ON b.ymd = a.ymd AND b.symbol = a.symbolWHERE s.symbol = 'APPLE' 正确的写法是将 where 条件写在 on 后面 1234SELECT a.price_close, b.price_closeFROM b JOIN a ON ( b.ymd = a.ymd AND b.symbol = a.symbol and s.symbol = 'APPLE') 方法4： 避免 union all 子查询中使用 group by 【替换 count(distinct) 除外】、count(distinct)、max、min等。 123456789101112131415161718192021222324252627with a1 as ( select user_account, hit_date from data where hit_date between '2018-12-01' and '2018-12-13' and nbtn_name like "%支付宝%" union all select user_account, hit_date from data where hit_date between '2018-12-01' and '2018-12-13' and nbtn_name like "%支付宝%")select hit_date, count(user_account) as pvfrom a1group by hit_date 方法5： 避免不同数据类型进行关联 使用CAST函数对数据类型进行转换，语法为cast(value AS TYPE)123456789select a.price_close, b.price_closefrom a join b on a.user_id = cast(b.user_id as string)where hit_date between &apos;2018-11-01&apos; and &apos;2018-11-02&apos; and a.symbol = &apos;apple&apos; 方法6： 无效ID在关联时的数据倾斜问题 把空值的 key 变成一个字符串加上随机数，就能把倾斜的数据分到不同的 reduce 上 ,解决数据倾斜问题。需要用到Case When … Else…End语法 写法1：123456789101112131415Select *From a Join bOn a.user_id is not nullAnd a.user_id = b.user_idUnion allSelect * from awhere a.user_id is null 写法2：1234567891011Select *From a left out Join bOn Case when a.user_id is null then concat(‘dp_hive’,rand() ) else a.user_id = b.user_id end; Hive的查询注意事项以及优化总结： 尽量尽早过滤数据，减少每个阶段的数据量。对于分区表要加分区，同时只选择需要使用到的字段 对历史库的计算经验 尽量原子化操作，尽量避免一个SQL包含复杂逻辑可以使用中间表来完成复杂的逻辑 join操作 小表要注意放在join的左边，否则会引起磁盘和内存的大量消耗 如果union all的部分个数大于2，或者每个union部分数据量大，应该拆成多个insert into语句，实际测试过程中，执行时间能提升50% 让服务器尽量少做事情，走最优的路径，以资源消耗最少为目标 参考资料： https://blog.csdn.net/yu0_zhang0/article/details/81776459 https://blog.csdn.net/young_0609/article/details/84593316 https://blog.csdn.net/qq_29232943/article/details/79644614 http://lxw1234.com/archives/2015/06/317.htm https://zenoh.iteye.com/blog/1748592 http://www.lwyyyyyy.cn/getArticleDetailInfo?articleId=89 求两组数据的交集， 并集， 差集并集union 与 union all union, 结果包含所有行， 并删除重复行unoin all, 结果包含所有行， 但不删除重复行 写法1：1234567891011121314151617181920212223use computer_view;with a1 as ( select user_account from data where hit_date between '2018-12-01' and '2018-12-02' and nbtn_name like "%支付宝%" union select user_account from data where hit_date between '2018-12-01' and '2018-12-02' and nbtn_name like "%手淘%")select count(user_account) as pvfrom a1 点击支付宝或者手淘活动的人数总共有 435499 人 写法2：1234567891011121314151617181920212223use computer_view;with a1 as ( select user_account from data where hit_date between '2018-12-01' and '2018-12-02' and nbtn_name like "%支付宝%" union all select user_account from data where hit_date between '2018-12-01' and '2018-12-02' and nbtn_name like "%手淘%")select count(user_account) as pvfrom a1 点击支付宝或者手淘活动的次数为 665935 交集写法1：1234567891011121314151617181920212223use computer_view;with a1 as ( select user_account from data where hit_date between '2018-12-01' and '2018-12-02' and nbtn_name like "%支付宝%" intersect select user_account from data where hit_date between '2018-12-01' and '2018-12-02' and nbtn_name like "%手淘%")select count(user_account) as pvfrom a1 点击支付宝又点击手淘活动的人数为 66174 差集 (except 函数 与 join写法) 写法1：1234567891011121314151617181920212223use computer_view;with a1 as ( select user_account from data where hit_date between '2018-12-01' and '2018-12-25' and nbtn_name like "%支付宝%" except select user_account from data where hit_date between '2018-12-01' and '2018-12-25' and nbtn_name like "%手淘%")select count(user_account) as pvfrom a1 写法2：12345678910111213141516171819202122232425use computer_view;with a1 as ( select user_account from data where hit_date between '2018-12-01' and '2018-12-25' and nbtn_name like "%支付宝%"),a2 as ( select user_account from data where hit_date between '2018-12-20' and '2018-12-25' and nbtn_name like "%支付宝%")select count(distinct a1.user_account) as pvfrom a1 left outer join a2 on a1.user_account = a2.user_account and a2.user_account is null 只参加支付宝活动， 没有参加手淘活动的人数为 369325在求差集时， 需要注意前后顺序， 否则会出现逻辑错误可以发现， 差集 + 交集 =并集， 369325 + 66174 = 435499 写法3： 1234567891011121314151617181920212223242526272829303132333435--详细列出差集的版本号with a1 as(select distinct two as user_accountfrom test.data_csvexcept (select distinct user_accountfrom computer_view.datawhere hit_date between '2018-09-01' and '2018-09-03' union all select distinct user_accountfrom computer_view.datawhere hit_date between '2018-09-01' and '2018-09-03'))select a2.six , COUNT(a2.two) as uv, count(a1.user_account) as uv_1froma1, test.data_csv as a2WHERE a1.user_account = a2.twogroup by a2.sixlimit 100 业务问题计算留存率 求11月10-15号每天的1、3、7日留存率 方法1： 一次性求次1日，次3日， 次7日留存 12345678910111213141516171819202122232425262728with a1 as (select hit_date, user_accountfrom computer_view.datawhere hit_date between '2019-04-25' and '2019-05-13' and btn_information is not null),a2 as (select hit_date, user_accountfrom computer_view.datawhere hit_date between '2019-04-25' and '2019-05-13' and btn_information is not null)select a1.hit_date,count(distinct a1.user_account) uv,count(distinct case when datediff(a2.hit_date, a1.hit_date) = 1 then a1.user_account else null end ) next_day,count(distinct case when datediff(a2.hit_date, a1.hit_date) = 3 then a1.user_account else null end ) three_day,count(distinct case when datediff(a2.hit_date, a1.hit_date) = 7 then a1.user_account else null end ) seven_dayfrom a1 join a2 on a1.user_account = a2.user_accountgroup by a1.hit_dateorder by a1.hit_datelimit 100 方法2： 统计每天的uv 使用date_add 函数， 一次性求出10-15号每一天的次1、3、7日留存 算出留存率 步骤1： 123456789101112-- 统计10-15号每天uvSELECT hit_date, count(distinct user_account) as uvFROM computer_view.dataWHERE hit_date between '2018-11-10' and '2018-11-15'group BY hit_dateorder BY hit_date 步骤2：123456789101112131415161718192021222324252627282930-- 统计10-15号每天的次日留存数， 统计次3、7日留存只需将1换为3、7with a1 as ( select user_account, hit_date from computer_view.data where hit_date between '2018-11-10' and '2018-11-15'),a2 as ( select user_account, hit_date from computer_view.data where hit_date between '2018-11-10' and '2018-11-25')select a1.hit_date, count(distinct a1.user_account) as uvfrom a1 join a2 on a1.user_account = a2.user_accountWHERE a2.hit_date = date_add(a1.hit_date, 1) group by a1.hit_dateorder BY a1.hit_date 拓展方法：(迷神) 123456789101112131415161718192021-- 留存sql优化select count(1)from( select userid, count(1) from( select t1.userid, t1.statdate from table1 t1 where t1.statdate &gt;= $&#123;上30天日期&#125; and t1.statdate &lt;= $&#123;上一天日期&#125; group by t1.userid, t1.statdate ) s1 group by userid having count(1) &gt; 2 ) R1 此sql为一个样例，计算连续跟任意都适用，至于计算第N天，只需要更改下日期过滤条件，变成=$[上N天日期]，=${上一天日期}。另外，这种方式适合跑当前周期数据，如果跑历史数据，可以写个循环。当然，最暴力还是直接用userid 关联。 这种写法，更多是针对现在大部分分布式处理平台的特性，尽可能将数据合理均匀分片，每台服务器各自运算自己的，最后汇总。 尽可能少用 count distinct 这种写法，因为无法利用分片的特性。 计算上一步 求点击【确认充值】按钮的上一步点击的名称 1234567891011121314151617181920212223242526use default;with a as (select user_account, btn_name, lag(btn_name, 1) over (partition by user_account order by create_timestamp) as previous_btn_namefrom computer_view.datawhere hit_date between '2018-11-01' and'2018-11-01' and btn_name is not nullhaving btn_name like '确认支付')select previous_btn_name, count(distinct user_account) as cfrom agroup by previous_btn_nameorder by c desclimit 1000 上一步点击的名称我已经知道了， 现在要想 之前通过上一步点击这些条件之后， 再点击【确认支付】按钮的 去重uv 1234567891011121314151617181920212223242526272829use default;with a as (select user_account, btn_name, lag(btn_name, 1) over (partition by user_account order by create_timestamp) as previous_btn_namefrom computer_view.datawhere hit_date between '2018-11-01' and'2018-11-01' and btn_name is not nullhaving btn_name like '确认支付')select count(distinct user_account) as cfrom awhere (previous_btn_name like "%10元%" or previous_btn_name like "%30元%" or previous_btn_name like "%50元%" or previous_btn_name like "%10元%" or previous_btn_name like "%30元%" or previous_btn_name like "%50元%" or previous_btn_name like "%100元%" or previous_btn_name like "%200元%" or previous_btn_name like "%300元%" ) 125752 创建临时表12345678910111213141516use default;create table test.nine_android_user_version_10select user_account, app_versionfrom computer_view.datawhere hit_date between '2018-09-01' and '2018-09-30' and user_account is not null and app_version is not nullgroup by user_account, app_version 原始日志中取数12345678910111213141516use default;create table test.nine_user_version_10select url_par(url_query,'account') as user_account, split(url_par(url_query,'AppID'),' ')[1] as app_versionfrom apache_log.client_ios_sensorwhere dt between '2018-10-01' and '2018-10-20' and url_par(url_query,'account') is not null and url_par(url_query,'AppID') is not nullgroup by url_par(url_query,'account'), split(url_par(url_query,'AppID'),' ')[1] 取 pv &gt;1 的用户量12345678910111213141516171819202122232425262728293031with a1 as (SELECTuser_accountFROMcomputer_view.dataWHEREnbtn_name is not null andhit_date between '&#123;&#125;' and '&#123;&#125;'union all SELECTuser_accountFROMcomputer_view.dataWHEREnbtn_name is not null andhit_date between '&#123;&#125;' and '&#123;&#125;'),a2 as (SELECT user_account,count(user_account) as pvfrom a1group by user_accounthavingcount(user_account) &gt; 3)SELECT count(distinct user_account) as uvfrom a2 求连续4个月活跃的用户数 1月活跃的用户数， 在2月、3月、4月一直活跃的用户有多少？ 12345678910111213141516171819with a1 as(select user_account , month(hit_date) as monthfrom compu_view.ios_log_viewwhere hit_date between '2019-01-01' and '2019-04-30'group by user_account, month(hit_date) ),a2 as ( select user_account,a1.month, row_number() over(partition by user_account order by a1.month) as pxfrom a1) select count(distinct user_account) as uvfrom a2where a2.px = 4 常用函数https://wing324.github.io/2017/10/20/Hive%E5%AE%9E%E7%94%A8%E5%87%BD%E6%95%B0%E5%A4%A7%E5%85%A8/ 聚合函数 函数名 定义 count() 个数统计函数 count(distinct ) 统计去重之后的个数 sum() 求和 sum(distinct ) 去重之后的和 avg() 平均值 avg(distinct) 去重之后的平均值 min() 最小值 max() 最大值 corr(A, B) 相关系数 var_pop() 方差 var_samp() 样本方差 stddev_pop() 标准偏差 stddev_samp() 标准样本偏差 covar_pop(A, B) 协方差 covar_samp(A, B) 样本协方差 RAND() 随机数 时间函数 函数名 定义 NOW ( ) 当前时间 extract() 抽取具体的年、月、日 date() 返回时间的日期部分 year() 返回时间的年份 month() 返回时间的月份 day() 返回日期的天 hour() 返回时间的小时 minute() 返回时间的分钟 second() 返回时间的秒 week () 第几周 dayofweek() 返回星期几，1为星期天 dayofyear() 一年中的第几天 sec_to_time ( ) 秒数转成时间 dateadd() 时间相加 date_sub() 时间相减 datediff() 时间的差值 date_format() 输出指定时间格式 datename() 返回日期部分的参数 datepart() 返回日期、时间的单独部分 sql 中的时间处理函数 now() 返回当前时间 1select now() date() 输出为日期,没有具体时间 date_add() 时间相加date_add(dt,interval 1 day ) 在dt的基础上加上一天 123date_add(hit_date, interval 1 day)-- 给hit_date 添加一天 date_sub() 时间相减 datediff() 时间的差值 date_format() 输出指定格式对时间的格式进行改变date_format(dt, “%Y-%m-%d”) 1date_format(hit_date, "%Y-%m-%d) 窗口函数窗口函数 函数名 定义 rank() 排名相等的会留下空位 dense_rank() 排名相等的不会留下空位 row_number() 排名不管数据是否相等 lag() 访问相同结果集的先前行中的数据 lead() 访问相同结果集的后续行中的数据 first_value() 返回组中数据窗口的第一个值 last_value() 返回组中数据窗口的最后一个值 if() 条件判断函数 case…when…else…end 判断各个元素是否满足了某种条件的集合 over() 与聚合函数sum(), count(), avg()等结合使用， 实现分组聚合的功能 split() hive字符串分割函数 intersect 交集 except 差集 union all 并集 round 把数值字段舍入为指定的小数位数 difference 衡量两个值之间的差异 coalesce 1、将控制替换成其他值；2、返回第一个非空值 pivot 行转换列 over 函数 语法： over(partition by ….)作用： 与聚合函数sum(), count(), avg()等结合使用， 实现分组聚合的功能 123456789# 根据日期 和 mac_id 进行分组求每组的数量和， 并按日期排序select hit_date, mac_id, mac_color, day_num, sum(day_num) over(partition by hit_date, mac_id order by hit_date) as sum_numfrom test.datas hit_date mac_id mac_color day_num sum_num 20171011 1292 金色 11 89 20171011 1292 黑色 19 89 20171011 1292 粉金 58 89 20171011 1292 金色 1 89 20171011 2013 金色 9 22 20171011 2013 金色 3 22 20171012 1292 金色 5 18 20171012 1292 粉金 1 18 20171012 2013 粉金 1 7 20171012 2013 金色 6 7 20171013 1292 黑色 1 1 20171013 2013 粉金 2 2 123456789101112# group by 语句select hit_date, mac_id, sum(day_num) from test.datagroup by hit_date, mac_idorder by hit_date day_id mac_id sum_num 20171011 124609 1 20171011 20130 22 20171011 12922 89 20171012 12922 18 20171012 20130 7 20171013 12922 1 20171013 20130 2 over(partition by) 与 group by 的区别grou by 字段只能显示与分组聚合相关的字段， 而 over(partition by)可以显示所有字段 LAG 和 LEAD 函数 语法： LAG(col,n,DEFAULT) 用于统计窗口内往上第n行值;LEAD(col,n,DEFAULT) 用于统计窗口内往下第n行值 123456789101112131415161718192021# 计算11月1-10号， 不同日期同一用户登陆客户端 pv 量对比with a1 as (select user_account, count(user_account) as pv, hit_datefrom computer_view.datawhere hit_date between '2018-11-01' and'2018-11-10'group by user_account, hit_date)select user_account, a1.hit_date, a1.pv, lag(a1.pv, 1) over (partition by user_account order by user_account, a1.hit_date) as pv1, lead(a1.pv, 1) over(partition by user_account order by user_account, a1.hit_date) as pv2from a1limit 100 first_value() 和 last_value() 函数 语法:first_value() ：比较每个用户浏览次数与第一天浏览次数进行比较，查询返回当前浏览次数以及第一天浏览次数last_value() ： 比较每个用户浏览次数与最新一天浏览次数进行比较，查询返回当前浏览次数以及最新一天浏览次数 12345678910111213141516171819with a1 as (select distinct user_account, count(user_account) as pv, hit_datefrom computer_view.datawhere hit_date between '2018-11-01' and'2018-11-10'group by user_account, hit_date)select distinct user_account, a1.hit_date, a1.pv, first_value(a1.pv) over (partition by user_account order by user_account, a1.hit_date) as pv1, last_value(a1.pv) over(partition by user_account order by user_account, a1.hit_date) as pv2from a1limit 100 rank、dense_rank、 row_number 排序函数 row_number函数说明 12ROW_NUMBER ( ) OVER ( [ PARTITION BY value_expression , ... [ n ] ] order_by_clause ) 说明： rank函数， 返回数据项在分组中的排名， 排名相等的会留下空位， 如1、2、2、4dense_rank函数， 返回数据项在分组中的排名， 排名相等的不会留下空位， 如1、2、2、3row_number函数， 返回数据项在分组中的排名， 排名不管数据是否相等， 如1、2、3、4 1234567select a, row_number() over(order by b) row_number, rank() over(order by b) rank, dense_rank() over(order by b) dense_rank from lijie.test_rank a row_number rank dense_rank A 1 1 1 C 2 2 2 D 3 3 3 B 4 3 3 E 5 5 4 F 6 6 5 G 7 7 6 if 函数 12345678910select city, count(distinct user_account) as uv from an_log_viewwhere hit_date = &apos;2019-06-10&apos;group by cityhavingcount(if( nbtn_name like &quot;发现&quot;, 1, null)) &gt;= 20 123456789select city,count(1),count(if( nbtn_name like &quot;发现&quot;, 1, null)),count(if(nbtn_name like &quot;发现&quot;， 1， null)) / count(1)froma1group by city lateral view 函数 描述： &gt; lateral view 用于和 split、explode、collect_set 函数 等一起使用， 能够将一行数据拆成多行数据，在此基础上对拆分后的数据进行聚合。 举例： 表： table pageid adid_list front_page [1,2,3] contact_page [3,4] 将 表 table 中的 adid_list 转换为单独的行。 12345SELECT pageid, adidFROM tablelateral view explode(adid_list) adTable as adid 输出结果为：|pageid |adid_list||—|—||front_page|1||front_page|2||front_page|3||contact_page|3||contact_page|4| 要求： 计算特定广告的展现次数 1234567SELECT adid, count(1)FROM tablelateral view explode(adid_list) adTable as adidGROUP BY adid 输出结果为： adid count(1) 1 1 2 1 3 2 4 1 多个 lateral view 查询 表： table2 array col2 [1,2] [“a”，”b”] [3,4] [“c”, “d”] 123456SELECT myCol1, myCol2FROM baseTableLATERAL VIEW explode(col1) myTable1 AS myCol1LATERAL VIEW explode(col2) myTable2 AS myCol2 输出结果为： myCol1 myCol2 1 “a” 1 “b” 2 “a” 2 “b” 3 “c” 3 “d” 4 “c” 4 “d” 字符串函数 函数名 定义 concat() 拼接字符串 length() 计算字符串的长度，一个汉字算三个字符 instr (A ,B ) 返回字符B首次在A中出现的位置,不存在返回0 lcase() 转换成小写 left(string2 ,length ) 从string2中的左边起取length个字符 lower() 将字串转化为小写 upper() 将字符转化为大写 replace() 替换字符 substr() 返回字符串A从start位置开始，长度为len的字符串 substring() 截取字符串 substring_index() 通过截取获取不同索引位的字符 LTRIM (string2 ) 去除前端空格 RTRIM (string2 ) 去除后端空格 字符串截取函数：substr,substring, substring_index 语法: substr(string A, int start, int len),substring(string A, int start, int len) 返回值: string 说明：返回字符串A从start位置开始，长度为len的字符串 举例1： 12345678910use computer_view;select substring(charge_products,2,30)from datawhere hit_date between '2018-10-01' and '2018-10-05'group by charge_productslimit 15 举例2：1234567891011121314select substring(a2.charge_products,2,80), a1.namefrom lookup.products_lookup as a1 join computer_view.data as a2 on a1.product = substring(a2.charge_products,2,80)where hit_date between '2018-10-07' and '2018-10-13' and mall_events is not nullgroup by substring(a2.charge_products,2,80), a1.name 举例3： 123456789101112131415--打断selectsubstring_index(page_url, '?', 1),count(distinct user_tracking_id) as uv,count(page_url) as pv from computer_viewwherehit_date between '2019-04-09' and '2019-04-09' and campaign like "%scjh-scep-tcnr-9yuanka%"group by substring_index(page_url, '?', 1)order by uv DESC CASE 表达式case when 的简单用法 语句 123case when sex = &apos;1&apos; then &apos;男&apos; when sex = &apos;2&apos; then &apos;女&apos;else &apos;其他&apos; end 注意： 必须写 end, else 部分默认为 null 等值转换 有这么一张表 pop ： area(地区) population(万) 渭南市 538 延安市 226 商洛市 238 昆明市 673 曲靖市 650 青岛市 769 需要得出如下表的结果： 省 人口（万） 陕西 1002 云南 1326 其他 769 sql如下：12345678910111213141516171819-- 将地名转换成省select case area when "渭南市" then "陕西" when "延安市" then "陕西" when "商洛市" then "陕西" when "昆明市" then "云南" when "曲靖市" then "云南" else "其他" end as district, sum(population)from pop-- group by -- case area-- when "渭南市" then "陕西"-- when "延安市" then "陕西"-- when "商洛市" then "陕西"-- when "昆明市" then "云南"-- when "曲靖市" then "云南"-- else "其他" end]]></content>
      <categories>
        <category>数据分析技能</category>
      </categories>
      <tags>
        <tag>Hive</tag>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[音乐]]></title>
    <url>%2F2019%2F04%2F23%2F%E7%94%9F%E6%B4%BB%E8%B5%84%E6%96%99-%E9%9F%B3%E4%B9%90%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[李志-回答 卑鄙是卑鄙者的通行证，高尚是高尚者的墓志铭。看吧，在那镀金的天空中，飘满了死者弯曲的倒影。冰川季过去了，为什么到处都是冰棱？好望角发现了，为什么死海里千帆向竞？ 我来到这个世界上，只带着纸、绳索和背影，为了在审判之前，宣读那些被判决了的声音：告诉你吧，世界，我不相信！纵使你脚下有一千名挑战者，那就把我算作那第一千零一名。 我不相信天是蓝的，我不相信雷的回声；我不相信梦是假的，我不相信死无报应。如果海洋注定要决堤，就让所有的苦水都注入我心中；如果陆地注定要上升，就让人类重新选择生存的峰顶。新的转机和闪闪的星斗，正在缀满没有遮拦的天空，那是五千年的象形文字，那是未来人们凝视的眼睛。 李志-忽然 李志-这个世界会好吗？ 李志-热河 李志-黑色信封 李志-梵高先生 李志-关于郑州的回忆 李志-人民不需要自由 李志-墙上的向日葵 李志-光阴路的夏天 李志-动静 李志-看见 李志-14跨年演唱会 左小祖咒/陈升-爱情的枪 Pink Floyd - Wish You Were Here Queen - Love Of My Life 轻音乐-Cello Collection with Calcifer]]></content>
      <categories>
        <category>生活资料</category>
      </categories>
      <tags>
        <tag>音乐</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hive 基础查询]]></title>
    <url>%2F2019%2F04%2F18%2F%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E6%8A%80%E8%83%BD-Hive%E5%9F%BA%E7%A1%80%E6%9F%A5%E8%AF%A2%2F</url>
    <content type="text"><![CDATA[什么是 HiveHive 是一种建立在Hadoop文件系统上的数据仓库架构, 并对存储的数据进行分析和管理，可以将 SQL 语句转换为 MapReduce 任务进行运行，这样就使得数据开发和分析人员很方便的使用 SQL 来完成海量数据的统计和分析。 Hive 擅长的是非实时的、离线的、对响应及时性要求不高的海量数据批量计算，统计分析。 Hive 不适用于在线交易处理 Hive 的常见查询语句 Hive 中的 SELECT 基础语法和标准 SQL 语法基本一致，支持 WHERE、DISTINCT、GROUP BY、ORDER BY、HAVING、LIMIT、子查询等 1. Hive 脚本如何注释可以用 - - 开头的字符串来表示注释， 也可以将需要注释的 sql 选中， 然后用 ctrl + ? 快捷键来进行注释。 2. 切换数据库1use android; 123# 查看当前数据库select current_database() 12# 重置默认数据库use default; 3. 查看表 查看当前使用的数据库中有哪些表 1show tables; 查看非当前使用的数据库中有哪些表 1show tables in myhive; 查看数据库中以 android 开头的表 12use android;show tables like 'android*' 查看表的详细信息 1desc formatted android 4. select…from 语句 基本查询 12# 查询 employee 表中的 name 和 salary。select name, salary from employee; 加入表中一列含有多个元素， 我们可以只查找此列的第一个元素 1select name, subord[0] from employees; 使用键值进行索引 1234567select name, deductions["state taxes"] from employees;# 可以使用 "点" 符号， 类似：表的别名 . 列名 这样的用法select name, address.city from employees; 使用列值进行计算 1234567select upper(name), salary, deductions["Federal Taxes"], rount(salary * (1 - salary, deductions["Federal Taxes"]))from employees;# ZHANGYU 100000.0 0.2 80000 使用正则表达式 12345# 选出所有列名以 price 作为前缀的列select 'price.*' from stocks; 常用的关系运算 12345678910111213 等值比较: = 等值比较:&lt;=&gt; 不等值比较: &lt;&gt;和!= 小于比较: &lt;小于等于比较: &lt;= 大于比较: &gt; 大于等于比较: &gt;= 区间比较 空值判断: IS NULL 非空判断: IS NOT NULL LIKE比较: LIKE JAVA的LIKE操作: RLIKE REGEXP操作: REGEXP 数学运算 123456789加法操作: +减法操作: –乘法操作: *除法操作: /取余操作: %与操作: &amp;或操作: |异或操作: ^取反操作: ~ 常用的聚合函数 1234567891011121314151617count(*) # 个数统计函数count(distinct col) # 统计去重之后的个数sum(col) # 求和sum(distinct col) #去重之后的和avg(col) # 平均值avg(distinct col) # 去重之后的平均值min(col) # 最小值max(col) # 最大值corr(col1, col2) # 相关系数var_pop(clo) # 方差var_samp(col) # 样本方差stddev_pop(col) # 标准偏差stddev_samp(col) # 标准样本偏差covar_pop(col1, col2) # 协方差covar_samp(col1, col2) # 样本协方差select count(distinct account), avg(salary) form employees; 使用别名 1234select count(distinct acount) as uv from employees; 使用limit语句限制返回的行数 123456# 只显示 10 行select count(distinct account) as uvform employees limit 10; 嵌套 select 语句 12345678910select e.name, e.salaryfrom( select upper(name) from employees) as ewhere e.salary &gt; 500; case…when..then句式 123456select name , salary, case when salary &lt; 5000 then 'low' when salary &gt; = 5000 and salary &lt; 70000 then 'middle' else 'high' end as bracket from employees; 5. where 语句, 添加条件 常见用法 1select * from employees where country = 'us' and state = 'ca'; 可以在where条件下计算 12345678select name , salary, deductions['first taxes'], salary * (1-deductions['first taxes'])from employeeswhere round(salary * (1-deductions['first taxes']) ) &gt; 70000;# zhangyu 100000.0 0.2 80000 对上式进行优化 1234567891011select e.* from ( select name , salary, deductions['first taxes'], salary * (1-deductions['first taxes']) from employees ) ewhere round(salary * (1-deductions['first taxes']) ) &gt; 70000; 条件中有浮点数 1234567# 对浮点数进行比较select name, salary, duductions['first taxes']from employees where duductions['first taxes'] &gt; 0.2; 出现的结果中会有 0.2， 因为 DOUBL 和 FLOAT 类型不同 123456select name, salary, duductions['first taxes']from employees where duductions['first taxes'] &gt; cast (0.2 as float); 出现的结果中不会有0.2 like 和 rlike rlike 子句是Hive功能的一个扩展， 可以通过Java的正则表达式来指定匹配条件 12345678select name, address.streetfrom employees where address.street rlikt '.*(beijing|shanghai).*';# 用likeselect name, address from employeeswhere address.street like '%beijing%' or address.street like '%shanghai%'; 6. group by 语句, order by, 与 having 分类并排序 12345678910select year(ymd), avg(price_close) from stockswhere exchange = 'nasdaq' and symbol = 'aapl'group by year(ymd)order by year(ymd) desc; having 子句来限制输出结果 123456789# 例子1select year(ymd), avg(price_close) from stockswhere exchange = 'nasdaq' and symbol = 'aapl'group by year(ymd)having avg(price_close) &gt; 50.0 ; 123456789# 例子2select col1from t1group by col1having sum(col2) &gt; 10 123456789101112131415# 如果没有having， 将要使用嵌套select子查询# 例子1select s2.year, s2.avg from( select year(ymd) as year, avg(price_close) as avg from stocks where exchange = 'nasdaq' and symbol = 'aapl' group by year(ymd)) s2where s2.avg &gt; 50.0 12345678910111213# 例子2select col1 from (select col1, sum(col2) as col2sum from t1 group by col1 ) as t2where t2.col2sum &gt; 10 having 与 where 的区别 Where 是一个约束声明，使用Where约束来自数据库的数据，Where是在结果返回之前起作用的，Where中不能使用聚合函数。 Having是一个过滤声明，是在查询返回结果集以后对查询结果进行的过滤操作，在Having中可以使用聚合函数。 123456789# 查找平均工资大于3000的部门select deparment, avg(salary) as average from salary_info group by deparment having average &gt; 3000 123456789#查询每个部门工资大于3000的员工个数select deparment, count(*) as c from salary_info where salary &gt; 3000 group by deparment 7. join 语句 Hive中Join的关联键必须在ON ()中指定，不能在Where中指定 内连接 只有进行连接的两个表中都存在与连接标准相匹配的数据才会被保留下来。 123456SELECT a.ymd, a.price_close, b.price_closeFROM a JOIN b ON a.ymd = b.ymdWHERE a.symbol = 'Apple' and b.symbol = 'Ibm' ON 子句指定了两个表间数据进行连接的条件。 对于多张表进行连接查询 1234567SELECT a.ymd, a.price_close, b.price_close, c.price_closeFROM a JOIN b ON a.ymd = b.ymd JOIN c ON a.ymd = c.ymdWHERE a. symbol = 'Apple' AND b.symbol = 'Ibm' AND c.symbol = 'Google' 为什么条件内不加表 b 和表 c 进行连接操作， 因为 Hive总是按照从左到右的顺序来执行 Join 优化 Hive 会假定查询中最后一个表是最大的表， 在对每行记录进行连续操作时， 它会尝试将其他表缓存起来，然后扫描最后那个表进行计算。 因此， 我们在查询时， 要保证连续查询中的表的大小从左到右依次是增加的。 假如，在 a, b 两个表中，b表最小， 则 sql 需要修改为： 123456SELECT a.price_close, b.price_closeFROM b JOIN a ON b.ymd = a.ymd AND b.symbol = a.symbolWHERE a.symbol = 'APPLE' 使用 “标记” 来指定哪张表是大表， 不需要排序 123456SELECT /*+Streamtable(a)*/ a.price_close, b.price_closeFROM a JOIN B on a.ymd = b.ymd AND a.symbol = b.symbolWHERE a.symbol = 'Apple' 左外连接 123456SELECT a.price_close, b.price_closeFROM a LEFT OUTER JOIN b on a.ymd = b.ymd AND a.symbol = b.symbolWHERE a.symbol = 'Apple' 左边表符合 WHERE 条件的全部返回，右表不符合 ON 条件的返回 NULL 完全外链接 123456SELECT a.price_close, b.price_closeFROM a FULL OUTER JOIN b on a.ymd = b.ymd AND a.symbol = b.symbolWHERE a.symbol = 'Apple' 返回所有表中符合 WHERE 语句条件的所有记录 Hive 不支持右半开连接 8. 排序 ORDER BY Order by 对查询的所有结果进行排序 可在字段加 DESC 关键字， 进行降序排序。 （默认 ASC， 升序） 1234567891011SELECT a.price_close,FROM a WHERE a.symbol = 'Apple'GROUP BY a.price_closeORDER BY A.PRICE_close DESCLIMIT 10; 9. 子查询 Hive中如果是从一个子查询进行SELECT查询，那么子查询必须设置一个别名 From 子句进行子查询 1234567891011121314151617181920212223242526select dt, count(distinct account) as uv, count(1) as pvfrom (select dt, count(distinct account) as uv, count(1) as pv from client.android_log_viewUNION ALL select dt, count(distinct account) as uv, count(1) as pv from client.ios_log_view ) group by dtorder by dt Hive 0.13 开始， Where 子句也支持子查询 1234567SELECT *FROM AWHERE A.a IN (SELECT foo FROM B); SELECT AFROM T1WHERE EXISTS (SELECT B FROM T2 WHERE T1.X = T2.Y) 将子查询作为一个表的语法，叫做Common Table Expression（CTE） 如果用 distinct, select 后面必须直接跟 distinct 1234567891011121314151617181920212223242526272829with a1 as (select distinct user_account, provincefrom computer_viedatawhere hit_date between '2018-09-01' and '2018-09-30'union allselect distinct user_account, provincefrom computer_view.datawhere hit_date between '2018-09-01' and '2018-09-30')select province, count(distinct user_account) as uvfrom a1group by provinceorder by uv DESC 刷新数据表1refresh table computer_log.client_ios_log 用python脚本连接数据库作为一名数据分析师，日报、周报、月报数据一个也不能少。 相应的， 就要在数据库中提取大量的数据， 并处理大量的Excel表格。 在提取和处理数据的过程中， 对于一些重复性的劳动， 写个Python脚本来实现半自动化， 能够大幅提高自己的工作效率。 以下是自己工作中的一点总结经验。 首先， 用Python连接数据库 对于数据库的ip地址，用户名，密码等， 如果不清楚，或数据库连接不上， 需要和开发人员对接 12345678from pyhive import hive import timeconn = hive.Connection(host='ip地址', port=10000, username='用户名', database = 'default', auth='NOSASL')cursor = conn.cursor()# 获得连接的游标 设置开始和结束时间 可以用python中的time函数设置时间 12startdate = '2018-09-01'enddate = '2018-09-19' 用Python中的format函数将日期传入{}中 python中写sql脚本时， 需要用\来进行换行符的转换, \后面不能有空格。 日期用两个{}来代替， 用format函数将开始日期与结束日期传入 123456789101112131415161718192021222324# 提取积分类uv,pv数据sql_jifenxinxi_an = &quot;&quot;&quot;select count(distinct user_account) as uv, count(1) as pv from computer_view.data where hit_date between &quot;&#123;&#125;&quot; and &quot;&#123;&#125;&quot; and (btn_position like &quot;服务-查询-积分信息%&quot; or btn_home = &quot;积分-扇形左&quot; ) limit 1000&quot;&quot;&quot;.format(startdate,enddate)# format 插入时间cursor.execute(sql_jifenxinxi_an)# 运行此语句cursor.fetchall()#fetchall():接收全部的返回结果行. 我们可以按照这个格式写工作中需要运行的多个SQL语句。 这样， 当脚本运行的时候， 我们可以腾出时间来去干其他工作， 等过一段时间，所有的SQL语句都跑完了， 我们再进行统一的整理。 参考资料：Hive 编程指南Hive的那些事Hive 官网一起学HiveHive性能优化上的一些总结过往记忆——hive]]></content>
      <categories>
        <category>数据分析技能</category>
      </categories>
      <tags>
        <tag>Hive</tag>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[类比汇总]]></title>
    <url>%2F2019%2F03%2F30%2F%E4%B8%AA%E4%BA%BA%E7%B3%BB%E7%BB%9F-%E7%B1%BB%E6%AF%94%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[学习一门技能，你需要知道最少必要知识。 这就好像你拿着一张地图，不可能一下子掌握其中所有的细节，但花几分钟搞清楚 “图例”（Legend）部分总是可以的，知道什么样的线标示的是公交车，什么样的线标示的是地铁，什么样的线标示的是桥梁，然后知道上北下南左西右东 —— 这之后，就可以开始慢慢研究地图了…… 在我们使用函数的过程中，我们常常有意忽略它的内部如何完成从输入到输出之间的处理过程 —— 这就好像我们平日里用灯泡一样，大多数情况下，我们只要知道开关的使用方法就够了 —— 至于为什么按到这个方向上灯会亮，为什么按到另外一个方向上灯会灭，并不是我们作为用户必须关心的事情…… 当然，如果你是设计开关的人就不一样了，你必须知道其中的运作原理；但是，最终，你还是希望你的用户用最简单方便的操作界面，而不是必须搞懂所有原理才能够使用你所设计的产品…… 在任何一本编程书籍之中，关于字符串的内容总是很长 —— 就好像每本英语语法书中，关于动词的内容总是占全部内容的至少三分之二。 教育就像一副眼镜。戴上眼镜之前和之后，我们看到的其实是同样的世界；但是戴上眼镜之后，我们就看得更清楚。 我们是这样一台计算机，厂商（我们的父母）并没有为我们提供详尽的说明书，也不负责定期升级我们的操作系统——即使他们并非故意。 人与人之间很不一样，就好像计算机和计算机之间也很不一样，有些中央处理器（头脑）更强大一些，有些人的内存容量（记忆力）更大一些，有些人的硬盘空间（笔记与藏书）更大一些，有些人显示器（外表）更漂亮一些。 很多人的处理器是落伍的，输入和输出设备常常残缺不全，内存小到没法用的底部，硬盘甚至根本就没有……至于连网设备么，真的很差，甚至真的还不如没有，因为即使连着网也因为缺乏通讯协议而完全无法使用… 科学是由信息构成的，正如房子是用砖头盖的一样，可问题在于，正如仅仅一堆砖头放在那里的时候，我们不能称其为房子一样，一堆信息放在一块就叫科学，有点不像话…… 学习电脑编程的函数时，我把函数想象成铅笔刀，钝铅笔进去，锐利的铅笔出来，这个模型不依赖于图像，但是过程类似。 两个自我： 大象和骑象人 人的感性面就是一头大象，而理智面就是一个骑象人。骑象人骑在大象背上，手里握着缰绳，好像是他在指挥大象，但实际上，他的力量微不足道。一旦和大象发生冲突，他想往左，而大象想往右。那他通常是拗不过大象的。 就像人有一套生理免疫系统来排斥不属于身体的微生物一样，人的心理也有一套免疫系统，它会排斥我们采取新的行为方式，以此来维持心理结构的平衡和稳定。 我们要验证这些假设对不对，什么时候成立，什么时候不成立。 这就像学习游泳，我们既不能只在岸上熟读《怎么学游泳》的书，也不能一下子要求自己跳到深水区，这样就被淹死了。 同一辆车， 在公路上开， 和在泥地上开， 要达到相同的速度， 付出的努力是不同的。 同理， 不同的工作环境和内容， 带来不同的难度， 对采用的技术和努力程度也有不同的要求。 所以只衡量结果却不考虑过程， 有失公平。 考虑过程， 就包括了对工作暖色、环境因素带来的工作复杂度的度量， 也体现了对个人技能、态度的衡量。 中国人是椰子文化，擅长熟人社会的交往规则，不擅长与陌生人打交道。西方人是桃子文化， 擅长与陌生人打交道。 闭环原则是工作中最常用也是最有效的原则，但很少有人能够一直做到。这就像“运动和良好的饮食可以帮助我们保持健康和身材”一样，几乎所有人都知道， 但很少有人能够做到。 “回音壁”效应： 基于数据算法的产品就像是一个回音壁，你发出声音后，应用反馈给你的是与你自己声音相似的回音。你认为自己的“声音”得到了印证，所以你会对自己“声音”的正确性更加坚定不移。由此，你的信息、知识圈层只会更加固话，视野越发狭窄。 爱因斯坦：事情不会在出现问题的那个层面得到解决，只有上升到更高的层面才会得到解决。这就像你家的羊被狼叼走了一只，你往里面补了一只羊，表面上看这个问题解决了。过些天，又有羊被叼走了，你又得不断的补羊。可出是有一天你登高望远，发现原来是羊圈出现了破损，那么你只要把破损的地方补好就可以了。用大海捞针的方式穷举各种可能进行试验，这其实是一种受限于无法利用更高潜能的“笨方法”。如果人自己可以提升视野和维度，去“补羊圈”，问题往往迎刃而解，并不需要无穷次的实验。 只要改变的策略和知识得当，以前看似不可能的事情会变得完全可能，而且简单明了，这就好比要打开一扇锁着的门一样–只有拿对钥匙才能轻松打开。 建立习惯就好像骑自行车上陡坡： 爬坡，到顶，下坡。 刚开始，你必须用双腿的最大力量蹬自行车，之后会渐渐变得轻松，但是你必须一直蹬到山顶，否则就会倒退回原地，让之前所有的进步付诸东流。 你有没有开过不带转向助力装置的汽车？ 方向盘转了好几圈，车的反应却很小。 大脑对改变的反应就像不带转向装置的汽车一样。 每次重复产生的作用可以忽略不计，可是如果不断重复下去，这些微小的变化会给大脑和生活带来巨大的改变。 任何事物能成为基础的第一原则就是它必须牢固可靠，而“激发动力”侧率就像是在液体上盖房子。 我不喜欢动力不是因为它不好。例如，为了写出这些文字，我需要最基本的动力，但动力论到处都是， 人们将其伪装成个人成长的秘方，虽然这不是它本身的错。 这就好像我告诉你胡萝卜能治愈癌症一样，胡萝卜的确对你有益，但它不可能治好任何得癌症的人，于是这个好东西-胡萝卜，已经被塑造成了真理的敌人，在导出招摇撞骗。这么看来，动力是一根邪恶的胡萝卜。 动力偶尔才会产生效果，所以很难评估，对动力策略的长远结果做一番审视，你可能会发现它并不是每次都会奏效。动力也不会轻易改善，因为如果你的狗病死了，你会情绪崩溃，或者你累了或者情绪很差时也会不想锻炼。与此相反的是， 你却能提高克服可能来自感情创伤、缺乏自信、情绪糟糕或者精力不足的抵触情绪，进而采取行动的能力，这种能力就是意志力。 相反，他在脑中植入了一个观点，有点像你在DVD播放器里插入了一张DVD.]]></content>
      <categories>
        <category>个人系统</category>
      </categories>
      <tags>
        <tag>类比</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL面试题]]></title>
    <url>%2F2019%2F03%2F24%2F%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E6%8A%80%E8%83%BD-Hive%E9%9D%A2%E8%AF%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[结合两个表 问题描述： 表1：Preson Column Name Type PersonId int FirstName varchar LastName varchar 表2： Address Column Name Type AddressId int PersonId int City varchar State varchar 要求： 为Person表中的每个人提供以下信息，无论每个人都有一个地址：1FirstName, LastName, City, State 答案： 12345678SELECT Person.FirstName, Person.LastName, Address.City, Address.StateFROM Person LEFT join Address on Person.PersonId = Address.PersonId; 考查点： 使用 join 对两表进行连接查询。 取出排名第 2 高的数据 问题描述 表： Employee Id Salary 1 100 2 200 3 300 要求： 根据上面的 Employee 表，查询返回 薪水工资第二高的数据：200, 如果没有第二高的薪水， 返回Null。 SecondHighestSalary 200 答案 答案1 解法： 在除过第一名薪水中，找出最高的薪水，也就是第二名。 123456SELECT MAX(Salary) as SecondHighestSalaryFROM EmployeeWHERE Salary &lt; (SELECT MAX(Salary) FROM Employee); 答案2 解法： 跳过排名第一的数据， 并取出1条数据，即读取第2条数据。 123456789SELECT DISTINCT Salary as SecondHighestSalaryFROM Employeeorder by Salary DESC limit 1 offset 1-- 可缩写为limit 1,1 但上式写法错误， 因为如果表中没有第二薪水的话，那sql运行报错，而不是返回Null。 我们将其作为临时表可解决此问题： 12345678SELECT (SELECT DISTINCT Salary FROM Employeeorder by Salary DESClimit 1 offset 1) AS SecondHighestSalary 或者使用 IFNULL 1234567891011SELECT IFNULL( (SELECT DISTINCT Salary FROM Employeeorder by Salary DESClimit 1,1), NULL ) AS SecondHighestSalary 延伸 找出排名第三的薪水 1234567891011SELECT IFNULL( (SELECT DISTINCT Salary FROM Employeeorder by Salary DESClimit 2 offset 1), NULL ) AS SecondHighestSalary 对数据进行排序 问题： 表： Scores Id Score 1 3.50 2 3.65 3 4.00 4 3.85 5 4.00 6 3.65 要求： 对以下 Scores 表中的分数进行排名，如果两数相同，则有相同的排名， 排名相等的不会留下空位。 输出结果为： Score Rank 4.00 1 4.00 1 3.85 2 3.65 3 3.65 3 3.50 4 答案 答案1： 步骤1： 返回不同的成绩 1Select Distinct Score from Scores 步骤2： 统计并计算排名 1Select Count(1) + 1 From (Select Distinct Score from Scores) as uniqeScores where Score &gt; sc.Score 步骤3： 汇总 12345678910Select sc.Score, (Select Count(1) + 1 From ( Select Distinct Score from Scores) as uniqeScores where Score &gt; sc.Score) as rank From Scores sc Order by sc.Score Desc; 答案2： 123456select s1.Score, COUNT(DISTINCT s2.Score) Rankfrom Scores s1 inner join Scores s2 on s1.Score &lt;= s2.Scoregroup by s1.Idorder by s1.Score desc 答案3： 12345select Score, dense_rank() over(order by Score) as Rankfrom Scores 延伸 rank、dense_rank、 row_number 的区别 rank函数， 返回数据项在分组中的排名， 排名相等的会留下空位。 如1、2、2、4 dense_rank函数， 返回数据项在分组中的排名， 排名相等的不会留下空位。 如1、2、2、3 row_number函数， 返回数据项在分组中的排名， 排名不管数据是否相等。 如1、2、3、4 留存率 问题： 写出6月5-10号每日客户端活跃用户的次1日、次3日、次7日留存 答案 答案1：123456789101112131415161718192021222324with a1 as (select dt, user_accountfrom computerwhere dt between '2019-06-01' and '2019-06-17'),a2 as (select dt, user_accountfrom computerwhere dt between '2019-06-01' and '2019-06-17')select a1.dt,count(distinct a1.user_account) uv,count(distinct case when datediff(a2.dt, a1.dt) = 1 then a1.user_account else null end ) next_day,count(distinct case when datediff(a2.dt, a1.dt) = 3 then a1.user_account else null end ) three_day,count(distinct case when datediff(a2.dt, a1.dt) = 7 then a1.user_account else null end ) seven_dayfrom a1 join a2 on a1.user_account = a2.user_accountgroup by a1.dtorder by a1.dtlimit 100 输出结果为： 日期 uv 次1日 次3日 次7日 2019/6/1 50231 6578 6642 5154 2019/6/2 42000 6293 5027 4304 2019/6/3 44312 6760 8331 5042 2019/6/4 37852 5298 7133 0 2019/6/5 30678 6082 4648 0 2019/6/6 39405 8173 4972 0 2019/6/7 31267 5352 4920 0 2019/6/8 25614 4451 0 0 2019/6/9 24113 4568 0 0 2019/6/10 26242 0 0 0 答案2：步骤1：1234567891011SELECT dt, count(distinct user_account) as uvFROM computerWHERE dt between '2019-06-01' and '2019-06-17'group BY dtorder BY dt 步骤2：123456789101112131415161718192021222324252627282930-- 统计10-15号每天的次日留存数， 统计次3、7日留存只需将1换为3、7with a1 as ( select user_account, dt from computer where dt between '2019-06-01' and '2019-06-17'),a2 as ( select user_account, dt from computer_view.client_android_log_view where dt between '2019-06-01' and '2019-06-17')select a1.dt, count(distinct a1.user_account) as uvfrom a1 join a2 on a1.user_account = a2.user_accountWHERE a2.dt = date_add(a1.dt, 1) group by a1.dtorder BY a1.dt 步骤3：1留存率 = 用步骤2结果/ 步骤1 结果 连续出现三次的数字 问题： 查找出连续出现至少三次的所有数字 表 Logs 如下： Id Num 1 1 2 1 3 1 4 2 5 1 6 2 7 2 得到如下结果： ConsecutiveNums 1 答案 答案1： 12345678910select distinct a1.Num as ConsecutiveNumsfrom Logs as a1left join Logs as a2 on a1.Id = a2.Id-1left join Logs as a3 on a1.Id = a3.Id -2where a1.Num = a2.Num and a2.Num = a3.Num 答案2： 1234567891011121314select distinct a1.Num as ConsecutiveNumsfrom Logs a1, Logs a2, Logs a3where a1.Id = a2.Id -1 and a2.Id = a3.Id -1 and a1.Num = a2.Num and a2.Num = a3.Num 答案3：1234567891011121314---连续 N 次出现， 则将 3 改为 N 即可。SELECT distinct num as ConsecutiveNumsFROM(SELECT id, num, @pre := @cur, @cur := num, @rep_ct := IF(@pre = @cur, @rep_ct + 1, 1) as rep_ctFROM `Logs` l, (SELECT @pre := null, @cur := 0, @rep_ct := 1) init) temp WHERE rep_ct &gt;= 3 连续 4 个月活跃的用户明细 问题：求出 1-4 月每月连续登陆客户端的用户数 思路 将用户登录的月份按从小到大排序， 找出排序等于 4 的用户 答案 1234567891011121314151617181920212223242526with a1 as(select id, month(dt) as monthfrom datawhere dt between '2019-01-01' and '2019-04-30'group by id, month(dt) ),a2 as ( select id, a1.month, row_number() over(partition by id order by a1.month) as numfrom a1) select count(distinct id) as uvfrom a2where a2.num= 4 查询比经理薪资高的员工姓名 问题 表：Employee 包含员工和经理的Id 与薪水 Id Name Salary ManagerId 1 Joe 70000 3 2 Henry 80000 4 3 Sam 60000 NULL 4 Max 90000 NULL 要求： 查找收入高于经理的员工，得到如下结果： Employee Joe 前3列 来自a1, 后两列来自a2 答案 答案1： 利用 join 对表进行合并前3列 来自a1, 后两列来自a2 Name Salary ManagerId Id Salary Joe 70000 3 3 60000 Henry 80000 4 4 90000 1234567select a1.name as Employeefrom Employee as a1 join employee as a2 on a1.ManagerId = a2.Idwhere a1.Salary &gt; a2.Salary 答案2： 123456789101112131415161718with a1 as ( select name,salary, ManagerId from Employee),a2 as ( select managerid, Id from Employee)select a1.namefrom a1 join a2 on a1.ManagerId = a2.Idwhere a1.Salary &gt; a2.Salary 答案3： 步骤1： 12SELECT *FROM Employee AS a1, Employee AS a2 此步骤输出结果为： 结果将获得这两个标的笛卡尔积，输出结果将使 4*4 = 16条记录， 我们对输出结果进行过滤。 12345678SELECT a.Name AS 'Employee'FROM Employee AS a, Employee AS bWHERE a.ManagerId = b.Id AND a.Salary &gt; b.Salary 找出重复邮件 问题 表： Person Id Email 1 a@b.com 2 c@d.com 3 a@b.com 要求： 找出Person 表中所有重复电子邮件，得到如下结果： Email a@b.com 答案 答案1： 123456789101112select a1.Emailfrom(select Email, count(Email) as numfrom Persongroup by Email) as a1where a1.num !=1 答案2： 12345678select Emailfrom Persongroup by Emailhaving count(Email) !=1 5月中连续7天登陆的用户数 问题:根据用户登录表 data，取出连续登录了K天的用户uid id dt A 2019-06-01 B 2019-06-03 B 2019-06-04 B 2019-06-05 B 2019-06-06 C 2019-06-05 C 2019-06-06 C 2019-06-07 答案： 将用户按照电话号进行排序 id dt num A 2019-05-01 1 B 2019-05-03 1 B 2019-05-04 2 B 2019-05-05 3 B 2019-05-06 4 C 2019-05-05 1 C 2019-05-06 2 C 2019-05-07 3 1234567891011select id, dt, row_number() over(partition by id order by dt) as numfrom Datawhere dt between '2019-05-01' and '2019-05-07'group by id, dt 将日期与排序进行相减 id dt num diff A 2019-05-01 1 2019-04-30 B 2019-05-03 1 2019-05-02 B 2019-05-04 2 2019-05-02 B 2019-05-05 3 2019-05-02 B 2019-05-06 4 2019-05-02 C 2019-05-05 1 2019-05-04 C 2019-05-06 2 2019-05-04 C 2019-05-07 3 2019-05-04 12345678910111213141516171819202122232425with a1 as ( select id, dt, row_number() over(partition by id order by dt) as num from computer_view.client_android_log_view where dt between '2019-06-01' and '2019-06-03' group by id, dt)select id, dt, num, (DATE_SUB(dt, num )) as diff from a1group by id, dt, numlimit 100 统计差值相同的数字个数，并大于等于3 1234567891011121314151617181920212223242526272829303132333435with a1 as ( select user_account, hit_date, row_number() over(partition by user_account order by hit_date) as num from computer_view.client_android_log_view where hit_date between '2019-06-01' and '2019-06-05' group by user_account, hit_date),a2 as (select user_account, hit_date, num, (DATE_SUB(hit_date, num )) as diff from a1group by user_account, hit_date, num)select diff, max(num), count(distinct user_account)from a2group by diffhaving max(num) &gt;= 1limit 100 找出连续登录4天以上的用户数 123456789101112131415161718192021222324252627282930313233343536with a1 as ( select id, dt, row_number() over(partition by id order by dt) as num from computer_view.client_android_log_view where dt between '2019-06-01' and '2019-06-05' group by id, dt),a2 as (select id, dt, num, (DATE_SUB(dt, num )) as diff from a1group by id, dt, num)select id, diff, count(diff) from a2group by id, diff having count(diff) &gt;= 4limit 100 id diff count(diff) B 2019-05-02 4 C 2019-05-04 3 求连续任意天数的用户数 sql分三层第一层：根据条件查询一个时间区间的数据 cha_day 统一计算出一个时间差，然后和当前行数相减。连续的天数和行数相减，结果是一样的第二层：分组求出每个用户的连续天数， rows:排序找出一个用户最大连续天数第三层：连续天数分组，求出人数。 分组天数总人数，应该等于总人数 1234567891011121314151617181920212223242526272829303132333435363738select lx_day, count(user_account)from( select user_account, cha_day, count(cha_day) as lx_day, row_number() over(partition by user_account order by count(cha_day) desc) as rows from ( select datediff(hit_date,'2000-01-01')-row_number() over(partition by user_account order by hit_date) as cha_day, hit_date, user_account from apache_computer_view.client_ios_log where hit_date between '2019-10-15' and '2019-10-20' and nbtn_name = '签到有礼' group by hit_date, user_account )v group by user_account, cha_day)vwhere rows = 1group by lx_dayorder by lx_daylimit 1000 找出未订购任何内容的用户 问题： 表： Customers Id Name 1 Joe 2 Henry 3 Sam 4 Max 表： Orders Id CustomerId 1 3 2 1 要求： 根据上面两个表，找出从未订购任何内容的所有客户。输出结果如下： Customers Henry Max 答案 答案1： 123456SELECT Name as CustomersFROM Customers left JOIN Orders on Customers.Id = Orders.CustomerIdwhere Orders.CustomerId is NULL 答案2： 12345678910select customers.name as Customersfrom customerswhere customers.Id not in (select CustomerId from Orders) 找出各部门薪水最高的员工 问题： 表： Employee Id Name Salary DepartmentId 1 Joe 70000 1 2 Jim 90000 1 3 Henry 80000 2 4 Sam 60000 2 5 Max 90000 1 表： Department Id Name 1 IT 2 Sales 要求：找出各部门薪水最高的员工 Department Employee Salary IT Max 90000 IT Jim 90000 Sales Henry 80000 答案 步骤1： 查出各部门最高薪水 1234567SELECT DepartmentId, MAX(Salary)from Employeegroup by DepartmentId 步骤2： 12345678910111213141516171819selectEmployee.Name as Department,Department.Name as Employee,Salary from Employee join Department on Employee.DepartmentId= Department.Idwhere ((Employee.DepartmentId, Salary) in (SELECT DepartmentId, MAX(Salary)from Employeegroup by DepartmentId))group by Department,Employee,Salary 获取每个部门中薪水前三名的员工 问题： 表：Employee Id Name Salary DepartmentId 1 Joe 85000 1 2 Henry 80000 2 3 Sam 60000 2 4 Max 90000 1 5 Janet 69000 1 6 Randy 85000 1 7 Will 70000 1 表： Department Id Name 1 IT 2 Sales 要求： 找出各部门薪水前三的员工， 输出结果如下： Department Employee Salary IT Max 90000 IT Randy 85000 IT Joe 85000 IT Will 70000 Sales Henry 80000 Sales Sam 60000 答案 步骤1：对各部门薪水进行排序 合并12345678910select Employee.Name AS Employee, Employee.Salary AS Salary, Department.Name AS Department from Employee join Department on Employee.DepartmentId = Department.Id group by Employee, Salary, Department Employee Salary Department Joe 85000 IT Henry 80000 Sales Sam 60000 Sales Max 90000 IT Janet 69000 IT Randy 85000 IT Will 70000 IT 步骤2 ： 找出排名前三的 思路： 再添加一张Employee 表，与步骤1中的 A 表进行对比， 令 B 表中的 salary 大于 A 表中的 salary 条件限制：B表中 salary 大于 A 表中salary 的个数小于3 123456789101112131415select A.Name AS Employee, A.Salary AS Salary, Department.Name AS Department from Employee as A join Department on A.DepartmentId = Department.Id WHERE (select count(distinct B.Salary) from Employee as B WHERE B.Salary &gt; A.Salary and B.DepartmentId = A.DepartmentId) &lt;3 sql题 学生-课程-成绩案例 内容：表： student id name 1 zy 2 hz 3 zy 4 lx 5 lx 表： course id name 1 match 2 python 3 java 表: student_course sid cid score 1 1 60 1 2 50 2 2 80 4 3 90 2 2 80 3 3 50 问题 问题1： 查询 student表中重名的学生， 结果包含id 和name, 按 name 升序 12345678910select name, idfrom studentwhere name in (select name from student group by name having count(name) &gt; 1)order by name 问题2： 查询 student_course 表中的平均份不及格的学生， 列出学生的 id 和平均分 123456789select sid, avg(score) as avg_scorefrom student_coursegroup by sidhaving avg_score &lt; 60 问题3： 查询每门课成绩都不低于80的学生id 123456789101112select distinct sidfrom student_coursewhere sid not in (select score from student_course where score &lt;80) 问题4： 查询每个学生的总成绩，列出学生名称和总成绩 12345select student.name, sum(student_course.score)from student left join student_course on student.id = student_course.sid 问题5：查出总成绩最高的学生 123456789select sid, sum(score)from student_coursegroup by sidorder by sum(score) desclimit 1; 问题6： 查询课程1,成绩第二高的学生 方法1：123456789101112---在除过第一高的成绩中，找出最高的成绩select cid, max(score)from stuent_scorewhere cid =1 and score &lt; (select max(score) from student_score) 方法2： 12345678910111213---跳过排名第一的数据， 取1条数据select max(score)from stuent_scorewhere cid = 1 group by score order by score desc limit 1 offset 1 --limit 1,1 问题7： 查看各科成绩最高的学生id与课程id 1234567891011121314select cid, sid, scorefrom student_course as a1where score &gt;= (select max(score) from stuent_score as a2 where a1.id = ax.id) 错误写法： 12345678select sid, cid, max(score)from student_scoregroup by cid 问题8： 在student_course 表中查询每门课的前2名，结果按照课程id 升序， 同一课程按照成绩降序。 123456789101112131415select *from student_course xwhere 2 &gt;( select count(*) from student_course y where y.cid = x.cid and y.score &gt; x.score)order by cid, score DESC 对每季度数据进行汇总 问题： 表： sales 年 季度 销售 1991 1 11 1991 2 12 1991 3 13 1991 4 14 1992 1 21 1992 2 22 1992 3 23 1992 4 24 要求： 通过 SQL 语句显示以下结果： 年 一季度 二季度 三季度 四季度 1991 11 12 13 14 1992 21 22 23 24 答案： 123456select 年, sum(case when 季度=1 then 销售量 else 0 end) as 一季度, sum(case when 季度=2 then 销售量 else 0 end) as 二季度, sum(case when 季度=3 then 销售量 else 0 end) as 三季度, sum(case when 季度=4 then 销售量 else 0 end) as 四季度 from sales group by 年 解释 lateral view 函数描述 描述： lateral view 用于和 split、explode、collect_set 函数 等一起使用， 能够将一行数据拆成多行数据，在此基础上对拆分后的数据进行聚合。 问题1： 问题 将 表 table 中的 adid_list 转换为单独的行。 表： table pageid adid_list front_page [1,2,3] contact_page [3,4] 答案： 12345SELECT pageid, adidFROM tablelateral view explode(adid_list) adTable as adid 输出结果为：|pageid |adid_list||—|—||front_page|1||front_page|2||front_page|3||contact_page|3||contact_page|4| 问题2： 问题：要求： 计算特定广告的展现次数 答案： 1234567SELECT adid, count(1)FROM tablelateral view explode(adid_list) adTable as adidGROUP BY adid 输出结果为： adid count(1) 1 1 2 1 3 2 4 1 问题3： 问题： 多个 lateral view 查询 表： table2 array col2 [1,2] [“a”，”b”] [3,4] [“c”, “d”] 答案： 123456SELECT myCol1, myCol2FROM baseTableLATERAL VIEW explode(col1) myTable1 AS myCol1LATERAL VIEW explode(col2) myTable2 AS myCol2 输出结果为： myCol1 myCol2 1 “a” 1 “b” 2 “a” 2 “b” 3 “c” 3 “d” 4 “c” 4 “d” 删除重复的电子邮箱 问题 表：Person Id Email 1 zhang@qq.com 2 yu@gmailc.om 3 zhang@qq.com 要求: 删除 Person 表中所有重复的电子邮箱，只保留 Id 最小的那个。 Id Email 1 zhang@qq.com 2 yu@gmailc.om 答案： 答案1： 步骤1：找出 Id 大的重复邮箱 1234567select a1.*from Person a1 join Person a2 on a1.Email = a2. Emailwhere a1. Id &gt; a2.Id 步骤2： 删除 Id 较大的重复邮箱。 123456DELETE a1FROM Person a1 join Person a2 on a1.Email = a2. Emailwhere a1. Id &gt; a2.Id 答案2： 123456DELETE a1FROM Person a1, Person a2 where a1.Email = a2. Email and a1. Id &gt; a2.Id 上升的温度 问题 表： Weather Id(INT) RecordDate(DATE) Temperature(INT) 1 2015-01-01 10 2 2015-01-02 25 3 2015-01-03 20 4 2015-01-04 30 要求：查找与昨天日期相比温度更高的所有日期的 Id, 返回结果如下： Id 2 4 答案： 答案1： datediff 函数 123456SELECT a1.Idfrom Weather a1 join Weather a2 on datediff(a1.RecordDate, a2.RecordDate) = 1 and a1.Temperature &gt; a2.Temperature 答案2： ADDDATE 函数 123456SELECT a1.Idfrom Weather a1 join Weather a2 on a1.RecordDate= date_add(a2.RecordDate,1) and a1.Temperature &gt; a2.Temperature 游戏玩家分析1此表显示某些游戏玩家的活动。每一行都是某天用某些设备登陆并玩多个游戏的玩家记录。 表： Activity player_id device_id event_date games_played 1 2 2016-03-01 5 1 2 2016-05-02 6 2 3 2017-06-25 1 3 1 2016-03-02 0 3 4 2018-07-03 5 要求： 显示每个玩家的第一次登陆日期， 输出如下结果 player_id first_login 1 2016-03-01 2 2017-06-25 3 2016-03-02 答案： 123SELECT a1.player_id, a1.event_date as first_loginFROM activity a1 left join activity a2 on a1.player_id=a2.player_id and a1.event_date&gt;a2.event_dateWHERE a2.event_date is NULL 12345678910select player_id, to_char(event_date, 'yyyy-mm-dd') as first_loginfrom (select player_id, event_date, row_number() over (partition by player_id order by event_date asc) rn from Activity)where rn = 1 https://codeday.me/bug/20190309/737795.html 游戏玩家分析2表： Activity player_id device_id event_date games_played 1 2 2016-03-01 5 1 2 2016-05-02 6 2 3 2017-06-25 1 3 1 2016-03-02 0 3 4 2018-07-03 5 要求： 写取出每个玩家第一次玩游戏的设备号 输出结果如下： player_id device_id 1 2 2 3 3 1 答案： 123456789SELECT a1.player_id, a1.device_idFROM activity a1 left join activity a2 on a1.player_id=a2.player_id and a1.event_date&gt;a2.event_dateWHERE a2.event_date is NULL 12345678select player_id, device_id from ( select * from Activity where (player_id,event_date) in (select player_id, min(event_date) from Activity group by player_id) ) as t 123456789select player_id, device_idfrom (select player_id, device_id, row_number() over(partition by player_id order by event_date asc) rn from Activity)where rn = 1 游戏分析3表：Activity player_id device_id event_date games_played 1 2 2016-03-01 5 1 2 2016-05-02 6 1 3 2017-06-25 1 3 1 2016-03-02 0 3 4 2018-07-03 5 要求： 取出每个玩家在不同日期下的累积玩游戏次数。 例如： 玩家 id 为 1 的玩家， 在 2016-05-02 时，玩游戏的总次数为 5+6=11， 在2017-06-25 时，玩游戏的总次数为 5+6+1=12。 输出结果如下： player_id event_date games_played_so_far 1 2016-03-01 5 1 2016-05-02 11 1 2017-06-25 12 3 2016-03-02 0 3 2018-07-03 5 答案： 12345select player_id, to_char(event_date, 'yyyy-mm-dd') as event_date, sum(games_played) over(partition by player_id order by event_date) games_played_so_farfrom activity 1select a.player_id ,a.event_date,(case when @player_id=a.player_id then @value:=@value+a.games_played when @player_id:=a.player_id then @value:=a.games_played end ) as games_played_so_far from (select * from Activity order by player_id,event_date) a, (select @player_id:=Null,@value:=0)s 游戏分析4表： Activity player_id device_id event_date games_played 1 2 2016-03-01 5 1 2 2016-03-02 6 2 3 2017-06-25 1 3 1 2016-03-02 0 3 4 2018-07-03 5 要求： 查询在首次登陆后第二天再次登陆的玩家比例， 四舍五入到小数点后两位。 换句话说： 你需要计算从首次登陆日期开始至少连续两天登陆的玩家数量， 然后将该数量除以玩家总数。 输出结果如下：| fraction ||———–|| 0.33 | 12345678--- 错误select CAST( count(b.player_id) / count(distinct a.player_id) as decimal(38, 2)) as fractionfrom Activity as aleft join Activity as b on a.player_id = b.player_id and a.event_date = b.event_date+1 123456789101112131415select round(count(if(datediff(a2.event_date ,a1.event_date )=1,1,null))/count(distinct a1.player_id ),2) as fractionfrom Activity a1, Activity a2where a1.player_id =a2.player_id and (a1.player_id,a1.event_date) in ( select player_id , min(event_date) event_date from Activity a3 group by player_id ) 求中位数表： Employee Id Company Salary 1 A 2341 2 A 341 3 A 15 4 A 15314 5 A 451 6 A 513 7 B 15 8 B 13 9 B 1154 10 B 1345 11 B 1221 12 B 234 13 C 2345 14 C 2645 15 C 2645 16 C 2652 17 C 65 要求：查找每个公司的薪水中位数 Id Company Salary 5 A 451 6 A 513 12 B 234 9 B 1154 14 C 2645 答案：https://www.cnblogs.com/jxlwqq/p/5868206.htmlhttps://www.oschina.net/translate/how-to-calculate-median-value-in-mysql-using-a-simple-sql-query 进行排序123456789select Id, Company, Salary, ROW_NUMBER ( ) OVER (PARTITION BY Company order by Salary) as rank_name, count(1) over (partition by company) as numfrom Employee Id Company Salary rank_name num 3 A 15 1 6 2 A 341 2 6 5 A 451 3 6 6 A 513 4 6 1 A 2341 5 6 4 A 15314 6 6 8 B 13 1 6 7 B 15 2 6 12 B 234 3 6 9 B 1154 4 6 11 B 1221 5 6 10 B 1345 6 6 17 C 65 1 6 13 C 2345 2 6 14 C 2645 3 6 15 C 2645 4 6 16 C 2652 5 6 找到中位数 12345678910select id, company, salaryfrom (select id, company, salary, row_number() over (partition by company order by salary) as rank_name, count(1) over (partition by company) as num from employee )where abs(rank_name - (num+1)/2) &lt; 1 -- 顺序编号在公司薪水记录数中间的，即为中位数 查找至少有5名直接下属的经理表：Employee Id Name Department ManagerId 101 John A null 102 Dan A 101 103 James A 101 104 Amy A 101 105 Anne A 101 106 Ron B 101 要求： 查询来查找至少有5名直接下属的经理 输出结果为： Name John 答案： 123456789select a2.Namefrom Employee a1 join Employee a2on a1.ManagerId = a2.Idgroup by a1.ManagerIdhaving count(*) &gt;=5 给定数字的频率查中位数表： Numbers Number Frequency 0 7 1 1 2 3 3 1 要求： 数字为 0, 0, 0, 0, 0, 0, 0, 1, 2, 2, 2, 3，所以中位数是 (0 + 0) / 2 = 0，输出结果如下 median 0.0000 答案： 1234567891011121314151617181920select avg(n2.number) medianfrom (select min(n.number) numberfrom (select number, frequency, (@cumsum:=@cumsum+frequency) 'cumsum'from numbers ,(select @cumsum:=0) temp order by number) nwhere n.cumsum &gt;= (floor(((SELECT SUM(frequency) FROM numbers) +1 ) / 2))union select min(n1.number) numberfrom (select number, frequency, (@cumsum1:=@cumsum1+frequency) 'cumsum'from numbers ,(select @cumsum1:=0) temp order by number) n1where n1.cumsum &gt;= (ceil(((SELECT SUM(frequency) FROM numbers) +1 ) / 2))) n2; 找出当选最多的人名称表： Candidate id Name 1 A 2 B 3 C 4 D 5 E 表： Vote id CandidateId 1 2 2 4 3 3 4 2 5 5 表 Candidate 为候选人名称表， 表 Vote 中CandidateId 是 Candidate表中的 id。 要求： 找出当选者的名称，返回结果为当选者B。输出结果如下：| Name ||——|| B | 答案：12345678910111213141516select Namefrom Candidatewhere id = ( select CandidateId from Vote group by CandidateId order by count(*) DESC LIMIT 1 ) 选出所有 bonus &lt; 1000的员工的 name 以及 bonus表：Employee empId name supervisor salary 1 John 3 1000 2 Dan 3 2000 3 Brad null 4000 4 Thomas 3 4000 表：Bonus empId bonus 2 500 4 2000 要求： 选出所有 bonus &lt; 1000的员工的 name 以及 bonus。输出结果如下 name bonus John null Dan 500 Brad null 答案： 123456789select a1.name, a2.bonusfrom Employee as a1 left join Bonus as a2 on a1.empid = a2.empid where ifnull (bonus, 0) &lt; 1000 12345678910select a1.name, a2.bonusfrom Employee as a1 left join Bonus as a2 on a1.empid = a2.empid where nvl (bonus, 0) &lt; 1000 谁有最多的好友表： request_accepted 表中存储了所有好友申请通过的数据记录，其中，requester_id 和 accepter_id 都是用户的编号。 requester_id accepter_id accept_date 1 2 2016_06-03 1 3 2016-06-08 2 3 2016-06-08 3 4 2016-06-09 要求： 求出谁拥有最多的好友和他拥有的好友数目。输出结果如下 id num 3 3 答案： 1234567891011121314select id as id, ucnt as numfrom( select id, count(1) as ucnt from ( select requester_id as id from request_accepted union all select accepter_id as id from request_accepted ) group by id order by ucnt desc)where rownum = 1 找出人流量的高峰期表：stadium id visit_date people 1 2017-01-01 10 2 2017-01-02 109 3 2017-01-03 150 4 2017-01-04 99 5 2017-01-05 145 6 2017-01-06 1455 7 2017-01-07 199 8 2017-01-08 188 要求： 找出人流量的高峰期。高峰期时， 至少连续三行记录中的人流量不少于100。得出结果如下 id visit_date people 5 2017-01-05 145 6 2017-01-06 1455 7 2017-01-07 199 8 2017-01-08 188 答案： 1234567SELECT distinct a.*FROM stadium as a,stadium as b,stadium as cwhere ((a.id = b.id-1 and b.id+1 = c.id) or (a.id-1 = b.id and a.id+1 = c.id) or (a.id-1 = c.id and c.id-1 = b.id)) and (a.people&gt;=100 and b.people&gt;=100 and c.people&gt;=100)order by a.id; 12345678910111213141516select id, to_char(visit_date, 'yyyy-mm-dd') as visit_date, peoplefrom (select id, visit_date, people, count(1) over (partition by offset) cnt from (select id, visit_date, people, (row_number() over (order by id) - id) offset from stadium where people &gt;= 100 ) )where cnt &gt;= 3 -- 连续 3 天（及以上）order by id 预约连续空余座位表：cinema seat_id free 1 1 2 0 3 1 4 1 5 1 要求：获取所有空余座位，并将它们按照 seat_id 排序。输出结果如下 连续空余座位的定义是大于等于 2 个连续空余的座位。1 表示空余，0 表示已被占据。 seat_id 3 4 5 答案： 1234567891011121314151617181920select seat_idfrom(select seat_id, count(1) over (partition by num) as cumfrom( select seat_id, (row_number() over (order by seat_id) - seat_id) as numfrom cinemawhere free = 1))where cum &gt;= 2order by seat_id 找出符合条件的电影表：cinema id movie description rating 1 War great 3D 8.9 2 Science fiction 8.5 3 irish boring 6.2 4 Ice song Fantacy 8.6 5 House card Interesting 9.1 要求： 找出所有影片描述为非 boring (不无聊) 的并且 id 为奇数 的影片，结果请按等级 rating 排列。输出结果如下 id movie description rating 5 House card Interesting 9.1 1 War great 3D 8.9 答案1：12345678910select *from cinemawhere mod(id, 2) = 1 and description != 'boring'order by rating DESC 答案2：12345678910select *from cinemawhere description != 'boring' and id % 2 !=0order by rating DESC 表：Sales sale_id product_id year quantity price 1 100 2008 10 5000 2 100 2009 12 5000 7 200 2011 15 9000 表：Product product_id product_name 100 Nokia 200 Apple 300 Samsung 要求： 编写sql查询， 选择每个销售产品的第一年的数据， 输出结果如下 product_id first_year quantity price 100 2008 10 5000 200 2011 15 9000 答案：123456789101112131415select product_id, year as first_year, quantity, pricefrom ( select product_id, year, quantity,price, rank() over(partition by product_id order by year) rn from sales)where rn=1 找到购买所有产品的顾客表1： customer customer_id product_key 1 5 2 6 3 5 3 6 1 6 表2： product | product_key |+————-+| 5 || 6 | 要求： 找出从 customer 表中购买了 product 表所有产品的客户id。 输出结果如下 customer_id 1 3 答案：123456789101112select customer_idfrom customergroup by customer_idhaving count(distinct product_key) = (select count(distinct product_key) from product ) 12345678910111213141516select customer_idfrom (select customer_id, count(distinct product_key) as num from customer group by customer_id) as a1join ( select count(product_key) as num from product) as a2on a1.num = a2.num 查询关注者的关注数据表：follow followee (博主) follower(关注者) A B B C B D D E 要求： 查询每个关注者， 被多少人关注。 输出结果如下： follower num B 2 D 1 B 和 D 都在在 follower 字段中出现，作为博主，B 被 C 和 D 关注，D 被 E 关注。A 不在 follower 字段内，所以A不在输出列表中。 答案： 123456789101112select f1.follower, count(distinct f2.follower) as numfrom follow f1inner join follow f2 on f1.follower = f2.followeegroup by f1.followerorder by f1.follower 如何用python操作mysql步骤 安装 mysql-connector 1pip install mysql-connector 连接数据库 通过 connection 对数据库的连接进行管理， 通过 cursor 创建游标对数据库中的数据进行操作。 12345678910111213import mysql.connector# 创建数据库连接db = mysql.connector.connect( host='ip地址', user = "root", passwd = "1234", # 数据库密码 database = 'default', # 连接的数据库 auth_plugin = 'mysql_native_password" )# 获取操作游标cursor = db.cursor() 编写sql语句 123456789# 输出sql 语句sql = """select btn_namefrom cinemawhere hit_date = "2019-07-26" """ 执行sql语句并返回结果 1234567891011121314# 执行sql语句cursor.execute(sql)# 获取数据集中的所有行cursor.fetchall()# 获取数据中的第一行# cursor.fetchone()# 获取数据集中的n条数据# cursor.fetchmany(n)# 返回数据集中中的行数# cursor.rowcount 关闭游标和数据库连接 12345# 关闭游标cursor.close()# 关闭数据连接db.close() 延伸： 捕获异常信息。 在对数据进行增加、删除和修改时， 可能会出现异常，需要对异常数据进行捕获。 123456789101112131415161718import tracebacktry: sql = """INSER INTO player (team_id, player_name, height) VALUES (%s, %s, %s)""" val = (1000, "zhangyu", 1.95) # 执行sql语句 cursor.execute(sql, val) # 进行提交 db.commit() print(cursor.rowcount, "记录插入成功。")except Exception as e: # 打印异常信息 traceback.print_exc() # 回滚 db.rollback()finally: # 关闭数据库连接 db.close() 参考资料： 极客时间-sql必知必会 求出每个项目中经验最丰富的员工表：Project table project_id employee_id 1 1 1 2 1 3 2 1 2 4 表：Employee table employee_id name experience_years 1 Khaled 3 2 Ali 2 3 John 3 4 Doe 2 要求： 求出每个项目中经验最丰富的员工， 输出结果如下 ID为1和3的员工，在第一个项目中拥有最丰富的经验， 对于第二个项目， ID为1的员工拥有最丰富的经验 project_id employee_id 1 1 1 3 2 1 答案： 1234567891011select project_id, employee_idfrom (select p.project_id, e.employee_id, rank() over(partition by p.project_id order by e.experience_years desc) rn from project p, employee e where p.employee_id = e.employee_id)where rn = 1 求所有员工的平均工作经验，保留2位小数。表： Project project_id employee_id 1 1 1 2 1 3 2 1 2 4 +————-+————-+ 表：Employee employee_id name experience_years 1 Khaled 3 2 Ali 2 3 John 1 4 Doe 2 要求： 求每个部门所有员工的平均工作年限， 保留两位小数。输出结果如下 第一个项目的平均工作年限为（3+2+1）/ 3 = 2.00第二个项目的平均工作年限为（3+2）/ 2 = 2.50 project_id average_years 1 2.00 2 2.50 答案1：123456789select project_id, round(avg(experience_years),2) as average_yearsfrom Project, Employeewhere Project.employee_id = Employee.employee_idgroup by project_id 查询每个专业的学生人数 一所大学有 2 个数据表，分别是 student 和 department ，这两个表保存着每个专业的学生数据和院系数据。 表：student student_id student_name gender dept_id 1 Jack M 1 2 Jane F 1 3 Mark M 2 表：department dept_id dept_name 1 Engineering 2 Science 3 Law 要求： 查询 department 表中每个专业的学生人数 （即使没有学生的专业也需列出）。将你的查询结果按照学生人数降序排列。 如果有两个或两个以上专业有相同的学生数目，将这些部门按照部门名字的字典序从小到大排列。输出结果如下 dept_name student_number Engineering 2 Science 1 Law 0 答案1： 1234567891011SELECT a1.dept_name, COUNT(student_id) AS student_number FROM department a1 LEFT JOIN student a2 ON a1.dept_id = a2.dept_id GROUP BY a1.dept_nameORDER BY student_number DESC, a1.dept_name 答案2：12345678910111213141516select dept_name, (case when student_num is null then 0 else student_num end) student_numberfrom(select dept_id, count(*) student_numfrom studentgroup by dept_id) t1right join department t2 on t1.dept_id=t2.dept_idorder by student_number desc, dept_name asc 表：salesperson 表 salesperson 存储了所有销售员的信息。每个销售员都有一个销售员编号 sales_id 和他的名字 name 。 sales_id name salary commission_rate hire_date 1 John 100000 6 4/1/2006 2 Amy 120000 5 5/1/2010 3 Mark 65000 12 12/25/2008 4 Pam 25000 25 1/1/2005 5 Alex 50000 10 2/3/2007 表：company 表 company 存储了所有公司的信息。每个公司都有一个公司编号 com_id 和它的名字 name 。 com_id name city 1 RED Boston 2 ORANGE New York 3 YELLOW Boston 4 GREEN Austin 表： orders 表 orders 存储了所有的销售数据，包括销售员编号 sales_id 和公司编号 com_id 。| order_id | order_date | com_id | sales_id | amount ||———-|————|———|———-|——–|| 1 | 1/1/2014 | 3 | 4 | 100000 || 2 | 2/1/2014 | 4 | 5 | 5000 || 3 | 3/1/2014 | 1 | 1 | 50000 || 4 | 4/1/2014 | 1 | 4 | 25000 | 要求： 根据给定的三个表，salesperson， company， orders。输出所有表 salesperson 中，没有向公司 ‘RED’ 销售任何东西的销售员。 根据表 orders 中的订单 ‘3’ 和 ‘4’ ，容易看出只有 ‘John’ 和 ‘Pam’ 两个销售员曾经向公司 ‘RED’ 销售过。所以我们需要输出表 salesperson 中所有其他人的名字。 输出： name Amy Mark Alex 答案1： 1234567891011121314SELECT a1.nameFROM salesperson a1 LEFT JOIN orders a2 ON a1.sales_id = a2.sales_id LEFT JOIN company a3 ON a2.com_id = a3.com_idGROUP BY a1.nameHAVING SUM(IF(a3.name = 'RED', 1, 0)) = 0ORDER BY a1.sales_id 答案2： 12345678910111213select a1.namefrom salesperson a1where not exists (select * from orders a2 join company a3 on a2.com_id=a3.com_id where a3.name='RED' and a1.sales_id=a2.sales_id) 答案3：123456789101112SELECT name FROM salesperson WHERE sales_id not in (SELECT DISTINCT a1.sales_id FROM orders a1 LEFT JOIN company a2 ON a1.com_id = a2.com_id WHERE a2.name = 'RED') LeetCodeAnimation https://github.com/MisterBooo/LeetCodeAnimation leetcode 题解 https://github.com/azl397985856/leetcode LeetCode所有题目 http://leetcode.liangjiateng.cn/leetcode/game-play-analysis-ii/description SQL语句数据分析面试必备 https://mp.weixin.qq.com/s/ol-jheA3TTv0qqtFtEt_ow]]></content>
      <categories>
        <category>数据分析技能</category>
      </categories>
      <tags>
        <tag>Hive</tag>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读书档案]]></title>
    <url>%2F2019%2F02%2F20%2F%E7%94%9F%E6%B4%BB%E8%B5%84%E6%96%99-%E4%B8%AA%E4%BA%BA%E6%88%90%E9%95%BF%E4%B9%A6%E5%8D%95%2F</url>
    <content type="text"><![CDATA[需读书籍数据分析： 《网站分析实战》 《精益数据分析》 《运营之光》 《计算广告》 《新零售：低价高效的数据赋能之路》 《增长黑客》 《女士品茶》 《数据化管理》 《流量池》 麦肯锡： 《麦肯锡教我的思考武器》 《麦肯锡教我的写作武器》 《麦肯锡意识》 《麦肯锡方法》 《麦肯锡图表工作法》 《麦肯锡教我的谈判武器》 《麦肯锡笔记思考法》 《麦肯锡精英高效阅读法》 批判思维与逻辑思维： 《批判性思维工具》 《学会提问》 《金字塔原理》 《零秒思考》； 已写文章 行动： 每天问自己的10个问题 如何学习： 《学习之道》 《如何学习》 《刻意练习》；已写文章 《刻意学习》；读书笔记 《好好学习-个人成长指南》 ；已写文章 ； 读书笔记 行动： 反思日记 如何生活： 《基本穿搭-适用一生的穿衣法则》 《奇特的一生》 《我是个怪圈》 《习惯的力量-原版》 《医治受伤的自信》 《智能时代》 职场技能： 《精准表达：让你的方案在最短的时间内打动人心》 《小强升职记》 《像外行一样思考，像专家一样实践》 你凭什么做好互联网 如何思考： 《系统之美》 《思考-快与慢》 《原则》 《怎样解题》 《第五项修炼》 《穷查理宝典》 《改变》 《万万没想到-用理工科思维理解世界》； 已写文章 适合产品经理的十本书 - 俞军入门必读 《社会心理学》 阿伦森 插图第七版：特别好，适合成为“产品经理的第一本书” 《第一本经济学》 经济学帮助人们洞察世事 《学会提问》 学习辨别信息和言论的真假对错 以上三本都是既可以当做产品经理的入门书读，又可以在职业生涯反复读的书。 思维： 《认知心理学及其启示》 人类认知和思维的基本机制 《 思考快与慢》 人如何有缺陷地思考 《 超越智商》 如何克服缺陷做理性决策 《思维与决策》 第四版 系统介绍思维与决策领域的研究 学习深度思考和决策需要的书籍，以上四本够用很久了，因为仅仅阅读多是没用的，最终还是阅读、思考、实践的最短板决定决策水平。 经济学： 《经济学原理》 曼昆版 微观分册 最通用的经济学教材 《错误的行为》 行为经济学离PM最近，但尚无好教材，先用这一本占坑 《新制度经济学 一个交易费用分析范式》 学习交易费用思考商业模式 《魔鬼经济学》 史蒂芬.列维特 《统计数据会撒谎》 统计陷阱 《超级数字天才》 《女士品茶》 其他推荐阳志平：双十一买书指南认知科学入门书单]]></content>
      <categories>
        <category>生活资料</category>
      </categories>
      <tags>
        <tag>书单</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[业务分析——埋点方案]]></title>
    <url>%2F2018%2F12%2F22%2F%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E6%8A%80%E8%83%BD-%E5%9F%8B%E7%82%B9%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[APP埋点上报规则如何制定埋点中业务的痛点： 改版前后，同一位置命名不统一，导致数据提取比较麻烦。 按钮数据出现漏采，多发情况。 数据埋点不能很好的服务于业务， 有些业务的划分埋点也许要埋点。 数据埋点业务繁琐，埋点需求-埋点方案-需求评审-研发实施-埋点测试-埋点更正-上线数据采集。 每一步都比较繁琐。 用户换端，导致有些数据追踪不到。 数据统计埋点工作框架及细节规范 https://zhuanlan.zhihu.com/p/78267447 数据分析入门：初识数据埋点（一） http://www.woshipm.com/data-analysis/872543.html 有赞埋点实践 https://tech.youzan.com/track-1/ 美团点评前端无痕埋点实践 https://tech.meituan.com/2017/03/02/mt-mobile-analytics-practice.html 知乎客户端埋点流程、模型和平台技术 https://zhuanlan.zhihu.com/p/40985361 数据埋点方案 埋点需求： 代码埋点 无埋点 全埋点 埋点方案比较 埋点实施流程 不同场景的埋点方案 https://www.sensorsdata.cn/blog/20181114-2/ 问题： 需求整理不完善， 没有整体考虑， 版本更替原有埋点不可用 数据统计口径不清楚，没有将埋点的具体采集时机郑群传达，埋点不是自己想要定义的指标 数据采集方案没有想清楚， 哪些应该在前端埋点，哪些应该在后端埋点，埋点采集sdk如何正确使用没有了解清楚 数据采集和埋点方式全埋点（无埋点、自动埋点）什么是全埋点？ 《Android 全埋点技术白皮书》 无埋点实现监测的真相——革新还是噱头？ 什么是全埋点预先收集用户的所有行为数据， 然后根据实际分析需求从中提取行为数据。 在产品中嵌入SDK，等于做了一个统一的埋点，对于其他行为，则不需要调用SDK代码。 无埋点的优势 可视化展现宏观指标，满足基本的数据分析需求。 能够采集uv、pv等基础数据。 如果仅仅看宏观数据，并没有精细化分析需求，并且是对客户端做的分析，则全面点是比较省事的选择。 技术门槛低，使用与部署比较简单。 只需要嵌入SDK，极大程度避免了因需求变更、埋点错误等原因导致重新埋点的复杂工作。 用户友好性强。可以直接应用手指或鼠标进行操作，自动向服务器发送数据，避免手工埋点错误。 无埋点的缺点 无埋点只能采集到用户交互数据，且适合标准化的采集，自定义属性的采集需要代码埋点来辅助。每个用户的交互行为均有许多属性，无埋点无法深入到更细、更深的维度。 电商行业，用户点击“购物车”是一次交互行为，无埋点会忽悠用户信息、商品品类等其他维度的信息。用户上滑屏幕，内容瀑布流的底部加载、商品或广告的加载展示、下拉菜单中下拉内容的数据点击情况，都需要代码采集来辅助实现。 会存在数据采集不全面、传输时效性差、数据可靠性无法保证等问题。 代码埋点什么是代码埋点 前端埋点(wap链接上能够查看埋点数据)：在前端嵌入SDK的方式，对于每一个关键行为，我们都需要调用SDK代码，将必要的事件名、属性字段等写入代码，然后发送到后台数据服务器。 后端埋点(wap链接上无法查看发送数据内容，只能通过后端来发送)：将相关的事件、属性等通过后端模块调用SDK的方式，发送到后台服务器。 后端采集数据到分析系统中则是通过内网传输，这个阶段不存在安全和隐私性问题。同时内网传输基本不会因网络原因丢失数据，所传输的数据可以非常真实地反映用户行为。 优点更适合精细化分析的场景，我们可以将各种细粒度的数据采集下来，方便后续深度分析需求。 Jupyter在美团民宿的应用实践图床 #]]></content>
      <categories>
        <category>数据分析技能</category>
      </categories>
      <tags>
        <tag>数据分析</tag>
        <tag>埋点方案</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Pandas 库总结]]></title>
    <url>%2F2018%2F09%2F28%2F%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E6%8A%80%E8%83%BD-Pandas%E5%BA%93%2F</url>
    <content type="text"><![CDATA[python中的单引号，双引号，三引号的不同作用 Pandas简介Pandas是python数据分析中一个非常核心的数据库， 在日常的工作中经常需要使用Pandas库来对数据进行处理分析。Pandas的核心为两大数据结构， Series和DataFrame，Series用于存储一维数据， 而DataFrame存储多维数据。 常用的软件-Anaconda是数据分析中运行python的一款利器， 安装教程可参考Anaconda入门使用指南 时间函数12import timefrom datetime import datetime, time, timedelta 现在时间 1now = datetime.now() 昨天 12ysd = now - timedelta(days = 1)ysd = now.replace(day = now.day-1) 本月第一天 1month_first = now.replace(day = 1) 上月最后一天 1lastmonth_end = month_first - timedelta(days=1) 上月第一天 123lastmonth_first = now.replace(month = now.month-1, day =1)lastmonth_first = lastmonth_end.replace(day=1) 转化为日期形式 1this_firsts = lastmonth_first.__format__(&quot;%Y-%m-%d&quot;) 12345678import datetimefrom dateutil.relativedelta import relativedelta begin = datetime.date(2019,1,1)end = datetime.date(2019,1,31)for i in range(1,10): first = d + relativedelta(months=i) last = end + relativedelta(months=i) 读取与写入Excel数据相对路径与绝对路径: https://blog.csdn.net/m0_37693335/article/details/81474995 读取文件夹的内容 r（转义符）避免路径中的\被转义。路径中不加 \ 则需要把所有的\写成/。 1234567891011import pandas as pdimport numpy as npfrom pandas import Series, DataFrameimport osfile_list = os.listdir(r&apos;E:\工作文件\周报\周数据\测试\0902-0908&apos;)print(file_list, &apos;\t&apos;)# 读取当前文件夹地址os.getwd() 读取xls格式Excel表 1234df = pd.read_excel(&apos;E:/工作文件/周报/周数据/测试/0902-0908/an-商品汇总-uv.xls&apos;)df = pd.read_excel(r&apos;E:\工作文件\周报\周数据\测试\0902-0908\an-商品汇总-uv.xls&apos;)df = pd.read_excel(r&apos;E:\工作文件\周报\周数据\测试\0902-0908\an-商品汇总-uv.xlsx&apos;) 读取csv格式Excel表 12345678df = pd.read_csv('E:/工作文件/周报/周数据/测试/0902-0908/商品汇总.csv')# 读取csv文件，并用 分隔符分割df = pd.read_csv(r'E:\商品汇总.csv', sep = " ")# 只读取文件前两行df = pd.read_csv(r'E:\商品汇总.csv', nrows = 2) 读取显示编码错误： python 默认的编码格式是’utf-8’ 12345# 显示错误为：UnicodeDecodeError: 'utf-8' codec can not decode byte 0xb5 in position 0: invalid start byte# 修改方式df = pd.read_csv(path + '登记用户 20191127.csv',encoding="gbk" ) 123456789# 当文件路径包含中文解析错误时，设置 engine 参数来消除这个错误# 错误原因， 当调用read_csv方法时，默认使用C语言作为解析语言，只需要将默认值c语言更改为python# 如果文件格式是 csv usf-8, 那么编码也改为 utf-8-sig# 如果文件格式是 csv格式， 则编码格式为 gbkdf = pd.read_csv('登记用户 20191127.csv', engine = 'python', encoding = 'utf-8-sig') 读取txt格式数据 1df = pd.read_table(r&apos;C:\Users\Administrator\Desktop\haha.txt&apos;, sep = &apos; &apos;) 12345with open(r&apos;C:\Users\Administrator\Desktop\haha.txt&apos;, &apos;r&apos;) as f: df = f.readlines() df = np.loadtxt(r&apos;C:\Users\Administrator\Desktop\haha.txt&apos;) # 将txt文件存为numpy数组 读取excel中的sheet名称 12345678910111213141516df = pd.read_Excel(r'E:\工作文件\an-商品汇总-uv.xlsx', sheet_name = 'sheet1')# 传入sheet的顺序，从0开始计数df = pd.read_Excel(r'E:\工作文件\an-商品汇总-uv.xlsx', sheet_name = 0)# 读取sheet,并制定文件中的第几行做行索引df = pd.read_Excel(r'E:\工作文件\an-商品汇总-uv.xlsx', sheet_name = 0, index_col = 0)# 读取sheet文件， 并制定文件中的第几列做列索引df = pd.read_Excel(r'E:\工作文件\商品汇总.xlsx', sheet_name = 0, head = 1)# 当本地文件过多时，可以通过设定 usecols 参数来指定要导入的列df = pd.read_Excel(r'E:\商品汇总.xlsx', usecols = 0)# uescols = [0,2] 12345678910rbook = []kong_data = os.listdir(r&apos;F:\省资源位&apos;)for file_name in kong_data: data_excel = pd.ExcelFile(r&apos;F:\省资源位\\&apos;+file_name) sheet = data_excel.sheet_names for i in sheet: data_button_rest = pd.read_excel(r&apos;F:\省资源位\\&apos;+file_name, sheet_name= i ) rbook.append(data_button_rest) result_df =pd.concat(rbook)datas_excel = pd.DataFrame(result_df) 将运行的所有数据都展现出来， 而不是只展现最后一条12from IPython.core.interactiveshell import InteractiveShellInteractiveShell.ast_node_interactivity = &quot;all&quot; 将数据写入Excel表， 并输出 123data.to_excel(&apos;C:/Users/Administrator/Desktop/&apos;+&apos;商品分类.xlsx&apos;)data.to_excel(r&apos;C:\Users\Administrator\Desktop\\&apos;+&apos;商品分类.xlsx&apos;)data.to_excel(r&apos;C:\Users\Administrator\Desktop/&apos;+&apos;商品分类.xlsx&apos;) 将求出的数据存储在excel中的多个sheet中12345678910import pandas as pdfrom openpyxl import load_workbook writer = pd.ExcelWriter('F:/notebooks/zhoushuju.xlsx')btn_navigation.to_excel(writer, sheet_name = '底部导航')shouye_top20.to_excel(writer, sheet_name = '首页top20')shouyedier_top2.to_excel(writer, sheet_name = '首页第二屏top20')writer.save()writer.close() 其他数据格式12345678910111213141516171819202122232425262728293031# 从SQL表/库导入数据 import pymysqleng = pymysql.connet(host= &apos;100.129&apos;, user = &apos;root&apos;, password = &apos;1234&apos;, df = &apos;db&apos;, charset = &apos;ugf8&apos;)query = &quot;&quot;&quot;select * from android_log &quot;&quot;&quot;df = pd.read_sql(query, eng)# 导出数据到SQL表 df.to_sql(table_name, eng)&lt;!-- # 从JSON格式的字符串导入数据 pd.read_json(json_string) --&gt;&lt;!-- # 解析URL、字符串或者HTML文件，抽取其中的tables表格 pd.read_html(url) --&gt;&lt;!-- # 从你的粘贴板获取内容，并传给read_table() pd.read_clipboard() --&gt;&lt;!-- # 从字典对象导入数据，Key是列名，Value是数据pd.DataFrame(dict) --&gt;&lt;!-- # 以Json格式导出数据到文本文件df.to_json(filename) --&gt;``` 6. 常见问题：* 当文件有中文时， 可能会出现错误：Initializing from file failed 有中文， 可以用此方法解决 f = open(‘我的文件.csv’)res = pd.read_csv(f)123456789101112131415161718192021222324252627* 修改数据格式，并存储```pythonimport pandas as pdimport numpy as npimport os#切换工作目录os.chdir(r&apos;E:\detil_data&apos;)显示当前目录os.getcwd()# 将目录变成列表data = os.listdir()# for 循环此目录for i in data: a = open(i) datas = pd.read_csv(a) datas.to_csv(&apos;F:\\zy_data\\文件\\&apos;+ i +&apos;222.csv&apos;, index=False,encoding=&apos;utf_8_sig&apos; )#datas = pd.read_csv(&apos;a.csv&apos;,encoding=&apos;gbk&apos;)# datas.to_csv(&apos;test12.csv&apos;, index=False,encoding=&apos;utf_8_sig&apos; ) 123456import os path = os.getcwd() + "/"# pathfile_list = os.listdir()a= [name for name in file_list if name.startswith("登记用户")] 当文件特别大， 1个多G时， 可以用for循环查看数据 12for i in data: print(i) 查看大文件有多少列 1234data = open(&apos;E:/用户明细.csv&apos;)data1 = pd.read_csv(data, iterator=True)data2 = data1.get_chunk(5)print(data2) 迭代器 对输出数据进行处理pandas的数据输出显示设置 123456789101112131415import numpy as npimport pandas as pddf = pd.DataFrame(np.random.randn(150, 150))# pd.set_option('expand_frame_repr', False) #数据超过总宽度后，是否折叠显示pd.set_option('display.width', 100) #数据显示总宽度pd.set_option('max_rows', 100) #显示最多行数，超出该数以省略号表示pd.set_option('max_columns', 100) #显示最多列数，超出该数以省略号表示pd.set_option('max_colwidth', 16) #设置单列的宽度，用字符个数表示，单个数据长度超出该数时以省略号表示pd.set_option('large_repr', 'truncate') #数据超过设置显示最大行列数时，带省略号显示/若是info则是统计信息显示pd.set_option('show_dimensions', True) #当数据带省略号显示时，是否在最后显示数据的维度print(df)pd.set_option('max_info_columns', 100) #当列数超过这个值时，调用df.info()函数时不会统计每列的非空值。print(df.info()) 将数据变成小数形式12345678910import pandas as pd inputfile = '../data/electricity_data.xls'outputfile = './electricity_data_analyze1.xls' data = pd.read_excel(inputfile)data[u'线损率'] = (data[u'供入电量']-data[u'供出电量'])/data[u'供入电量'] #data[u'线损率']的类型为series； data[u'线损率']为小数data[u'线损率'] = data[u'线损率'].apply(lambda x: format(x, '.2%')) #Series.apply()让序列的值依次在lambda函数中执行； data['线损率']由小数转化为百分数 data.to_excel(outputfile, index=False) 描述数据 表信息 1df.info() 显示数据的行列数 1df.shape 查看数据格式dtpyes 1df.dtypes 显示列名、元素 12df.columnsdf.values 添加默认列名 12# 如果数据没有标题行，可用pandas添加默认的列名df = pd.read_excel(&apos;x.xlsx&apos;, header = None) 显示前数据前5行 12df.head(5)df[[&apos;标题&apos;, &apos;客户端uv&apos;]].head() 显示数据后5行 1df.tail(5) 值 1df.values 读取a列 1df[&apos;a&apos;] 修改索引 1df = df.set_index[&apos;标题&apos;] 显示数据唯一值（unique函数） 12# 数据有0， 是因对缺失值进行了填充df[&apos;经纪人级别&apos;].unique() 对第几行数据不读取 12#不读取哪里数据，可用skiprows=[i]，跳过文件的第i行不读取df = pd.read_excel(&apos;x.xlsx&apos;,skiprows=[2] ) 对缺失值进行识别 12# 所有缺失值显示为Truepd.insull(df) # df.isnull() 计算 1234567891011#计算此data的数量df[&apos;data&apos;].value_counts()# 升序计数df[&apos;data&apos;].value_counts(ascending = True)# 升序计数并分组df[&apos;data&apos;].value_counts(ascending = True, bins = 2)# 计数df[&apos;data&apos;].count() 字符和数值之间的转化1234int() # 转化成整数float() # 转化成浮点数str() # 转化成字符type() # 查看格式 数据清洗 删除空值 （dropna函数） DataFrame中的空值处理 123df.dropna(how=&apos;any&apos;)df.dropna(how = &apos;all&apos;) 123456789用法：DataFrame.drop(labels=None,axis=0, index=None, columns=None, inplace=False)参数说明：labels 就是要删除的行列的名字，用列表给定axis 默认为0，指删除行，因此删除columns时要指定axis=1；index 直接指定要删除的行columns 直接指定要删除的列inplace=False，默认该删除操作不改变原数据，而是返回一个执行删除操作后的新dataframe；inplace=True，则会直接在原数据上进行删除操作，删除后无法返回。 123# 删除包含 集团 二字 的行read_data = data_excel_2[- data_excel_2[&apos;所属省份名称&apos;].isin([&apos;集团&apos;])] 填充空值（fillna函数） 12345# 空值用0填充df.fillna(value=0)# 用均值对空值进行填充df[&apos;经纪人响应时长&apos;].fillna(df[&apos;经纪人响应时长&apos;].mean()) 更改数据格式，更改数据类型 12# 将数据格式int64,改为float格式df[&apos;大区&apos;].astype(&apos;float64&apos;) 更改列名称, 修改列名。 123data2.columns = [[&apos;导航&apos;,&apos;uv&apos;, &apos;pv&apos;,&apos;户均点击&apos;]]df.rename(columns=&#123;&apos;IM渠道&apos;: &apos;渠道&apos;&#125;) 找到重复值 1df.duplicated() 删除重复值 Pandas删除数据的几种情况 12345678# 默认第一次出现的保留，其余删除df['门店'].drop_duplicates()# 最后一次出现的保留，其余删除df['门店'].drop_duplicates(keep = 'last')# 多列去重df.drop_duplicates(subset = ['姓名', '唯一识别码']) 对列表内的值进行替换 1df[&apos;客户UCID&apos;].replace(&apos;10531975&apos;, &apos;110&apos;) 获取数据分布情况 1data.describe() 修改数据 1234567891011121314# 修改结果df.replace(参数)# 修改索引df.rename(参数)# 增加, 将一列数据添加到另一列数据后。 df.append(参数)# 删除def df[&apos;a&apos;]df.drop([&apos;a&apos;, &apos;b&apos;], inplace = True) 对数据进行处理 对两个数据进行合并- mearge, join, concat函数 1234567891011121314151617181920212223242526272829303132# 按照轴把多个对象拼接起来pd.concat(df1, df2)# join函数适合根据索引进行合并，合并索引相同但列不同的对象# merge函数，根据一个或多个键连接多行, 相当于excel中的vlookupleft = pd.DataFrame(&#123;&apos;key&apos;:[&apos;ko&apos;,&apos;k1&apos;,&apos;k2&apos;,&apos;k3&apos;], &apos;key2&apos; : [&apos;ko&apos;,&apos;k1&apos;,&apos;k2&apos;,&apos;k3&apos;], &apos;A&apos; :[&apos;ao&apos;,&apos;a1&apos;,&apos;a2&apos;,&apos;a3&apos; ], &apos;B&apos; : [&apos;bo&apos;,&apos;b1&apos;,&apos;b2&apos;,&apos;b3&apos; ]&#125;)right =pd.DataFrame(&#123;&apos;key&apos;:[&apos;ko&apos;,&apos;k1&apos;,&apos;k2&apos;,&apos;k3&apos;], &apos;key2&apos; : [&apos;ko&apos;,&apos;k1&apos;,&apos;k2&apos;,&apos;k4&apos;], &apos;c&apos; :[&apos;co&apos;,&apos;c1&apos;,&apos;c2&apos;,&apos;c3&apos; ], &apos;d&apos; : [&apos;do&apos;,&apos;d1&apos;,&apos;d2&apos;,&apos;d3&apos; ]&#125;)# 将left和right进行合并pd.merge(left, right)# 指定以key为键进行合并pd.merge(left, right, on = &apos;key&apos;) pd.merge(name_3, name_1, left_on = [&apos;ming&apos;], right_on = [&apos;标记&apos;])# key2列不相同的部分会直接舍弃掉pd.merge(left, right, on = [&apos;key&apos;, &apos;key2&apos;])# 保留key2列不相同的部分pd.merge(left, right, on = [&apos;key&apos;, &apos;key2&apos;], how = &apos;outer&apos;)# 不相同的部分指定以左表为基准pd.merge(left, right, on = [&apos;key&apos;, &apos;key2&apos;], how = &apos;left&apos;) 将 list 格式转化成 DataFrame 格式 1df = pd.DataFrame(data, columns = [&apos;省份&apos;, &apos;按钮名称&apos;, &apos;uv&apos;, &apos;pv&apos;] ) 对数据进行排序 12345data =pd.DataFrame(&#123; &apos;group&apos;:[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;a&apos;], &apos;data&apos; : [4, 2, 5, 6, 7, 8, 2, 9, 4]&#125;)# 在保证group列降序的情况下，对data列进行升序处理data.sort_values(by = [&apos;group&apos;, &apos;data&apos;],ascending = [False, True], inplace = True) 对数据进行分组——excel中的数据透视表 123456789# 如果price列的值&gt;3000，group列显示high，否则显示lowdf[&apos;group&apos;] = np.where(df[&apos;客户当天发送消息数&apos;] &gt; 5,&apos;high&apos;,&apos;low&apos;)# 对符合多个条件进行分组# 符合经纪人级别为A1且经纪人响应时长&gt;24的在sign列显示为1df.loc[(df[&apos;经纪人级别&apos;] == &apos;A1&apos;) &amp; (df[&apos;经纪人响应时长&apos;]&gt;= 24.0), &apos;sign&apos;]=1 对数据进行分列 12pd.DataFrame((x.split(&apos;网&apos;) for x in df[&apos;客户注册渠道&apos;]), index=df.index,columns=[&apos;客户注册渠道&apos;,&apos;size&apos;]) 新增一列 123data = data.assign(ration = [4, 2, 5, 6, 7, 8, 2, 9, 4])data[&apos;rations&apos;] = [5, 2, 5, 6, 7, 8, 2, 9, 4] 对数据进行切分 12bins = [1,3,6,9]data_cut = pd.cut(data[&apos;data&apos;], bins) 取出的数据， 指定取到小数点几位数？ 123456# 取到小数点后3位for i in a : print(&quot;%.3f&quot;%c)# 设置小数点位数，四舍五入df[&apos;cnts&apos;].round( decimals = 2) 数据选择 选择某一列/ 某几列 12345678910111213# 普通索引- 根据名称进行选择df['客户端uv']df[['标题', '客户端uv']]# 位置索引， 切片索引， 根据所在第几列进行选择df.iloc[:, [0,2]] # 获取第1列和第3列的数值# : 表示选择所有的行， 逗号后面表示要选择列的位置区域 选择某一行/某几行 12345678910# 普通索引-locdf.loc['第一行']df.log[['第一行', '第二行']]# 位置索引，切片索引df.iloc[0] # 选择第一行df.iloc[[0,1]] # 选择第一行和第二行 根据指定条件进行筛选 123456789101112131415161718# 选择年龄小于200的数据df[df['年龄'] &lt; 200] #年龄小于200，且id小于300df[(df['年龄'] &lt; 200) &amp; (df['id'] &lt; 300)]df[np.logical_and(df['年龄'] &gt; 10, df['id'] &gt; 5)]# A列值大于10，或 B列值大于5df[(df['A'] &gt; 10) | (df['C'] &gt;20)]df[np.logical_or(df['A'] &gt; 10, df['C'] &gt; 20)]# 当 A列的值大于13时， 显示B，c列的值df[['B','C']][df['A']&gt;13] 行列同时选择 对数据进行提取,筛选 按条件进行提取 1234567891011121314# 用isin函数进行判断# 使用isin函数根据特定值筛选记录。筛选A值等于10或者13的记录df[df.A.isin((10, 13))]# 判断经纪人级别是否为A3df[&apos;经纪人级别&apos;].isin([&apos;A3&apos;]) # 先判断结果，将结果为True的提取#先判断经纪人级别列里是否包含A3和M4，然后将复合条件的数据提取出来。df.loc[df[&apos;经纪人级别&apos;].isin([&apos;A3&apos;,&apos;M4&apos;])] 按索引进行提取 1234567891011121314151617181920212223242526272829303132333435363738394041# 取标签为2,3,4， A列的数据， 显示为Series格式df.loc[2:4, 'A']# iloc函数# 行和列都用index来进行提取df.iloc[0:5, 1:3] # 返回第一行 df.iloc[0,:]# 返回第一列的第一个元素df.iloc[0,0]#[0, 2, 5] 代表指定的行，[ 4, 5 ] 代表指定的列df.iloc[[0,2,5],[4,5]]# 获取第1列到第4列的值df.iloc[:, 0:3]# ix#ix的功能更加强大，参数既可以是索引，也可以是名称，相当于，loc和iloc的合体df.ix[1:3, ['A', 'B']]# at函数根据指定行index及列label，快速定位DataFrame的元素，选择列时仅支持列名df.at[3, 'A']# iat函数选择时只使用索引参数df.iat[3, 2] 按日期进行提取 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import pandasimport datetime as dt# 重新设置索引df.reset_index()#设置日期为索引df=df.set_index(&apos;日期&apos;)#提取2016年11月2号的数据df[&apos;2016-11-02&apos; : &apos;2016-11-02&apos;]dt_time = dt.datetime(year = 2018, month=9, day = 17, hour = 22, minute = 43)print(dt_time)#构造时间ts = pd.Timestamp(&apos;2018-09-17 22:43:00&apos;)ts = pd.to_datetime(&apos;2018-09-17 22:43:00&apos;)ts = pd.to_datetime(&apos;17/09/2018 22:43:00&apos;)# 月份ts.month#日期ts.day# 加日期ts + pd.Timedelta(&apos; 10 days&apos;)ts.hour# 构造时间序列， 构造十个日期， 每12分钟一次pd.Series(pd.date_range(start = &apos;2018-09-17 22:43:00&apos;, periods = 10, freq = &apos;12min&apos;))读取文件， 有时间列， 先将时间字符串转换成时间格式， 再进行处理或当读取数据时， 就对数据格式进行修改data = pd.read_csv(&apos;.../db.csv&apos;, index_col = 0, parse_dates = True)# 读取时间为2013年的所有数据data[&apos;2013&apos;]# 取所有8点到12点之间的数据, 不包含8点和12点data[(data.index.hour &gt; 8) &amp; (data.index.hour &lt; 12)]# 包含8点到12点data.between_time(&apos;08:00&apos;, &apos;12:00&apos;)# 时间序列的重采样-看每月的平均值data.resample(&apos;M&apos;).mean() 数据汇总 对数据进行分类 - group by函数 123456789101112131415161718192021222324# 创建数组df = pd.DataFrame(&#123;&apos;key&apos; : [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;,&apos;a&apos;, &apos;b&apos;, &apos;c&apos;,&apos;a&apos;, &apos;b&apos;, &apos;c&apos;], &apos;data&apos; : [0, 2, 4, 5, 6, 7, 8, 9, 4]&#125;)# 分别计算a, b, c 的和df.groupby(&apos;key&apos;)[&apos;data&apos;].sum()df.groupby(&apos;key&apos;)[&apos;data&apos;].mean()s = pd.Series([1, 2, 3,1, 2, 3],[8,7,6,8,7,6])# 对索引进行排序grouped = s.groupby(level = 0， sort =False)grouped.first()df2 = pd.DataFrame(&#123;&apos;x&apos;:[&apos;a&apos;, &apos;b&apos;, &apos;a&apos;, &apos;b&apos;], &apos;y&apos; : [1, 2, 3, 4]&#125;)# 只关注x中的bdf3 = df2.groupby([&apos;x&apos;]).get_group(&apos;b&apos;)# 查看个数df2.size() 对数据进行透视, 相当于Excel中的数据透视表功能。 将行变为列 12345678910111213pd.pivot_table(data, values=None, index=None, columns=None, aggfunc=&apos;mean&apos;)df = pd.DataFrame(&#123;&quot;A&quot;: [&quot;foo&quot;, &quot;foo&quot;, &quot;foo&quot;, &quot;foo&quot;, &quot;foo&quot;, &quot;bar&quot;, &quot;bar&quot;, &quot;bar&quot;, &quot;bar&quot;], &quot;B&quot;: [&quot;one&quot;, &quot;one&quot;, &quot;one&quot;, &quot;two&quot;, &quot;two&quot;, &quot;one&quot;, &quot;one&quot;, &quot;two&quot;, &quot;two&quot;], &quot;C&quot;: [&quot;small&quot;, &quot;large&quot;, &quot;large&quot;, &quot;small&quot;, &quot;small&quot;, &quot;large&quot;, &quot;small&quot;, &quot;small&quot;, &quot;large&quot;], &quot;D&quot;: [1, 2, 2, 3, 3, 4, 5, 6, 7]&#125;)table = pd.pivot_table(df, values=&apos;D&apos;, index=[&apos;A&apos;, &apos;B&apos;], columns=[&apos;C&apos;], aggfunc=np.sum) 将列变为行 1pd.melt(df2, id_vars=[&apos;date&apos;], value_vars = [&apos;&apos;,&apos;&apos;]) 对数据进行映射 12# 用map函数对字典进行映射， 新加一列data[&apos;upper&apos;] = data[&apos;group&apos;].map(dataUpper) 数据统计 数据采样 12345678910111213# 简单随机抽取sampledf.sample(n=3)# 设置采样权重# 需要对每一行进行权重设置，列表行数少可行，过多不可行# 假设有4行数据，设置采样权重weights = [0, 0, 0.5, 0.5]df.sample(n=4, weights=weights)## 确定采样后是否放回# 采样后放回，Truedf.sample(n=6, replace=True) 统计计算 1234567891011121314151617181920# 描述统计 describe函数#自动生成数据的数量，均值，标准差等数据#round（2）,显示小数点后面2位数，T转置df.describe().round(2).T# 标准差std()df[&apos;经纪人响应时长&apos;].std()# 协方差covdf[&apos;经纪人当天发送消息数&apos;].cov(df[&apos;客户当天发送消息数&apos;]# 相关性分析corrdf[&apos;客户当天发送消息数&apos;].corr(df[&apos;经纪人当天发送消息数&apos;])# 中位数df.median() 对字符串进行操作 大小写 12a.lower()a.upper() 长度 12# 长度a.len() 去除空格 123a.strip()a.lstrip()alrstrip() 替换 1df.columns.str.replace(&apos; &apos;, &apos;_&apos;) 切分与分列、 合并 123456789101112131415161718192021222324252627#切分a.split(&apos;_&apos;)# 切分， 且成为新列a.split(&apos;_&apos;, expand = True)# 对切分进行限制, 只切1次a.split(&apos;_&apos;, expand = True, n=1)# 查看是否包含a.str.contains(&apos;A&apos;)# 分列s.str.get_dummies(sep= &apos;|&apos;)# pandas对dataframe中的某一列使用split做字符串切割：# words = df[&apos;col&apos;].split()# 报错：# AttributeError: &apos;Series&apos; object has no attribute &apos;split&apos;# 原因是df[&apos;col&apos;]返回的是一个Series对象，需要先把Series对象转换为字符串：pandas.Series.str.split# words = df[&apos;col&apos;].str.split()对两列数据进行合并df[&apos;省份_名称&apos;] = df[&apos;省份&apos;].str.cat(df[&apos;名称&apos;],sep = &apos;_&apos;)]]></content>
      <categories>
        <category>数据分析技能</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一个好用的插件]]></title>
    <url>%2F2018%2F09%2F25%2F%E7%94%9F%E6%B4%BB%E8%B5%84%E6%96%99-%E5%A5%BD%E7%94%A8%E7%9A%84%E6%8F%92%E4%BB%B6%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[一个好用的插件神器最近发现了一个特别能够提高生活幸福感的插件：Tampermonkey, 中文翻译过来叫做油猴。 安装好这个插件最大的作用， 就是我们可以从Greasy Fork这个网站来安装我们需要的脚本， 从而极大的提高浏览器的使用效率。 比如：我们在Greasy Fork网站找到智能划词翻译这个脚本， 然后点击安装脚本即可。安装完成脚本之后， 我们打开一个英文网页，对需要翻译的段落进行框选，点击翻译按钮，就可实现在原网页查看中文翻译， 对于我这种英语不好的人来说， 有很大的帮助。 我们还可以安装微博过滤设置脚本，来对微博页面进行个性化设置， 自己设置完成后的微博页面是这个样，相对于原版网页来说简洁了不少。 也可安装微博浮图脚本， 查看微博图片也比较方便， 只需把鼠标光标放在图片上即可 如果想找资料或电影资源的话， 也可以下载豆瓣资源下载大师, 或百度网盘直接下载助手等脚本， 当然，有能力还是要支持正版。 例如：安装豆瓣资源下载大师脚本后， 打开豆瓣电影网页， 页面是这个样子。 在Greasy Fork这个网站还有很多别人写好的脚本， 比如百度文库文字复制、购物党自动比价工具、 Download Youtube videos and subtitles等好用的脚本， 可以根据自己的需要进行安装。]]></content>
      <categories>
        <category>生活资料</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[个人资料收集]]></title>
    <url>%2F2018%2F08%2F05%2F%E7%94%9F%E6%B4%BB%E8%B5%84%E6%96%99-%E8%B5%84%E6%BA%90%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"><![CDATA[互联网工具 指数类 百度指数 http://index.baidu.com/v2/index.html#/ 微博指数 https://data.weibo.com/index/ 各种数据指数 http://data.chongbuluo.com/ 企业类 企业信用信息公示系统 http://www.gsxt.gov.cn/index.html 国家统计局 http://data.stats.gov.cn/ 企查查 财报类 上交所http://www.sse.com.cn/ 深交所http://www.szse.cn/ 港交所https://www.hkexnews.hk/ 美国上市公司https://www.sec.gov/ 同花顺财经http://data.10jqka.com.cn/ 分析工具 语义分析系统http://ictclas.nlpir.org/nlpir/ 腾讯文智 https://nlp.qq.com/semantic.cgi#page2 echarts https://echarts.baidu.com/ 在线图片识别文字 https://ocr.wdku.net/ 问卷调查 https://www.wjx.cn/ 视频： 科普-计算机科学速成课 纪录片-设计的艺术 纪录片-小兵小赵 访谈-子夜.大学之殇 月球视频 最后的演讲 性，死亡与生命的意义 统计学：statistics —— CrashCourse 锵锵行天下 蓝色星球 风味人间 成功的原则 youtube视频：Rachel’s English 纪录片-生门 电影-生门 纪录片-人生果实 《人类星球》梦与狂想的王国《尘与雪》《人生七年》《身份的焦虑》 《铁西区》《和凤鸣》《原油》 书： The Non-Designer’s Design Book (4th Edition) 英文原版免费编程书籍 网站： RSS收集网站 知笔墨 微软海底机房摄像头直播 全球免费摄像头直播 设计类网站 漫画-海报 Our the in World 中国知网 统计学可视化 cnki免费下载文献：账号：hqwytsg015 密码：cnki015 北京值得去的地方 纪录片——AlphaGo youtube最受欢迎的频道 写作网站 博客 TED:阅读全世界 阮一峰的个人网站 追求对知识概念和原理进行更合适的描述 《用数据讲故事》作者博客 万维钢的博客 w4lle’s Notes = android技术博客 stormzhang 廖祜秋的博客 最好的数据分析博客汇总 数据分析类网站 Kaggle 统计之都 纪杨的网站数据分析笔记 蓝鲸的网站分析笔记 Cloga的互联网笔记 陈老师的天善智能博客文章 秦路-文章 数据可视化网站 一起大数据 数据分析问答 数学公式转换MD格式 信息图制作 简历制作网站 多人协同任务清单 GA小站-一个Google Analytics 和Adobe Analytics 经验分享平台 TED 如何掌控你的自由时间 —— 时间=选择 提升自信的技巧 —— 除非你做到了，否则没有人相信你 【TED】科技公司如何控制你的注意力 我从生活和写作中学到了12个真理 - 一个一个写，改初稿， 如果不知道写什么，就写你自己经历的事情 收入如何影响人们的生活方式——世界各国， 收入水平导致的生活条件改变都差不多官方网站 图表的魔力——图表能够让人更快的理解信息 如何利用大数据做出正确的判断-用大量数据去做分析， 去深入了解， 但要想成功， 就需要冒一定的风险 大数据时代：如何避免数据迷信？-不光要依靠大数据， 也要依靠厚数据，让解决问题的方法更加多元化 李开复：人工智能如何拯救人类-ai让我们明白我们为何为人 开启情绪识别的大门-用算法来识别人类情绪 有趣的故事 盗醉猴 植物修炼成精之后还有没有细胞壁？ NBA 感人的比赛或者画面有哪些？ 有没有一部电影让你在深夜中痛哭？ 为什么法海要阻止白素贞和许仙在一起？ What are some amazing pictures one has to see twice to understand? 21世界100部伟大的电影 幽默段子-银教授什么时候有空？也没什么事，就是想占用你一辈子的时间，想和你过过日子。 我这人特别不实在，除了实在想你。 ​​​​ 你这日子一天天过的，没什么两样，都是喜欢我的一天 我把电脑抱在怀里安慰了很久，因为它的系统崩溃了。 ​​​​ 没钱真的会被人看不起。今天叫朋友还我一千块钱，朋友说：“借我一万的人都没找我要，你哪来的脸开口？” 我羞愧无比，暗暗发誓等我有钱了，一定要多借点给他。 总觉得自己过了18岁就能慢慢成熟起来，没想到我每年都是十八岁]]></content>
      <categories>
        <category>生活资料</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python基础学习]]></title>
    <url>%2F2018%2F07%2F25%2F%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E6%8A%80%E8%83%BD-python%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[数 整数-int 123i = 1# 查看变量的类型type(i) 浮点数-float 12340.2 * 0.10.020000000000000004 浮点数在计算机中表输入的十进制浮点数仅由实际存储在计算机中的近似的二进制浮点数表示,二进制来表达 1/10 是一个无限循环小数:0.0001100110011001100110011001100110011001100110011…,Python 只打印机器中存储的二进制值的十进制近似值。 如何限制显示的小数点个数 1print(&quot;&#123;:.4f&#125;&quot;.format(0.1*0.4)) 字符串-str 字符串的表示方式： python中有3种表示字符串的方式——单引号，双引号，三引号。 单引号和双引号的作用是相同的, 但双引号中可以将包含的特殊字符单引号输出，而单引号要输出’需要/转义 123456str = &apos; \&apos;hello world\&apos; &apos;print(str)str = &quot;&apos;hello python&apos;&quot;print(str) 三引号的用法特殊，三引号中可以输入单引号、双引号或换行符等字符,也可用作制作文档字符串 123str = &apos;&apos;&apos;&apos;hello&apos;/&quot;world&quot;&apos;&apos;&apos;print(str) 常用的字符串处理方法 1234# 重复字符串sta = &apos;hi&apos;print (sta * 2) 1234# 切片sta = &apos;1234567890&apos;print(sta[2:9:2]) 123456789#去除空格name = &apos; zhang yu &apos;# 去除左侧空格print(name.lstrip())# 去除右侧空格print(name.rstrip())# 去除两侧空格print(name.strip()) 123456789101112# 分割字符串#split()函数通过制定分隔符对字符串进行切片name = &quot;zhang and yu and han&quot;print(name.split())print(name.split(&apos; &apos;,2))print(name.split(&apos; and &apos;))# partition()函数将目标字符串分割为两个部分，返回一个三元元组（head,sep,tail），包含分割符url = &quot;https://zhangandyu.github.io//2018&quot;print( url.partition(&quot;//&quot;))print(url.rpartition(&quot;//&quot;)) 1234567# 替换字符串#str.replace(old, new,max)# max 可选字符串不能超过max次str = &quot;this is a apple&quot;print (str.replace(&quot;is&quot;, &quot;was&quot;)) print (str.replace(&quot;is&quot;, &quot;was&quot;, 1)) 1234# 拼接字符串a = &apos;_&apos;name = (&apos;zhang&apos;, &apos;and&apos;, &apos;yu&apos;)print(a.join(name)) 12345678910#查找字符串是否包含子字符串#str.find(str, beg=0, end=len(string))a = &apos; this is a apple&apos;b = &apos;is&apos;#从下标3开始，查找在字符串里第一个出现的子串，返回结果：3print(a.find(b,2)) #从下标5开始，查找在字符串里第一个出现的子串，返回结果：6print(a.find(b,5)) 12345678910111213#判断字符串是否以指定的前后缀结尾# str.startswith(str, beg=0,end=len(string))a = &apos;this is a apple&apos;b = &apos;th&apos;c = &apos;is&apos;print(a.startswith(b))print(a.startswith(c,2))a = &apos;this is a apple&apos;b = &apos;le&apos;c = &apos;app&apos;print(a.endswith(b))print(a.endswith(b,10)) 1234567891011121314151617181920212223#其他函数# 检测数字str.isdigit() # 检测字符串是否只由数字组成str.isnumeric() # 检测字符串是否只由数字组成,这种方法是只针对unicode对象str.isdecimal() # 检查字符串是否只包含十进制字符。这种方法只存在于unicode对象# 检测字母str.isalpha() # 检测字符串是否只由字母组成# 检测字母和数字str.isalnum() # 检测字符串是否由字母和数字组成# 检测其他str.isspace() # 检测字符串是否只由空格组成str.islower() # 检测字符串是否由小写字母组成str.isupper() # 检测字符串中所有的字母是否都为大写str.istitle() # 检测字符串中所有的单词拼写首字母是否为大写，且其他字母为小写str.capitalize() # 将字符串的第一个字母变成大写,其他字母变小写str.lower() # 转换字符串中所有大写字符为小写str.upper() # 将字符串中的小写字母转为大写字母str.swapcase() # 对字符串的大小写字母进行转换max(str) # 返回字符串 str 中最大的字母min(str) # 返回字符串 str 中最小的字母len(str) # 返回字符串的长度str(arg) # 将 arg 转换为 string 布尔值 and-逻辑与 or-逻辑或 not-逻辑非 not的优先级大于and和or的优先级，而and和or的优先级相等。 逻辑运算符的优先级低于关系运算符，必须先计算关系运算符，再计算逻辑运算符。 变量命名规则 只能包含字母、数字和下划线 不能包含空格 不能将python关键字和函数名用作变量名 变量名应简短又具有描述性 慎用小写字母l和大写字母O 序列 什么是序列 序列是Python中最基本的数据结构。 python中有6个序列的内置类型,包括列表、元组、字符串、Unicode字符串、buffer对象和xrange对象。 对于序列，都可以使用一下操作： 索引 切片 加 乘 成员检查in和not in 计算序列的长度len() 取序列中的最大、最小值max()和min() 列表 列表是最常用的Python数据类型，它可以作为一个方括号内的逗号分隔值出现 列表适合用于存储在程序运行期间可能变化的数据集。 列表是可以修改的， 这对处理网站的用户列表或游戏中的角色列表至关重要。 列表对象方法 12 list.append(x)# 把一个元素添加到列表的结尾 12 list.extend(x)# 将一个给定列表中的所有元素都添加到另一个列表中 12 list.insert(i,x)# 在指定位置插入一个元素 12list.remove(x)# 删除列表中值为 x 的第一个元素 12list.pop(i)# 从列表的指定位置删除元素，并将其返回 12 list.clear()# 从列表中删除所有元素 12list.index(x)# 返回列表中第一个值为 x 的元素的索引 12list.count(x)# 返回 x 在列表中出现的次数 12 list.sort()# 对列表中的元素进行排序 12list.sorted()# 对列表中的元素进行临时排序 12list.reverse()# 倒排列表中的元素 12list.copy()# 返回列表的一个浅拷贝 12list.len(x)#返回列表的长度 用列表实现栈和列队 栈是一种后进先出的数据结构，我们可以使用列表的append()和pop()方法了实现 123a = [1,2]a.append(3) #入栈a.pop() # 最后一个元素出栈 队列是一种先进先出的数据结构，我们可以使用列表的append()和pop(0)方法了实现 123a = [2,1]a.append(1) # 入队列a.pop(0) # 第0个元素出队列 列表推导式 为从序列中创建列表提供了一个简单的方法。 普通方法 12345a = []for i in range(20): a.append(i ** 2)print(a)# i 依然存在 123456b = []for x in [1,2,3,4]: for y in [2,3,4]: if x !=y: b.append((x,y))print(b) 推导式 12a = [i**2 for i in range(20)]print(a) 1[(x,y) for x in [1,2,3,4] for y in [2,3,4] if x !=y] 12from math import pi[str(round(pi, i)) for i in range(1, 16)] 12345matrix = [ [1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]][[row[i] for row in matrix] for i in range(4)] 元组 元组为不可变得列表， 在需要创建一系列不可修改的元素时使用。 只有一个元素元组中只包含一个元素时， 需要在元素后面添加逗号，否则括号会被当做运算符使用 12zy = (2,)zy[0] 修改元组 对元组进行连接组合 1234na = (&apos;z&apos;, &apos;y&apos;)me = (&apos;y&apos;, &apos;u&apos;)name = na + meprint(name) 给元组变量赋值 123na = (&apos;zy&apos;, &apos;yu&apos;)na = (&apos;y&apos;, &apos;u&apos;)print(na) 元组运算符 123456789101112# 计算元组个数len((2,45, 67, 8, 9))# 连接(1,2,3, 4) + (4, 5, 6)# 复制(1,2,3, 4)* 3#迭代 for i in (12, 3,4 , 5): print(i) 将列表转换为元组 123list = [ &apos;z&apos;, 1, 2, 3, 4, &apos;u&apos;]tup = tuple(list)print(tup) 映射和集合字典 字典：将相关信息关联起来 访问字典 12man = &#123;&apos;name&apos;:&apos;zhangyu&apos;, &apos;xingbie&apos;:&apos;man&apos;, &apos;hige&apos;:165&#125;print(man[&apos;name&apos;]) 添加键-值对 12man[&apos;home&apos;] = &apos;xian&apos;man 修改字典中的值 123man = &#123;&apos;name&apos;:&apos;zhangyu&apos;, &apos;xingbie&apos;:&apos;man&apos;, &apos;hige&apos;:165&#125;man[&apos;hige&apos;] = 170man 删除键-值对 123man = &#123;&apos;name&apos;:&apos;zhangyu&apos;, &apos;xingbie&apos;:&apos;man&apos;, &apos;hige&apos;:165&#125;del man[&apos;xingbie&apos;]man 遍历所有的键-值对 1234man = &#123;&apos;name&apos;:&apos;zhangyu&apos;, &apos;home&apos;:&apos;xian&apos;, &apos;hige&apos;:165, &apos;girfriend&apos;:&apos;null&apos;&#125;for key, value in man.items(): print( key,&quot;:&quot; , value) 分别遍历所有的键-值 1234567man = &#123;&apos;name&apos;:&apos;zhangyu&apos;, &apos;home&apos;:&apos;xian&apos;, &apos;hige&apos;:165, &apos;girfriend&apos;:&apos;null&apos;&#125;for key in man.keys(): print( key) for value in man.values(): print(value) 按倒序顺序遍历分别遍历所有的键-值 12for key in sorted(man.keys()): print( key) 字典列表 12345678man = &#123;&apos;name&apos;:&apos;zhangyu&apos;, &apos;home&apos;:&apos;xian&apos;, &apos;hige&apos;:165, &apos;girfriend&apos;:&apos;null&apos;&#125;alien = &#123;&apos;color&apos;:&apos;green&apos;, &apos;points&apos;:5&#125;computer = &#123;&apos;name&apos;:&apos;wangzhou&apos;, &apos;num&apos;: 40&#125;alients = [man, alien, computer]for i in alients: print(i) 在字典中存储列表 12345678910province = &#123; &apos;name&apos;:[&apos;zhangyu&apos;, &apos;han&apos;, &apos;dou&apos;], &apos;home&apos;:[&apos;xian&apos;, &apos;beijing&apos;], &apos;hige&apos;:[165, 170, 370, 2389]&#125;for na, las in province.items(): for la in las: print(na, la) 在字典中存储字典 12345678province = &#123; &apos;man&apos; :&#123;&apos;name&apos;:&apos;zhangyu&apos;, &apos;home&apos;:&apos;xian&apos;, &apos;hige&apos;:165, &apos;girfriend&apos;:&apos;null&apos;&#125;, &apos;alien&apos; : &#123;&apos;color&apos;:&apos;green&apos;, &apos;points&apos;: 5&#125;, &apos;computer&apos; : &#123;&apos;name&apos;:&apos;wangzhou&apos;, &apos;num&apos;: 10&#125;&#125;for i, a in province.items(): print(i, a) 字典键的特性 不允许同一键出现两次，创建时如果同一键被赋值两次， 后一个值会被记住。键必须不可变， 可以用数字，字符串，或元组充当，但不能用列表 12dict = &#123;&apos;name&apos;: &apos;zhang&apos;, &apos;name&apos;:&apos;yu&apos;&#125;dict python中关于字典的函数 1234567891011121314151617181920212223242526272829303132333435# 删除字典内所有元素dict.clear()#返回一个字典的浅复制dict.copy()# 创建字典seq = (&apos;Google&apos;, &apos;Runoob&apos;, &apos;Taobao&apos;)dict = dict.fromkeys(seq,10)dict#返回指定键的值，如果值不在字典中返回设定值dict1.get(&apos;Google&apos;, 40)#和get()类似, 但如果键不存在于字典中，将会添加键并将值设为设定值dict1.setdefault(&apos;google&apos;, &apos;20&apos;)dict1#把字典dict2的键/值对更新到dict里dict1=&#123;&apos;Google&apos;: 10, &apos;Runoob&apos;: 10, &apos;Taobao&apos;: 10&#125;dict2 =&#123;&apos;na&apos;: &apos;zhang&apos;, &apos;name&apos;:&apos;yu&apos;&#125;dict1.update(dict2)dict1#以列表返回可遍历的(键, 值) 元组数组dict.items()#以列表返回一个字典所有的键dict.keys()#以列表返回字典中的所有值dict.values() 集合类型 集合是一个无序的，不重复的数据集合。集合作用有以下两点： 去重： 把一个还有重复元素的列表或元组等数据类型变成集合， 其中的重复元素只出现一次，用set()方法 1234567891011121314#使用大括号之间创建集合f = &#123;1, 2, 2, 2, &apos;a&apos;&#125;print(f)print(type(f))# 用set()方法a = [1, 2, 2, &apos;a&apos;, &apos;a&apos;]b = (1,2,2, &apos;a&apos;, &apos;a&apos;)c = set(a)d = set(b)e = set()print(c)print(d)print(e) 进行关系测试：测试两组数据之间的交集，差集，并集等数据关系 12345678910111213141516171819202122232425262728293031323334# 查看集合的相关函数help(set)a = [1,2,2,&apos;a&apos;,&apos;a&apos;,&apos;d&apos;,&apos;e&apos;]b = [1,2,2,&apos;a&apos;,&apos;a&apos;,&apos;b&apos;,&apos;b&apos;]c = set(a)d = set(b)# 取交集e = c.intersection(d)print(e)# 取并集f = c.union(d)print(f)# 取差集（无重复）g = c.difference(d)print(g)#对称差集&quot;（不同时在c,d中存在）h = c.symmetric_difference(d)print(h)#判读是否为子集i = c.issubset(d)print(i)# &quot;判读是否为超集&quot;j = c.issuperset(d) #检查是否有相同元素,没有返回Truek = c.isdisjoint(d) 条件和循环if语句 if-else语句 12345age = 17if age &gt;= 18: print( &quot;you can seee six video&quot;)else: print(&quot; you should study&quot;) if-elif-else 语句 1234567age = 18if age == 18: print( &quot;you should find girlfriend&quot;)elif age&gt; 18: print(&quot;you can see six video&quot;) else: print(&quot; you should study&quot;) 多个elif 1234567891011age = 80if age == 18: print( &quot;you should find girlfriend&quot;)elif 18&lt;age&lt;30: print(&quot;you can see six video&quot;) elif 30&lt; age &lt; 60: print( &quot;you should go to work&quot;)elif age&gt; 60: print(&quot;you should go to tourism&quot;)else: print(&quot; you should study&quot;) if语句中的and和or 1234567num = 9if num &gt;= 0 and num &lt;= 10: print (&apos;hello&apos;)num = 10if num &lt;= 0 or num &gt;= 10: print(&apos;zy&apos;) while语句 for循环主要用于遍历迭代的对象， while循环主要用于条件判断 1234567891011numbers = [12, 21, 48, 8, 1230, 5, 7]even =[]odd = []while len(numbers) &gt; 0 : number = numbers.pop() if(number % 2 == 0): even.append(number) else: odd.append(number) print(even) continue 用于跳过该次循环 123456789101112numbers = [12, 21, 48, 8, 1230, 5, 7]even =[]odd = []while len(numbers) &gt; 0 : number = numbers.pop() if(number % 2 == 0): even.append(number) else: odd.append(number) continue print(even) break 用于退出循环 12345678910111213numbers = [12, 21, 48, 8, 1230, 5, 7]even =[]odd = []while len(numbers) &gt; 0 : number = numbers.pop() if(number % 2 == 0): even.append(number) else: odd.append(number) continue print(even) break 循环使用 else 语句 123456count = 0while count &lt; 5: print (count, &quot; is less than 5&quot;) count = count + 1else: print (count,&quot; is not less than 5&quot; ) for语句for 循环可以遍历任何序列的项目 12for letter in &apos;python&apos;: print(letter) 函数 函数是组织好， 可重复使用的，用来实现有关功能的代码段。函数能提高应用的模块行，和代码的重复利用率。 定义函数123456def zhangyu(): &quot;&quot;&quot;显示名称&quot;&quot;&quot; print(&quot;zhangandyu&quot;) # return[&apos;a&apos;] zhangyu() 向函数传入参数 1234567def zy(name): print(&apos;Hello, &apos; + name.title() + &apos;!&apos;)zy(&apos;zhangyu&apos;)# name 为形参#&apos;zhangyu&apos;为实参 位置实参 1234567def describe_pet(animal_type, name): print(&apos;I have a &apos; + animal_type) print(&apos;My &apos; + animal_type + &apos;is name is &apos; + name.title() + &apos;.&apos;)describe_pet(&apos;dog&apos;, &apos;huabao&apos;)# 警惕位置混淆describe_pet(&apos;huabao&apos;, &apos;dog&apos;) 关键字实参 123456def describe_pet(animal_type, name): print(&apos;I have a &apos; + animal_type) print(&apos;My &apos; + animal_type + &apos;is name is &apos; + name.title() + &apos;.&apos;)describe_pet(name = &apos;huabao&apos;, animal_type = &apos;dog&apos;)# 位置混淆也没有关系 设置默认值 12345678910def describe_pet(name,animal_type=&apos;dog&apos;): &quot;&quot;&quot;设置animal_type的默认参数是dog&quot;&quot;&quot; print(&apos;I have a &apos; + animal_type) print(&apos;My &apos; + animal_type + &apos;is name is &apos; + name.title() + &apos;.&apos;)# 默认参数不改变describe_pet(name = &apos;huabao&apos;)# 默认参数改变describe_pet(&apos;huxbao&apos;, &apos;cat&apos;) 返回值函数返回的值可以使用return语句将值返回到调用函数的代码行中。从而将程序的大部分繁重工作移到函数中取完成。 12345def zy_name(first_name, last_name): name = first_name + last_name return name.title()zy_name(&apos;zhang&apos;, &apos;yu&apos;) 让实参变成可选的 12345678910def zy_name(first_name, last_name, middle_name =&apos; &apos;): if middle_name: name = first_name +&apos; &apos;+ last_name +&apos; &apos; + middle_name else: name = first_name + &apos; &apos; + last_name return name.title()zy_name(&apos;zhang&apos;, &apos;yu&apos;)zy_name(&apos;zhang&apos;, &apos;and&apos;, &apos;yu&apos;) 返回字典 1234567def build_person(first_name, last_name, age=&apos;&apos;): person = &#123;&apos;first&apos; : first_name, &apos;last&apos;: last_name&#125; if age: person[&apos;age&apos;] = age return personbuild_person(&apos;zhang&apos;, &apos;yu&apos;, age=25) 传递列表 12345def get_user(names): for name in names: print(name.title())zy = [&apos;a&apos;, &apos;b&apos;, &apos;v&apos;]get_user(zy) 传递任意数据的实参 12345def get_world(* names): for i in names: print(i)get_world(&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;) 使用位置实参和任意数量实参 必须将接纳任意数量实参的形参放到最后 1234def get_world(size, *names): for i in names: print(str(size) + i)get_world( 1,&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;) 使用任意数量的关键字实参 1234567def get_user(**user_info): profile = &#123;&#125; for key, value in user_info.items(): profile[key] = value return profileuser_profile = get_user(location = &apos;princeton&apos;, field = &apos;physics&apos;, home = &apos;xian&apos;)print(user_profile) 递归函数如果一个函数在函数内部，调用自己本身，这个函数就是递归函数。 12345def fan(n): if n == 1: return 1 else: return n * fan (n-1) 但递归函数在数特别大的情况下会导致栈溢出， 例如： 1fan(10000) 变量的作用域 局部作用域 1234def func(): name = &quot;zhangyu&quot;print(name) 运行报错， 因为name变量只在func()函数中生效，而在全局无法调用。 作用域链 12345678name = &quot;lzl&quot;def f1(): name = &quot;Eric&quot; def f2(): name = &quot;Snor&quot; print(name) f2()f1() f1()函数执行，最后输出snor，Python中有作用域链， 变量会由内到外找，先去自己作用域找，自己没有再去上级找，直到找不到报错。 终极作用域 1234567891011name = &apos;zhang&apos;def f1(): print(name)def f2(): name = &apos;yu&apos; return f1 ret = f2()ret() 输出结果为zhang, 分析可知， f2()函数执行结果为函数f1的内存地址。执行ret()就是执行f1()，name =’zhang’与fi()在一个作用域链。 12345678910# 新浪面试题li = [lambda : x for x in range(10)]print(type(li))print(type(li[0]))#lambada 面试题 li = [lambda :x for x in range(10)]res = li[0]()print(res) Numpy库 Numpy是科学计算库,特点是有N维数组对象ndarray，是Scipy、Pandas等的基础 array结构 1234567891011121314151617181920212223import numpy as np# 给列表每个元素增加1zy = [1, 2, 3, 4, 5]zy = zy + 1# 错误， 因为列表不支持这样的错误# 用array函数zy = np.array(zy)zy += 1zy# 计算by = np.array([ 2, 3, 4, 5, 6])zy + byzy * byzy ** by# 取值zy[0] zy[2:] 底层为创建ndarray对象，有丰富的可选参数 12345zy.shape # 多维数组的形状type(zy) # 类型zy.dtype # 数组中元素的类型, array内部必须为同一类型， 不同类型会默认进行转换zy.size # 数组中元素个数zy.ndim # 数组的维度 索引 12345678tang_array = np.array([[1, 2, 3], [3, 4, 5], [6, 7, 8]])tang_array[1]tang_array[1, 1]tang_array[:,1]tang_array[1,0:2] 1234567891011tang_array2 = tang_arraytang_array2# 将tang_array2中的4 改为10tang_array2[1,1] = 10tang_array2tang_array# tang_array 中的4也改为了10， 修改tang_array2,实际是指向了tang_array中的内存# 要想修改tang_array2 而不改tang_arra, 需要用copy() 巧用布尔类型 1234567891011121314# 构造等差数组zy = np.arange(0, 100, 10)zy# array([ 0, 10, 20, 30, 40, 50, 60, 70, 80, 90])# 构造布尔类型by = np.array([0, 0, 1, 0, 1, 1, 1, 0, 1, 0], dtype=bool)by# array([False, False, True, False, True, True, True, False, True,False])zy[by]# array([20, 40, 50, 60, 80]) array数组的数值计算 123456789101112131415161718192021222324252627282930313233343536373839404142zy = np.array([[1, 2, 3, 4], [5, 6, 7, 8]])#所有数据求和 np.sum(zy)# 指定要按什么维度进行计算np.sum(zy,axis = 0)np.sum(zy,axis = 1)# 所有数据乘积zy.prod()zy.prod(axis = 0)zy.prod(axis = -1)# 最小最大值zy.min(axis = 0)zy.max()# 最大值的索引zy.argmax()# 均值zy.mean()zy.mean(axis = 0)# 标准差zy.std(axis = 1)# 方差zy.var()# 进行限制， 小于3的值都变成3， 大于7的值都变成7zy.clip(3, 7)# 进行四舍五入zy.round()# 进行四舍五入到第一个小数点zy.round(decimals = 1) 排序 12345678import numpy as nptang_array = np.array([[1.1, 4.3, 5.2 , 5.1], [5.2, 6.4, 2.3, 4.6]])# 排序np.sort(tang_array)np.sort(tang_array, axis = 0) 数组形状操作 123456789101112zy_num = np.arange(10)zy_num# array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])zy_num.shape = 2, 5zy_num# array([[0, 1, 2, 3, 4],[5, 6, 7, 8, 9]])zy_num.reshape(1,10)#array([[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]]) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465# 增加维度zy_num = np.arange(10)zy_num.shape#(10,)zy_num = zy_num[np.newaxis, :]zy_num.shape#(1, 10)zy_num = zy_num[ :, np.newaxis]zy_num.shape#(10, 1)# 压缩维度zy_num = zy_num.squeeze()zy_num#array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])zy_num.shape#(10,)# 转置zy_num.shape = 2,5zy_num#array([[0, 1, 2, 3, 4], [5, 6, 7, 8, 9]])zy_num.transpose() # zy_num.T#array([[0, 5],[1, 6], [2, 7], [3, 8], [4, 9]])# 数组的连接a = np.array([[1,2, 3, 4], [5, 6, 7, 8]])b = np.array([[0, 3, 5, 7], [8, 0, 10, 21]])c = np.concatenate((a, b))c# array([[ 1, 2, 3, 4], [ 5, 6, 7, 8],[ 0, 3, 5, 7], [ 8, 0, 10, 21]])c = np.confatenate((a, b), axis = 1)cnp.vstack((a,b))# array([[ 1, 2, 3, 4],[ 5, 6, 7, 8],[ 0, 3, 5, 7],[ 8, 0, 10, 21]])np.hstack((a,b))# array([[ 1, 2, 3, 4, 0, 3, 5, 7],[ 5, 6, 7, 8, 8, 0, 10, 21]])a# array([[1, 2, 3, 4],[5, 6, 7, 8]])a.flatten()a.ravel()# array([1, 2, 3, 4, 5, 6, 7, 8]) 生成数组 123456789101112131415161718192021222324252627282930np.arange(10)np.arange(2,20,2)# array([ 2, 4, 6, 8, 10, 12, 14, 16, 18])np.arange(2,20,2, dtype= np.float32)# array([ 2., 4., 6., 8., 10., 12., 14., 16., 18.], dtype=float32)# 构造等距数组np.linspace(0, 10, 5)# array([ 0. , 2.5, 5. , 7.5, 10. ])# 构造行向量，列向量np.r_[0:10:1]np.c_[0:10:1]np.zeros(3)# array([0., 0., 0.])np.zeros((3,3))np.ones(3)# array([1., 1., 1.])np.ones((3,3)) * 8zy_num = np.array([1,2,3, 4])np.zeros_like(zy_num)# array([0, 0, 0, 0]) 运算 12345678910111213141516171819202122232425# 乘法x = np.array([5,5])y = np.array([2,3])np.multiply(x,y)# array([10, 15])np.dot(x,y)# array([10, 15])x = np.array([1, 1, 1])y = np.array([[1, 2, 3],[4, 5, 6]])print(x * y)#[[1 2 3] [4 5 6]]x = np.array([1, 1, 2])y = np.array([1, 1, 1])x == y# array([ True, True, False])np.logical_and(x,y)np.logical_or(x,y)np.logical_not(x,y) 随机模块 123456789101112131415161718192021222324252627282930# 随机浮点数np.random.rand(3,2)# 随机整数np.random.randint(10, size = (2,4))# array([[4, 6, 7, 8], [7, 6, 2, 3]])# 随机数np.random.rand()np.random.random_sample()# 0-10中随机找三个数np.random.randint(0, 10, 3)# array([8, 6, 9])# 随机高斯分布mu, sigma = 0, 0.2np.random.normal(mu, sigma, 5)# 设置数字精度, 输出数精度为小数点后3位np.set_printoptions(precision = 3 )# 洗牌， 打乱排列顺序zy_num = np.arange(15)zy_num# array([ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14])np.random.shuffle(zy_num)zy_num# array([ 1, 5, 4, 11, 14, 9, 8, 6, 7, 3, 0, 2, 10, 12, 13]) 读取写入文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263# 写一个名为tang的txt文件%%writefile tang.txt1 2 3 4 5 6 2 3 4 5 5 7# 读取tang文件data = np.loadtxt(&apos;tang.txt&apos;)data# array([[1., 2., 3., 4., 5., 6.],[2., 3., 4., 5., 5., 7.]])%%writefile tang.txt1, 2, 3, 4, 5, 6 2, 3, 4, 5, 5, 7data = np.loadtxt(&apos;tang.txt&apos;, delimiter = &apos;,&apos;)%%writefile tang.txta, b, c, d, e, f1, 2, 3, 4, 5, 6 2, 3, 4, 5, 5, 7# 不读取第一行data = np.loadtxt(&apos;tang.txt&apos;, delimiter = &apos;,&apos;, skiprows =1)# 指定使用哪几列data = np.loadtxt(&apos;tang.txt&apos;, delimiter = &apos;,&apos;, skiprows =1, usecols = (0,1, 4))# 写入数组文件zy_num = np.array([[1, 2, 3], [4, 5, 6]])np.savetxt(&apos;tang.txt&apos;, zy_num)# 保存成指定格式np.savetxt(&apos;tang.txt&apos;, zy_num, fmt= &apos;%d&apos;)np.savetxt(&apos;tang.txt&apos;, zy_num, fmt= &apos;%.2f&apos;)# 指定分隔符np.savetxt(&apos;tang.txt&apos;, zy_num, fmt= &apos;%d&apos;, delimiter = &apos;,&apos;)# 读写文件zy_num = np.array([[1, 2, 3], [4, 5, 6]])np.save(&apos;zy_num.npy&apos;, zy_num)zy_num = np.load(&apos;zy_num.npy&apos;)# 将两个文件保存在同一文件夹，并进行读写zy_num2 = np.arange(10)np.savez(&apos;zy_npz&apos;, a = zy_num, b = zy_num2)data = np.load(&apos;zy.npz&apos;)data.keys()# [&apos;a&apos;, &apos;b&apos;]data[&apos;a&apos;]# array([[1, 2, 3],[4, 5, 6]])]]></content>
      <categories>
        <category>数据分析技能</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python爬虫]]></title>
    <url>%2F2018%2F07%2F12%2F%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E6%8A%80%E8%83%BD-Python%E7%88%AC%E8%99%AB%2F</url>
    <content type="text"><![CDATA[爬取英雄联盟-英雄皮肤图片1. 前言最近自己在学爬虫， 有天朋友问我能否爬取英雄联盟的皮肤图片到本地，好实现快速浏览，折腾了半个小时，终于成功了。 2. 过程分析过程找到皮肤图片链接， 研究规律在抓取图片之前，我们需要分析网址链接的构成， 以便找到其中的规律。 打开英雄联盟网站, 点击其中的一个英雄， 我们可以看到一个英雄有1-6个皮肤甚至更多，且我们很容易从每个皮肤链接中找到规律。 123456789# 英雄1http://ossweb-img.qq.com/images/lol/web201310/skin/small266000.jpghttp://ossweb-img.qq.com/images/lol/web201310/skin/small266001.jpghttp://ossweb-img.qq.com/images/lol/web201310/skin/small266002.jpg# 英雄2http://ossweb-img.qq.com/images/lol/web201310/skin/small103000.jpghttp://ossweb-img.qq.com/images/lol/web201310/skin/small103001.jpghttp://ossweb-img.qq.com/images/lol/web201310/skin/small103002.jp 从以上的链接中，我们可以知道英雄皮肤的链接规律为：1&quot;http://ossweb-img.qq.com/images/lol/web201310/skin/small&quot; + &quot;英雄代号&quot; + &quot;0&quot; + &quot;01-10&quot; 找到每个英雄对应的数字代号那么我们需要解决的问题就变成了到每个英雄对应的代号是多少？ 通过搜索，我们发现每个英雄对应的代号存在champion.js文件中 从Headers中， 我们可以看到champion.js 对应的url为：1http://lol.qq.com/biz/hero/champion.js 我们通过正则表达式， 把js中对应的英雄代号提取出来。 通过以上把链接拼凑起来，我们就可以把链接对应的图片皮肤下载到本地了。 3. 代码1234567891011121314151617181920212223242526272829import requestsimport reimport jsonimport urlliburl = &quot;http://lol.qq.com/biz/hero/champion.js&quot;hd =&#123;&apos;User-Agent&apos;:&quot;Mozilla/5.0 (Windows NT 6.1) AppleWebKit/535.1 (KHTML, like Gecko) Chrome/14.0.802.30 Safari/535.1 SE 2.X MetaSr 1.0&quot;&#125;data = requests.get(url,headers = hd).contentdatas = data.decode()pat = &apos;&quot;keys&quot;:(.*?),&quot;data&quot;&apos;imglist = re.findall(pat,datas)datass = json.loads(imglist[0])for i in datass: try: for j in range(12): try: num = str(j) # print(num) if len(num) == 1: hero_num = &quot;00&quot; + num elif len(num) ==2: hero_num = &quot;0&quot; + num numstr = i + hero_num urls = &apos;http://ossweb-img.qq.com/images/lol/web201310/skin/big&apos;+ numstr +&apos;.jpg&apos; localfile = &quot;E:/张宇个人文件/英雄联盟/&quot; + str(i) + str(num) + &quot;.jpg&quot; urllib.request.urlretrieve(urls, filename = localfile) except Exception as err: pass except Exception as err: pass 爬取王者荣耀-英雄图片代码12345678910111213141516171819202122232425262728# 用python爬取王者荣耀皮肤import requestsimport reimport urlliburl = &quot;http://pvp.qq.com/web201605/herolist.shtml&quot;hd =&#123;&apos;User-Agent&apos;:&quot;Mozilla/5.0 (Windows NT 6.1) AppleWebKit/535.1 (KHTML, like Gecko) Chrome/14.0.802.30 Safari/535.1 SE 2.X MetaSr 1.0&quot;&#125;data = requests.get(url,headers = hd)pat = &apos;a href=&quot;herodetail/(.*?).shtml&apos;imglist = re.compile(pat, re.S).findall(data.text)for i in imglist: # print(i) try: for j in [1,2,3,4,5,6]: try: numstr = str(i)+&apos;/&apos; +str(i)+&apos;-mobileskin-&apos;+ str(j) # print(numstr) urls = &apos;https://game.gtimg.cn/images/yxzj/img201606/heroimg/&apos;+numstr+&apos;.jpg&apos; print(urls) localfile = &quot;E:/张宇个人文件/官网图片/&quot; + str(i)+ str(j)+ &quot;.jpg&quot; urllib.request.urlretrieve(urls, filename = localfile) except Exception as err: pass except Exception as err: pass 爬取网站美女图片代码构建用户代理池1234567891011121314# 这里可以随意加多个浏览器uapools = [ &quot;Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; WOW64; Trident/5.0)&quot;, &quot;Mozilla/5.0 (compatible; MSIE 10.0; Windows NT 6.2; WOW64; Trident/6.0)&quot;, &quot;Mozilla/5.0 (Windows NT 6.3; Trident/7.0; rv:11.0) like Gecko&quot;, &quot;Mozilla/5.0 (compatible; MSIE 10.0; Windows Phone 8.0; Trident/6.0; IEMobile/10.0; ARM; Touch; NOKIA; Lumia 920)&quot;, &quot;Mozilla/5.0 (Windows NT 6.1; WOW64; rv:6.0.2) Gecko/20100101 Firefox/6.0.2&quot;, &quot;Opera/9.80 (Windows NT 6.1; WOW64) Presto/2.12.388 Version/12.12&quot;, &quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/28.0 Safari/537.36 OPR/15.0&quot;, &quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.17 (KHTML, like Gecko) Chrome/24.0.1312.57 Safari/537.17&quot;, &quot;Mozilla/5.0 (X11; CrOS armv7l 3428.193.0) AppleWebKit/537.22 (KHTML, like Gecko) Chrome/25.0.1364.126 Safari/537.22&quot;, &quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/534.57.2 (KHTML, like Gecko) Version/5.1.7 Safari/534.57.2&quot;, &quot;Mozilla/5.0 (Windows; U; Windows NT 5.1; zh-CN) AppleWebKit/533.9 (KHTML, like Gecko) Maxthon/3.0 Safari/533.9&quot;,] 爬取并下载图片12345678910111213141516171819202122232425import reimport requestsimport urllib.request# uapools 如上所示for ua in uapools: hd =&#123;&apos;User-Agent&apos;:ua&#125; i = uapools.index(ua) # 限制爬取页数， 我们爬取前10页 if i &gt; 10: break try: url = &quot;http://www.iyuanqi.com/home/funimg/fun_list/m/Home/cp_uid/all/sort/30hot/p/&quot;+str(i)+&quot;.html&quot; data = requests.get(url, headers = hd) pat = &apos;class=&quot;lazy-img&quot; src=&quot;(.*?)&quot; data-original=&quot;&apos; imglist = re.compile(pat, re.S).findall(data.text) for j in range(0, len(imglist)): try: thisimg = imglist[j] thisimgurl = thisimg localfile = &quot;E:/张宇个人文件/网络图片/&quot; + str(i) + str(j) + &quot;.jpg&quot; urllib.request.urlretrieve(thisimgurl, filename = localfile) except Exception as err: pass except Exception as err: pass 爬取天善课程数据表存储到MYSQL前言天善智能是一个商业智能与大数据在线社区，有很多很好的学习课程。我们用爬虫来爬取网站的所有课程并存储到MYSQL数据库中， 以便于进一步的分析。 用python在MYSQL中创建名为zhanhyu的数据库 用python连接MYSQL数据库 1234567import pymysql# 因为本地mysql没有设置密码， 所以没有加password参数db = pymysql.connect(host = &apos;localhost&apos;, user = &apos;root&apos;, port = 3306)# 用cursor()方法获取MYSQL的操作游标， 利用游标来执行SQL语句cursor = db.cursor() 创建一个新的数据库， 名字叫做zhangyu 12# cursor.execute 执行真正的sql语句, DEFAULT 指定默认值cursor.execute(&quot;CREATE DATABASE zhangyu DEFAULT CHARACTER SET utf8&quot;) 在zhangyu库中创建tianshan2_datas的数据表 指定在zhangyu这个数据库中运行 12db = pymysql.connect(host = &apos;localhost&apos;, user = &apos;root&apos;, port = 3306, db=&apos;zhangyu&apos;)cursor = db.cursor() 用sql语句创建名为tianshan2_datas的表 12345sql = &apos;CREATE TABLE IF NOT EXISTS tianshan2_datas (name VARCHAR(255) NOT NULL, pirce VARCHAR(255) NOT NULL,numbers VARCHAR(255), PRIMARY KEY (name))&apos;curosr.exectute(sql)db.close() 爬取天善智能网站的数据12345678910111213141516171819202122232425262728import reimport requestsfor i in range(1,5): # 观察天善课程链接， 找出规律 thisurl = &quot;https://edu.hellobi.com/course/&quot; + str(i+1) # 用requests库抓取数据 hd =&#123;&quot;user-agent&quot;: &quot;Mozilla/5.0 AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.87 Mobile Safari/537.36&quot;&#125; data = requests.get(thisurl, headers = hd) #用正则表达式进行解析 title_pat = &apos;&lt;li class=&quot;active&quot;&gt;(.*?)&lt;/li&gt;&apos; price_pat = &apos;class=&quot;price-expense&quot;&gt;&lt;sub&gt;￥&lt;/sub&gt;(.*?)&lt;/span&gt;&apos; numb_pat = &apos;class=&quot;course-view&quot;&gt;(.*?)&lt;/span&gt;&apos; title = re.compile(title_pat, re.S).findall(data.text) if(len(title)&gt;0): title = title[0] else: continue price = re.compile(price_pat, re.S).findall(data.text) if(len(price)&gt;0): price = price[0] else: price = &apos;免费&apos; numb = re.compile(numb_pat, re.S).findall(data.text) if(len(numb)&gt;0): numb = numb[0] else: numb = &apos;缺失&apos; 将爬取的数据存储到名为zhangyu数据库的tianshan2_datas表中1234567891011con = pymysql.connect(host = &apos;localhost&apos;, user = &apos;root&apos;, port = 3306, db = &apos;zhangyu&apos;)cursor = con.cursor()sql = &apos;insert into tianshan2_datas(name, pirce, numbers) values(%s,%s,%s)&apos;try: cursor.execute(sql, (title, price, numb)) con.commit()except: con.rollback()con.close() 这样，我们就成功的把爬取的数据保存到mysql数据库中，方便我们查询使用。 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import pymysql# 因为本地mysql没有设置密码， 所以没有加password参数db = pymysql.connect(host = &apos;localhost&apos;, user = &apos;root&apos;, port = 3306)# 用cursor()方法获取MYSQL的操作游标， 利用游标来执行SQL语句cursor = db.cursor()# cursor.execute 执行真正的sql语句, DEFAULT 指定默认值cursor.execute(&quot;CREATE DATABASE zhangyu DEFAULT CHARACTER SET utf8&quot;)db = pymysql.connect(host = &apos;localhost&apos;, user = &apos;root&apos;, port = 3306, db=&apos;zhangyu&apos;)cursor = db.cursor()sql = &apos;CREATE TABLE IF NOT EXISTS tianshan2_datas (name VARCHAR(255) NOT NULL, pirce VARCHAR(255) NOT NULL,numbers VARCHAR(255), PRIMARY KEY (name))&apos;cursor.execute(sql)db.close()import reimport pymysqlimport requestsfor i in range(0,284): thisurl = &quot;https://edu.hellobi.com/course/&quot; + str(i+1) hd =&#123;&quot;user-agent&quot;: &quot;Mozilla/5.0 AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.87 Mobile Safari/537.36&quot;&#125; data = requests.get(thisurl, headers = hd) title_pat = &apos;&lt;li class=&quot;active&quot;&gt;(.*?)&lt;/li&gt;&apos; price_pat = &apos;class=&quot;price-expense&quot;&gt;&lt;sub&gt;￥&lt;/sub&gt;(.*?)&lt;/span&gt;&apos; numb_pat = &apos;class=&quot;course-view&quot;&gt;(.*?)&lt;/span&gt;&apos; title = re.compile(title_pat, re.S).findall(data.text) if(len(title)&gt;0): title = title[0] else: continue price = re.compile(price_pat, re.S).findall(data.text) if(len(price)&gt;0): price = price[0] else: price = &apos;免费&apos; numb = re.compile(numb_pat, re.S).findall(data.text) if(len(numb)&gt;0): numb = numb[0] else: numb = &apos;缺失&apos; con = pymysql.connect(host = &apos;localhost&apos;, user = &apos;root&apos;, port = 3306, db = &apos;zhangyu&apos;) cursor = con.cursor() sql = &apos;insert into tianshan2_datas(name, pirce, numbers) values(%s,%s,%s)&apos; try: cursor.execute(sql, (title, price, numb)) con.commit() except: con.rollback() con.close()]]></content>
      <categories>
        <category>数据分析技能</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[双拼输入法]]></title>
    <url>%2F2017%2F09%2F17%2F%E7%94%9F%E6%B4%BB%E8%B5%84%E6%96%99-%E5%8F%8C%E6%8B%BC%E8%BE%93%E5%85%A5%E6%B3%95%2F</url>
    <content type="text"><![CDATA[1. 怎么接触到双拼的？自己第一次接触双拼，是看到李笑来老师的《把时间当朋友》第二章中的“盲打究竟是否值得学会”,里面提到了盲打与双拼帮助他快速进行记录笔记和文字。 于是自己就试着在网上找双拼的学习方法。 2. 什么是双拼？ 维基百科：双拼是汉语拼音输入法的一种编码方案。相对于全拼而言，使用双拼输入汉字时只需输入一个代表声母的字母，一个代表韵母的字母，就可以打出任意一个中文单字了。 理解起来也很简单，比如你要拼写 张 红 这两个字， 用全拼的话可能你得输入 zhang hong， 而用小鹤双拼的话， 你只需要输入vh hs 就可以显示。 v 代表zh , h 代表ang , s代表ong 双拼的语法也有很多种，比如小鹤双拼、自然码双拼、紫光拼音双拼、搜狗拼音双拼、微软拼音双拼、智能ABC双拼。 每种双拼对应的语法也都不一样。 自己学习的是小鹤双拼，语法图是这样的： 在搜狗输入法上点击 设置—— 属性设置 —— 常用 —— 特殊习惯—— 双拼 就可以使用了。 3. 学习的过程刚开始学习小鹤双拼的时候， 自己是完全不习惯的， 因为想要使用小鹤双拼进行文字输入，就得记住每个字母对应的韵母， 自己每输入一个字， 就得想一下这个字的韵母是什么， 对应到按键上的那个字母又是什么。 再去输入，说实话当时输入字的效率低下到令人发指，而且往往记不住，自己只好打印了一张语法表贴在自己的电脑旁， 忘了就在表上找。 好几次忍不住偷偷换成了全拼， 特别是在工作着急的情况下。 就这样别别扭扭用了一周之后， 才发现自己已经能够慢慢不看语法表了。 （这让我都有点怀疑自己的智商，因为网上说基本一周就可以很熟练了）一个月过后自己才做到了输入基本不卡壳，但如果旁边有人一紧张还是会忘掉如何输入了。 现在用了一年多， 自己已经能够无意识的使用双拼了。 如果你现在问我键盘上的字母在双拼中代表哪个韵母，自己可能真的答不上来，但只要自己在键盘上打字，自己就能够无意识的打出来。 4. 学习双拼的优点与缺点( 1 ). 优点 简洁，同样一个词全拼要五六下，双拼只需要两下 感觉节省了时间，更喜欢在键盘上敲字了。 （至于是否真正节省了时间，自己没有做过对比） ( 2 ). 缺点 全拼不会用了， 有时在别人的电脑上输入文字总是很别扭，老出错，总想着把输入法改成双拼 有时大脑短路会想不起来双拼的语法 5. 感悟 任何学习都是不可逆的，当你学了到了一项技能，你就不可能再像从前没学过一样生活。 最可怕的不是自己知道自己不知道，而是不知道自己不知道。 比如自己学习双拼，自己以前根本不知道还有双拼这么一种输入法，就更不会产生要学习这种输入法的冲动。 如何解决自己不知道自己不知道的知识，自己目前能够想到的方法是：多读书，多关注大牛，多了解别人是怎么工作、生活。 有些东西只有自己亲身经历过后才能有所体会，哪怕是坏的体验。 如果只是看别人推荐而不去坚持使用双拼， 我就不能体会到大脑下意识使用双拼输入的快感。当然，也许会出现这种情况， 你付出了时间，付出了精力，而这项技能对你的生活影响并不大。这就需要你前期做一些搜索调查。 延伸到生活上，要是我不来北京生活，不来北京工作，我就没有机会知道来北京到底会面临什么困难，到底对自己的职业发展是否有益。也许最后自己会失败，可那又怎么样，自己的人生自己做主。 学会一项技能，不是只是了解它，而是能够在生活中无意识的使用它 一项技能，只是了解是远远不够的， 你要去不断的磨练，打磨，直到它成为你大脑的一部分。 学会的标准就是：你能否不需要专门思考就能够调用它。 要学习那些你通过短时间学会,就能够一辈子用的上的知识。 6. 延伸 总是听很多的牛人说，写作是非常重要的一项技能，对一个人清晰思考问题是非常有帮助的，然而自己却迟迟没有行动，主要还是觉得自己语言词汇匮乏， 缺乏独立思考，怕自己语无伦次。 其实又想想，写作这东西这就和自己刚开始学习双拼时一样，开始你觉得自己没有可能学会，也许过一段时间你就能够发现自己的进步， 你不去坚持写又怎么能够证明自己一定学不会呢？ 自己认为学习是一个自我验证的过程：你认为自己不可能学会，你就不会坚持去学；你不坚持去学，你就不会有进步， 从而你就不会看到到自己能够学会的结果，也就证明了自己确实学不会。相反， 你认为自己能学会，你就坚持去学，看到自己的进步，最终的确学会了，也证明了自己确实能够学会。 7. 未解决问题 如何运用心智的力量在还没有机会亲身体验的情况下，仅凭心智就可以像真实经历过一样深刻体会？ 如何解决 害怕自己付出了时间，付出了精力，而没有一个好的结果 参考资料： 《把时间当朋友》]]></content>
      <categories>
        <category>生活资料</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
</search>
