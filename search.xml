<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[数据异常分析方法]]></title>
    <url>%2F2019%2F08%2F03%2F%E6%96%B9%E6%B3%95-%E6%95%B0%E6%8D%AE%E5%BC%82%E5%B8%B8%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[如何针对异常数据进行分析作为一名数据分析师， 在工作中我们经常要对异常数据进行原因分析， 那么异常排查的方法都有哪些， 今天我们就来谈一谈。 首先，在进行分析前，我们需要做到以下几点： 对此数据的业务理解是否准确。 比如：APP的日活是如何定义的， 是用户只要启动APP，还是用户必须在APP中有点击行为。 数据的指标口径是否统一。 比如：某活动页面的 uv，是通过统计用户的手机号，还是统计用户 tracking_id 。不同的统计口径会导致数据出现差异。 数据的产出过程是否明确。 比如：数据是如何从日志中进行清洗，是否会存在多发或漏发数据情况。 寻找相关运营或产品人员进行沟通。询问运营人员关于此数据异常的见解，往往能够提高我们的分析效率。 接下来就是对异常原因的排查，常见的影响因素和方法有： 外部因素：时间因素、节假日活动、热点事件、政策影响等。 内部因素： 部门运营活动、产品功能上线、大盘整体趋势、页面性能、SQL逻辑错误、数据指标口径调整等。 多维度拆解法。从各个维度进行细分拆解，定位问题。比如：某产品活跃用户下降，那我们可以把活跃用户拆分成新用户、老用户、回流用户，然后针对不同的用户再进行细拆分析。 在查找出异常原因之后，我们还需要做到以下两点： 持续跟踪后续数据是否再次异常。在排查出原因并采取相应措施之后，我们需要持续跟踪数据，如果数据再次异常，那么说明给出的异常原因可能是错误的。 对异常原因进行梳理，文档化。 问题描述：什么时间、什么指标异常、异常幅度 主要结论：异常因素有哪些，各自的影响程度如何 后续跟进：后续的解决方案是什么，解决时间，再次验证是否异常。 具体分析过程：分析过程与详细分析数据 以上就是自己总结的数据异常原因分析，你还有哪些好用的分析方法，欢迎留言交流。 参考资料： 数据异常求生指南数据分析之数据异常分析日思619.数据异常了，如何分析？ 工作中存在的分析问题本周 话费账单组kpi考核同比突降67万， 领导让我分析数据异常的原因。 在分析的过程中，自己主要犯了三个错误： 自己一开始就对所有统计的按钮进行细拆， 而没有分功能模块进行细拆， 导致自己一开始只是看到 话费余额页面 和月账单页面下降， 而没有找到电子发票页面下降。 如果自己在细拆的对比中细心的话，自己也是可以找到的， 但是自己没有耐心做对比。 如果自己按照功能模块进行细拆对比， 就不会出现这样的情况。 自己从一开始就没有搭建出一个整体的分析体系， 导致自己分析时，一会跑这个数据， 一会跑那个数据，从而使自己得出的结论没有说服力。比如： 一开始，自己就跑话费余额数据， 但是跑着跑着发现口径有问题， 自己之前得出的结论竟然是错误的， 自己是先有了结论， 然后自己再找数据的， 这样会让自己再推翻自己的结论， 重新跑数据，特别的浪费时间。 数据的准确性不能保证， 自己跑的数据， 存在着比较明显的不合理之处， 口径不够明确， 给别人解释口径时不能够解释清楚。 如何分析业务数据问题陈述、产生假设、收集数据、分析数据、获取结论、采取行动 评估和定位问题 在深入研究任何类型的数据之前，应该快速找到你需要解决的真正问题，并用最简单的话定义它 如果无法用简单的语言解释你要解决的业务问题，那么任何数据分析都无法解决问题。 快速评估和定位问题的三问： 这是否是系统异常导致的问题？ 下载量下跌，但激活量没有，也许是下载数据没有埋点或埋点错误？ 这是更大问题的预兆吗？ 注册号码的下降是网站故障的指示吗？ 你在看一个重要的度量指标吗？ 如果网站的转化率下降，但原始注册量没有下降， 那么就从一个紧急事件变成了一个谜团待揭开 确定潜在原因 经验检索，快速寻找原因根据经验，寻找任何明显的可能原因或问题的答案, 当你检查显示问题的来源或报告后，是否有任何异常原因立即浮现在脑海中？ 例如，你的电子商务网站的ssl认证可能过期，导致浏览器弹窗窗口警告数据不安全，从而显著降低购物车转化率 询问相关人员原因这个问题会影响和涉及其他团队吗？如果是这样，他们是否对可能的原因有任何了解？即使问题与其他团队之间没有明显的联系，也有必要咨询一下。 营销经理可能会问客户支持： 我注意到注册数据下降了，你能否想一想过去几周你发现过什么相关的变化吗？ 创建假设一个假设知识一个尚未得到证实的有根据的猜测。 在分析数据之前，清楚地说明问题的几个可能原因非常重要，这有助于防止常见的数据分析误区。 导致注册量突然下降的假设： 某些地区的公众假期 最近对营销网站的更改 星期一网站中断导致注册过程中出现错误 转换率下降减少了注册量 产品页面在某搜索排名下降到搜索结果的第二页 技术思维的方法——科学假设需具备的条件： 涉及一个自变量和一个因变量 它是可测试的 它是可证伪的 有时查看数据可能会产生一个新的假设，需要再次测试。最终，我们的假设会在下一步通过数据分析得到证实或反驳。 分析数据 分割并确定相关数据指标根据你的假设，你需要查看哪些数据？哪些指标可以帮助你证明或者反驳假设？ 你可以按国家/地区， 渠道和网络会话持续时间细分注册次数，以测试你的假设 注意你的数据基于你已知的业务指标，你可以判断数据是否出现异常？如果无基准线，请用历史数据作为起点。 app注册量同比下降20% 评估异常或趋势的影响经过前两个步骤，你要查看发现的趋势/异常是否足以解释问题 在寻找数据中的异常或趋势时，要注意这些异常或趋势不仅要具有统计意义，也要具有实际意义。我们需要弄清楚是什么会对我们发现的问题产生实际影响。 统计显著性检验用于确定你注意到的异常是由于抽样误差还是适用于所有对象。 在上篇我们说到了如何对数据异常进行分析，这次我们来一道具体的数据分析面试问题。 以下是一家公司APP一周每天的活跃率，如何你是分析师： 从数据中你看到了什么问题？你觉得背后的原因是什么？ 如果你的老板要求你提一个运营运营改进计划，你会怎么做？ 分析答案： 数据质量数据采集， 数据接口， 数据存储 产品质量版本更新， 版本BUG 渠道质量渠道买量造假 活动质量是否有重大活动 政策问题 –&gt; 数据异常排查清楚以下三点： 业务理解 指标口径 当前数据产出过程 数据异常原因分析： 数据有问题 将时间轴拉长，看数据是近期异常还是历史异常，对比近三个月数据。 查看和该指标关联的其他核心指标是否也异常，如果异常，也要一并查看。 核查埋点是否有问题， 数据是否存在多发情况。 业务口径是否有问题， 取的数据是不是真正需要的数据。 写的sql逻辑是否有误， 或者android 和 ios 数据没有相加。 业务发生了变化 同口径下，同比环比数据是否异常， 在长时间轴的条件下进行对比 进行细拆， 看到底是哪个指标的数据出现了异常， 将该指标和相关的指标一起进行对比 与负责此指标的负责人进行沟通， 询问他们近期是否做了推广活动。 产品最近是否发布了新版本，或者某个功能改版存在缺陷问题。 其他因素影响 假期效应： 开学季， 暑期， 四大节日，当地节日 热点事件：常规热点如运动会，世界杯，其他热点事件 活动影响： 双11， 618， 支付宝送红包 政策影响： 金融监管 底层系统故障： 服务器迁移导致数据丢失 存在外部刷量作弊情况 统计口径： 业务逻辑进行了更改， 之前某业务有统计， 但现在不统计了。 数据计算方式改变 要对异常排查进行闭环 持续跟踪后期数据是否再次异常比如7.0版本数据存在多发现象， 但7.1版本开发说已更改， 当7.1版本发布之后， 要及时去查看数据是否再次异常。 对数据异常一定要记录， 对异常口径要留文档。 邮件化， 当数据异常排查原因查明， 并且确认更改之后， 发邮件给相关方， 描述数据异常的影响范围和主要结论。 作为一名数据分析师， 一定要经常去看这三种报表，培养自己的数据敏感度，了解业务的各种核心指标。]]></content>
      <categories>
        <category>数据分析方法</category>
      </categories>
      <tags>
        <tag>数据分析</tag>
        <tag>异常分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用环境来辅助自己进步]]></title>
    <url>%2F2019%2F08%2F02%2F%E7%94%9F%E6%B4%BB-%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93-%E5%88%A9%E7%94%A8%E7%8E%AF%E5%A2%83%E6%9D%A5%E8%BE%85%E5%8A%A9%E8%87%AA%E5%B7%B1%E7%9A%84%E8%BF%9B%E6%AD%A5%2F</url>
    <content type="text"><![CDATA[自己下班或者周末在房间，总是把大量的时间用来刷微博或者刷剧。虽然一直刷一直爽，但自己总是有一种虚度时间的空虚感，如何改变自己下班和周末的状态，成了自己最近在思考的问题。 最近在学习陈海贤的《自我发展心理学》，刚好说到了自己的这种现象，并给出了一种利用环境来促使改变的方法，对自己启发很大，今天就来介绍一下这种方法。 首先是融入到积极的环境中去。要想学习就去图书馆、自习室，要想锻炼就去体育场、健身房。我们心中其实都有一个关于“特定空间”的假设，在假设中，对于公司、图书馆这样的空间就是用来工作学习，对于自己寝室的假设肯定是用来休息娱乐的。如果你要让自己在宿舍这样的空间中好好学习工作，就得付出比在图书馆多几倍的努力才行，还不一定能学进去。所以，周末能去图书馆上自习就绝不在家办公， 让自己融入到特定的环境中去。 当然，如果要学习就要去图书馆，那也不现实。如何在自己的房间中也能被环境所带动呢，文中介绍了第二种方法，那就是在某个特定的环境中只做一件事情。 比如：你可以要求自己在这张书桌上只作跟工作学习有关的事情， 如果想刷微博，看电视，那就换个地方，可以坐沙发上。 背后其实也是利用了我们心中对“特定空间”的假设，如果你在这个书桌上进行娱乐活动，那么这个书桌作为你心中假设的环境就会破坏掉。平常在一个特定的空间里只做这一件事情， 慢慢这个习惯会形成稳定的心理预期，会给自己一种强烈的心理暗示，从而帮助自己进行改变。 这促使了我对之前行为的理解，当自己上完班回家之后，本身意志力就消磨的七七八八了，再要用所剩无几的意志力抵抗娱乐去学习，自己的大脑肯定不干。周末在房子里大脑肯定也是怎么舒服怎么来。 我自己针对性的采取了以下几种方法： 最近下班回家之后，先休息一个小时左右，恢复一下意志力，再起来学习工作，感觉效率到提升了不少。 指定特定的桌子只用来办公和学习， 如果自己想刷微博或者刷剧， 不要在这张桌子上进行。 （还在努力实践中） 周末能去石景山图书馆就尽量不要在房子呆着。 以上就是自己最近关于如何促进改变的一些小方法，你还有哪些好用的方法，欢迎留言交流。]]></content>
      <categories>
        <category>个人系统</category>
      </categories>
      <tags>
        <tag>心理</tag>
        <tag>方法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何用数据说话]]></title>
    <url>%2F2019%2F07%2F29%2F%E6%96%B9%E6%B3%95-%E5%A6%82%E4%BD%95%E7%94%A8%E6%95%B0%E6%8D%AE%E8%AF%B4%E8%AF%9D%2F</url>
    <content type="text"><![CDATA[如何用数据说话背景-冲突-疑问-回答 作为一名数据分析师， 经常要写很多的运营分析报告， 但我发现自己写完的分析报告交给领导看， 总是被领导指正说报告的说服力不够。经过这一段时间的磨练， 我也思考了如何才能增加报告的说服力。 一份运营分析报告， 看似简单，描述自己通过数据观察到的现象， 暴露公司运营中存在的问题， 但你揭露公司的问题， 同时也对相应的运营人员的结果的拷问， 人家肯定会质疑你报告的准确性， 如何才能让别人心服口服呢， 在最近的工作中，我总结出以下三点： 要用数据说话。 能用数据说明的，绝对不要用莫能两可的语言。 比如：本周活跃用户数比上周好。 这样的语言让人感觉很空洞， 就不如写成本周活跃用户较上周增长了20万用户， 增长表现良好。 要给出一个结论， 一定要有数据的支撑才行。 对复杂的数据口径进行说明。 不要以为运营人员能够能够很容易理解你的统计指标与口径， 要把他们当小白一样去对待才行。比如留存率是如何计算的， 有时你不必特意的去强调， 但是必要的标注还是得有。免得运营人员多次询问。 对数据进行多维比较，佐证结论。 有时你通过一个维度的数据比较很难将问题说明清楚，需要多维比较。 比如， 本周用户环比上周下降了20%， 那么这能说明本周比上周运营的差吗， 会不会存在月初月末周期的影响。如果要排除这些因素的话， 其实还需要求上月同时间段的环比数据。 如果上月同时间段用户比上周只下降了5%， 那证明可能不是时间的原因。 对于别人给出的原因你也需要数据验证。 有时我们发现某个数据下降，然后去问运营的负责人情况， 在他说完情况之后， 我们应该再根据他的情况进行数据验证， 而不是轻信别人，直接将这个原因写到报告中去。 报告要有结论和建议。 一份分析报告中， 最难的部分就是分析的结论和建议， 很多时候，我们只是简单的描述统计，而要做到逻辑和建议， 其实是一件很难的事情。 报告的内容和布局要有逻辑性。 首先，对于分析的内容， 要保证逻辑正确，避免给出引导运营错误的结论。 比如：一个用户的行为路径分析， 必须保证一个路径下转化率必须是同一个口径。 而不能与第二个目的进行对比。避免引导运营错误。 其次，报告的整体排版必须遵循一定的逻辑， 不能说用户行为，突然就跳到用户充值了。 最后， 把自己写好的分析报告给领导看下， 有时他们的建议能够弥补我们在思维视角上的缺陷， 更快的提高我们的分析撰写能力。 当然， 以上步骤只是我工作中的一点总结，仅供参考。每个公司，每个团队不一样， 要求的分析报告的侧重点不一样，但我们撰写分析报告的目的都是一样的：希望能够指出部门运营中的不足，说服运营人员进行迭代改进。 你还有哪些能够增加分析报告说服力的技巧， 欢迎一起分享交流。]]></content>
      <categories>
        <category>数据分析方法</category>
      </categories>
      <tags>
        <tag>数据分析</tag>
        <tag>报告</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[改版分析]]></title>
    <url>%2F2019%2F06%2F22%2F%E6%96%B9%E6%B3%95-%E6%94%B9%E7%89%88%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[频道改版分析1.分析目的 新频道的效果怎么样？ 2.分析方向 新频道整体改版效果分析。 新频道各部分细拆分析新频道各主要区域细拆，看各区域数据是上升还是下降。 新频道重点问题分析主要功能点流量入口修改后，流量如何分布。 3. 分析思路3.1 新版本整体改版效果分析 改版后，新频道是否受欢迎。衡量参数： 页面访问uv占比大盘 日均访问uv点击转化率 日均点击uv占比大盘 日均点击uv人均点击次数 次1日留存 次3日留存 次7日留存 说明: 频道访问uv占比大盘，数据提升，说明频道改版后，用户更喜欢访问此频道。（用户访问此频道后，并不一定会在频道内产生点击） 转化宽度： 日均访问uv点击转化率 = 频道内点击uv / 频道内访问uv，点击转化率提升，说明用户查看此频道后，频道内功能点改版后对访问此频道的用户更有吸引力。 日均点击uv占比大盘，数据提升，说明改版后吸引了更多的用户来进行点击。 转化深度：日均点击uv人均点击次数，数据提升，说明改版后，用户的点击频率也有所增加。 用户粘度：频道访问留存率提升， 说明改版后，此频道的用户粘性也在增加。 改版后，频道留存率上升原因分析主要为说明是某功能点使频道整体留存率上升。 公式： 频道留存率 = A用户数 A留存率 + 其他用户数 其他留存率 举例： 旧版次7日留存率 = 26.8%签到用户 46.7%留存率 + 73.2%其他用户 24.7%留存率 = 30.6% 新版次7日留存率 = 17.5%签到用户 48.8%留存率 + 82.5%其他用户 24.9留存率 = 29.1% 说明：新版本频道次7日留存率下降1.5，主要是由于9.3%的用户次7日留存率从46.7%下降到24.9% 3.2 新频道各坑位细拆分析 对频道中相同功能点进行新旧版本对比, 衡量参数： 各个坑位点击uv占比访问uv 各个坑位次7日留存率细拆 对1中数据差异较大坑位进行具体原因分析 对各模块坑位具体原因进行分析说明 3.3 对改版后的某主要功能点的流量结构变化进行分析 对新旧不同版本的流量结构进行梳理，找出主要流量入口变化，并进行说明。 用户究竟是如何使用产品新功能的，是否符合你预期设想的那样，还是说用户自己创造出了新的玩法 3.4 对产品流程转化率是否有提升 去观察整个产品的流程转化率是否因为产品迭代改版而有所提升。 查看转化漏斗，改变前后，流程的转化数据是否发生变化，每个小环节的漏斗转化率有什么变化]]></content>
      <categories>
        <category>数据分析方法</category>
      </categories>
      <tags>
        <tag>数据分析</tag>
        <tag>改版分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭建业务运营指标]]></title>
    <url>%2F2019%2F05%2F12%2F%E6%96%B9%E6%B3%95-%E5%B8%B8%E7%94%A8%E6%8C%87%E6%A0%87%2F</url>
    <content type="text"><![CDATA[作为一名数据分析师，在工作中通常需要一些指标来衡量数据发展的好坏，毕竟，如果你不能衡量它，那么你就不能增长它。 那么数据分析中常见的指标都有哪些，如何在工作中制定业务指标呢，今天的文章来详细探讨一下。 指标划分的整体思路1. 明确公司目前的核心指标 这也是一级指标，用来指引公司的战略目标。 明确我们需要研究公司目前都有哪些业务， 这些业务在行业中有没有一些标准的指标？ 如大目标是营收， 那么更多的付费用户能带来营收，更长的生命周期能带来营收，更高的客单价能带来营收，将一级级指标分配个多个团队或多个时间段来执行。 2. 明确部门的核心指标 根据公司的一级指标进行拆解，明确公司各个部门的二级指标。 我们要根据具体的职责来确定指标。 比如销售部门， 则gmv,客单价，客复购率等，都是我们需要追踪的指标。 认知阶段，很多都是市场部、品牌部、渠道从部负责，那么这样指标有问题，你就知道找谁背锅了。 3. 明确到个人的核心指标 根据对部门二级指标的拆解，明确部门个人的三级指标. 比如某人负责推广，则推广的流量， 转化率则就需要进行追踪， 对于数据异常，则能够追踪到某个员工具体的行为。 4. 明确每个业务动作的指标 每一个业务动作都话一个方框，注明什么动作，再补充这个动作需要哪些指标，使业务和指标之间的关系明确。 5. 学会跨部门背指标 很多部门的指标比较单一，比如渠道部只负责拉点击，不负责注册，那么就需要通过指标的表现和系统性，考虑跨部门背指标，或者用权重的方式去解决，让领导去拍板。 6 . 指标追踪 通过日报、周报、月报的数据汇报，来说明业务运营的问题，促进公司业务更好的发展。 对具体运营指标进行拆解-AARRR模型获取用户 核心： 找到获客成本较低且用户质量较高的渠道，通过砸钱让产品在某渠道进行曝光，并将用户转化成产品用户 常见的指标： 安装用户数 激活用户数 一次会话用户数 新用户下载完APP， 仅打开过产品一次，且该次使用时长在2分钟以内。（避免机器刷单） CPM - 每千人成本 广告展示时就向广告主收费，以曝光为目的，不强调实际获客效果。 倾向于保护流量主利益。 CAC - 每点击成本 用户发生点击行为时向广告主收费。 CAC = 新增用户总投入 / 新增用户总数 CPA - 每行动成本 以后端收费为主，也就是用户看到广告并点击后，有进一步了解的欲望，完成某些特定行为， 如下载APP、预约报名或购买了产品。 倾向于保护广告主利益。 CPPC - 每付费用户的获取成本 CPS - 以实际销售额换算广告金额 类似销售提成 CPD - 每下载成本 CPT - 每时间段成本 例如： 这个位置一个星期多少钱 ROI - 投资回报率 ROI = 销售所得利润 / 广告成本 * 100% 提高用户活跃度 提高产品使用粘性，提升用户使用深度。 DNU - 日新增用户数 DAU - 日活跃用户数 WAU - 周活跃用户数量 MAU - 月活跃用户数 ACU - 平均同时在线用户数 PCU - 最高同时在线用户数 UV - 访问用户数 PV - 点击量 人均点击次数 = 访问量/ 点击量 CTR - 点击率 点击量 / 曝光量 TS - 用户平均在线时长 人均启动次数 N次操作占比 用户行为路径 用户访问频次 跳出率 用户打开网站的某个网页， 然后直接退出网站。跳出率是直接衡量网页（网站）对“新用户”吸引力的重要指标 例如： 100个人进入该页面，5个人直接从该页面离开该网站，则跳出率为5%。 退出率 从该页面离开网站的次数占该网页总浏览次数的比例。退出率则是综合衡量用户离开网站行为的重要指标（也可能满足需求了就离开了） 例如： 20个人从该页面离开网站，该页面的总浏览量为200次，则退出率为10%。 用户会话次数 用户在时间窗口的所有行为集合。 例如：用户打开APP， 搜索商品，浏览商品，下单并支付，最后退出，整个算一次会话。 会话时间，网页端用户超过30分钟再次操作，算第二次会话。 移动端的时间窗口为5分钟。 功能渗透率 功能使用用户数 占 总活跃用户数 新老访客占比：衡量网站的生命力 访客时间： 衡量内容质量 访客平均访问页数：衡量网站对访客的吸引力，访问深度 访客来源： 访客从哪里来 用户行为转化率 首页访客占比：衡量网页结构，对新用户导航是否友好 TGI ： [目标群体中具有某一特征的群体所占比例 / 总体中具有相同特征的群体所占比例] * 100例如，在15-24岁的人群中，有8.9%的人过去一年内服用过斯达舒，而在总体人群中，服用过斯达舒的人数比例为6.6%，则斯达舒在15-24岁人群中的TGI指数是134.9，这说明，斯达舒主要定位在15-24岁的人群中。TGI指数表征不同特征用户关注问题的差异情况，其中TGI指数等于100表示平均水平，高于100，代表该类用户对某类问题的关注程度高于整体水平 提高留存率 如何让用户不断的使用我们的产品， 减少用户的流失，提升用户的粘性。 次日留存率 次3日留存率 次7日留存率 30日留存率 回流率 用户在使用该App离开的N天/周/月之后，再次使用该App的比例 用户流失率 用户生命周期（周期/(1-周期内新增留存率)) 功能使用率 衡量产品功能是否受用户欢迎 用户忠诚指数 忠诚指数是对活跃留存的再量化。活跃仅是产品的使用与否，A用户和B用户都是天天打开App，但是B产生了消费，那么B比A更忠诚。 提高收入 pu 付费用户 CR 付费转化率 注册用户到付费用户的转化率 ARPU 平均每用户收入 ARPPU 平均每付费用户收入 APA 活跃付费用户 PUR 用户付费率 APA / AU LTV 生命周期价值 如果我们获取到1万个用户需要花10万元，那么，如果这1万个用户从安装到卸载能够给公司带来大于10万元的收益，则这个产品就是可盈利的。 PBP 回收期 当我们预测到产品是可盈利的之后，所付出的成本需要多久才能收回，产品才能开始真正地盈利，这个时间就是回收期PBP，为了保证公司资金链不出问题，一般认为PBP能够在一年以内是最好的。 GMV 网站成交金额 拍下订单的总金额，包含付款和未付款两部分 支付uv 支付pv 访购率 人均订单数 客单价 总收入/订单数 复购率 单位时间内，消费两次以上的用户数占购买总用户数 退货率 消费次数 消费频率 订单量 购买间隔 APPU 每个用户的平均利润 用户推荐 通过提升产品的竞争力， 使用户给其他人推荐此产品。 分享率 分享次数 K因子 即每一个用户能够带来几个新用户 病毒传播周期 假设1000位种子用户在10天邀请了1500位用户，那么传播周期为10天，K因子为1.5。 NPS净推荐值 计量某个客户将会向其他人推荐某个企业或服务可能性的指数 净推荐值(NPS)=(推荐者数/总样本数)×100%-(贬损者数/总样本数)×100% 其他缩写 PP —— 英文percent point的简称，意思为百分比 UGC —— 用户原创内容 SEO —— 搜索引擎优化 CR —— 转化率 ： 衡量转化环节的好坏 visit —— 用户访问次数 ： 用户来到网站-关闭网站页面 Landing Page —— 着陆页 ： 用户从外部链接直接跳转到的第一个页面 Bounce Rate —— 跳出率 ： 用户来到网站，没有做任何行为就指标离开网站。 Referrer —— 引荐流量 PR —— 公众关系， 组织机构与公众环境之间的沟通与传播关系。 参考资料： 学习数据分析，从了解方法论开始万字干货总结：最全的运营数据指标解读]]></content>
      <categories>
        <category>数据分析方法</category>
      </categories>
      <tags>
        <tag>常用指标</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[营销活动分析]]></title>
    <url>%2F2019%2F04%2F22%2F%E6%96%B9%E6%B3%95-%E8%90%A5%E9%94%80%E6%B4%BB%E5%8A%A8%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[营销活动分析营销活动分析介绍互联网公司经常会做一些运营活动，比如比如当当网的限时优惠活动，春节期间支付宝的集五福活动等。这些活动花费了公司大量的人力与财力， 那么活动的效果该如何评估呢？这就需要用数据来说话。 数据分析在营销活动中的任务，不仅是在活动后对数据进行分析， 更要在活动前、活动中、活动后三个方面来都进行跟踪。 活动前期： 目的 和运营人员商定好本次活动的目标，这次活动主要是为了：拉新、促活还是品牌推广，没有目标的活动不是好的运营活动。 埋点 和运营人员商定好这次活动都需要了解哪些数据，针对需要采集的页面位置，写好埋点方案：字段名、埋点位置、上报方式 和研发人员沟通埋点方案，数据埋点完成后，测试采集数据是否准确， 避免采集数据有误。 搭建指标体系 写出这次活动自己都需要哪些指标，如何计算， 提前搭建好指标体系 提前订好这次活动自己需要输出哪些数据，用什么形式来进行展现， 定好数据的输出格式。 活动中期 观察活动前3天的数据 观察活动第1天的数据， 详细查看各指标体系的报表数据是否有异常，对于发现的问题做到及时修改。 观察1-3天的数据趋势， 预估活动目标的完成度， 考虑活动目标是否需要调整。 活动数据及时数据 定时输出活动战报，及时发现数据异常波动， 让运营人员和项目领导知道数据的实时动态。 对于长期活动，第一周后需要进行一次复盘，将结论同步给管理层， 让更高视野的人给建议。 活动后期 活动的效果 短期效果活动对大盘的影响 参与活动uv 打开APP， 首次进入活动uv 大盘的日环比、周同比 新增用户拉动低活跃用户重新活跃数目标完成度品牌传播指数 长期效果 新增用户留存率低活用户留存率 活动优化 活动主漏斗数据转化率 活动功能模块渗透率 用户反馈 活动报告 在活动结束1-2周内输出，要有时效性。 活动与活动之前的数据对比更能说明问题 思考每次活动的本质和意义。 敢于暴露问题， 把已知的事实告诉上级，邮件同步给运营负责人 涉及到钱的问题， 需要让业务方给， 邮件说明情况，钱问题比较敏感。 案例分析支付宝集五福活动 带来新增用户，提升用户的活跃度，品牌传播量 在活动开始之前应该确定一个重点提升的核心数据。 这样的数据包括新用户注册、用户活跃度、用户付费转化、产品交易额、品牌知名度（百度指数、新浪指数等）等等。 非商品交易类的互动性活动，需要关注： 产品核心数据（日活、新用户) 的提升效果。 专题页面的uv、pv, 活动产生的用户互动量和人均互动次数、分享次数 老用户和新用户的互动比例 交易类产品的促销活动： 互动为平台带来的总交易额、购买人数、人均客单价（关键指标） 活动页面商品的 uv、pv、进入活动页面的人数占比（活动吸引力） 浏览-加入购物车-下单的转化率，分析潜在用户流失原因。 优惠券核销量/ 优惠券发放量 不同渠道用户的付费比例，单价，留存]]></content>
      <categories>
        <category>数据分析方法</category>
      </categories>
      <tags>
        <tag>数据分析</tag>
        <tag>活动分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hive-SQL学习]]></title>
    <url>%2F2019%2F04%2F18%2F%E6%8A%80%E8%83%BD-Hive-SQL%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[数据库与表的增删改查数据库 create database-创建新数据库 12345--创建zhang数据库create database zhang --制定数据库的位置create database if not exists zhang location '/zhang.db' alter database-修改数据库 12---增加数据库属性alter database zhang set dbproperties("CTtime"= "2020-05-01") drop database -删除数据库 12345---数据库下无表drop database zhang;---数据库下有表，-强制删除drop database zhang cascade; 选择数据库 1use android; 12# 重置默认数据库use default android; 查看所在的数据库 123456789show databases;--模糊查询show databases like "s%"--- 查询数据库信息desc database zhang;---查询数据库扩展属性desc database extended zhang; 数据表 create table-创建新表 12345678910111213141516171819202122232425create [external] table [if not exists] table_name [(col_name data_type [comment col_comment],....)][partitioned by (col_name data_type [comment col_comment],..)][clustered by (col_name, col_name, ...)][row format row_format][stored as file_format][location hdfs_path]--- create table 创建指定名称的表，如果相同名称的表已存在，则用if not exists 选项来忽略这个异常。--extername 关键字让用户创建一个外部表---partitioned by 分区：分目录，把一个大的数据集根据业务需要分割成小的数据集。在查询时通过where子句的表达式来选择查询所需的指定分区，提高查询效率。--clustered by 分桶--row format 字段之间的分隔符---stored as 文件存储格式--location， 指定表在HDFS上的存储位置---在zhang库中创建test表create external table dept( deptid int, dname string, loc int) row format delimited fields terminated by '\t' update-更新数据库中的数据 1234567update 表名set 需更新的列名1= 新值1, 需更新的列名2=新值2,...where 列名 = 某个原有的值UPDATE Websites SET alexa='5000', country='USA' --更新的数据WHERE name='菜鸟教程'; insert into() -向数据库中插入新数据 12insert into 表名（列名1,列名2,列名3...)values(值1, 值2, 值3...) delete-从数据库中删除数据 12345678delete from 表名where column = value...DELETE FROM WebsitesWHERE name='Facebook' AND country='USA';--删除表中所有的行，表结果不变delete from table_name; alter table- 修改数据库表 123--清楚表中数据,删除掉指定分区ALTER TABLE shphonefeature DROP IF EXISTS PARTITION(year = 2015, month = 10, day = 1);---lter table test.mon_mau_list drop partition (hit_mon = '&#123;0&#125;') drop table - 删除表 create index -创建索引 drop index -删除索引 refresh table 表名 - 刷新数据表 1refresh table computer_log.client_ios_log 查看当前使用的数据库中有哪些表 1show tables; 查看非当前使用的数据库中有哪些表 1show tables in myhive; 查看数据库中以 android 开头的表 12use android;show tables like 'android*' 查看表的详细信息 1desc formatted android 查询分区表有多少分区 1show partitions dept_partition; 查看分区表结果 1desc formatted dept_partition 增加分区 1alter table dept_partition add partition(month=&apos;201705&apos;) partition(month=&apos;201704&apos;) 删除分区 1alter table dept_partition drop partition (month=&apos;201705&apos;) 内部表与外部表 内部表(管理表)：默认创建内部表， 删除表会删除所有数据 外部表： 删除表不会删除这份数据，不过描述表的元数据信息会被删除掉。 原始日志数据应该建立外部表（避免误删）， 用到的中间表、结果表使用内部表存储。 查看表是内部表还是外部表 12--查看表信息desc formatted table_name 内部表与外部表的相互转换 12345---内部表转换为外部表alter table student set tblproperties('EXTERNAL' = 'true') ---单引号、大小写不能变---外部表转化为内部表alter table student set tbproperties('EXTERNAL' = 'false') 查询select…from… 加入表中一列含有多个元素， 我们可以只查找此列的第一个元素 12select name, subord[0] from employees; 可以使用 “点” 符号， 类似：表的别名 . 列名 这样的用法 12select name, address.city from employees; 使用正则表达式，可以选出所有列名以 price 作为前缀的列 1select 'price.*' from stocks; 使用列值进行计算 1select count(distinct account), avg(salary) from employees; 使用别名 1select count(distinct acount) as uv from employees; 如果用 distinct, select 后面必须直接跟 distinct 1select distinct user_account, province from computer_viedata where 关系型运算符优先级高到低为：not - and - or 123select * from employees where country = 'us' and state = 'ca';select * from employees where country not in ('us', 'china') 数学运算符与关系运算符 运算符 描述 + 加法 - 减法 * 乘法 / 除法 % 取余 &amp; 与 \ 或 ^ 异或 ~ 取反 操作符 描述 A=B 如果A=B，则返回True,否则返回False A&lt;=&gt;B 如果A和B都为NULL，则返回True,其他的和等号操作结果一致，如果任意为Null,则结果为null A&lt;&gt;B,A!=B A或B为Null, 则返回Null,如果A不等于B，则返回True,否则返回False A&lt;B – A&lt;=B – A&gt;B – A&gt;=b – A[not] between B and C — A is null — A is not null — in – A [NOT] like B – A rlike B, A REGEXP B — 逻辑运算 描述 and — or – not — like、rlike 123456---like、 rlike select name, address.street from employees where address.street rlike '.*(beijing|shanghai).*';select name, address.street from employeeswhere address.street like '%beijing%' or address.street like '%shanghai%'; 通配符 含义 % 匹配0个或任意多个字符 _ 匹配任意一个字符 escape 转义字符，可匹配%和_。如SELECT * FROM table_name WHERE column_name LIKE ‘/%/_%_’ ESCAPE’/‘ — — . 匹配任意单个字 符 * 匹配0个或多个前一个得到的字符 [] 含有任意一个[]内的字符，[ab]*可匹配空串、a、b、或者由任意个a和b组成的字符串。 ^ 匹配开头，如^s匹配以s或者S开头的字符串 $ 匹配结尾，如s$匹配以s结尾的字符串。 {n} 匹配前一个字符反复n次。 group by1234567891011--- 对结果进行分类select year(ymd), avg(price_close) from stockswhere exchange = 'nasdaq' and symbol = 'aapl'group by year(ymd)order by year(ymd) desc; --desc 从高到低排列 order by1234567891011--对查询的所有结果进行排序, 可在字段加 DESC 关键字， 进行降序排序。 （默认 ASC， 升序）select year(ymd), avg(price_close) from stockswhere exchange = 'nasdaq' and symbol = 'aapl'group by year(ymd)order by year(ymd) desc; 12--先对code进行排序，然后对code里的姓名进行排序select * from a order by code, name desc; having1234567891011--- having 子句来限制输出结果--- 查找平均工资大于3000的部门select deparment, avg(salary) as average from salary_info group by deparment having average &gt; 3000 having 与 where 的区别： Where 是一个约束声明，使用Where约束来自数据库的数据，Where是在结果返回之前起作用的，Where中不能使用聚合函数。 Having是一个过滤声明，是在查询返回结果集以后对查询结果进行的过滤操作，在Having中可以使用聚合函数。 limit12---使用limit语句限制返回的行数，只显示 10 行select count(distinct account) as uv from employees limit 10; 表连接joinHive中Join的关联键必须在ON ()中指定，不能在Where中指定,ON 子句指定了两个表间数据进行连接的条件。 对于多张表进行连接查询12345678---为什么条件内不将表 b 和表 c 进行连接操作， 因为 Hive总是按照从左到右的顺序来执行SELECT a.ymd, a.price_close, b.price_close, c.price_closeFROM a JOIN b ON a.ymd = b.ymd JOIN c ON a.ymd = c.ymdWHERE a. symbol = 'Apple' AND b.symbol = 'Ibm' AND c.symbol = 'Google' 并集：union 与 union all12345678910111213141516171819202122with a1 as ( select user_account from data where hit_date between '2018-12-01' and '2018-12-02' and nbtn_name like "%支付宝%" union select user_account from data where hit_date between '2018-12-01' and '2018-12-02' and nbtn_name like "%手淘%")select count(user_account) as pvfrom a1 union 与 union all 的不同： union, 结果包含所有行， 并删除重复行 unoin all, 结果包含所有行， 但不删除重复行 交集：intersect12345678910111213141516171819202122with a1 as ( select user_account from data where hit_date between '2018-12-01' and '2018-12-02' and nbtn_name like "%支付宝%" intersect select user_account from data where hit_date between '2018-12-01' and '2018-12-02' and nbtn_name like "%手淘%")select count(user_account) as pvfrom a1 差集：except12345678910111213141516171819202122with a1 as ( select user_account from data where hit_date between '2018-12-01' and '2018-12-25' and nbtn_name like "%支付宝%" except select user_account from data where hit_date between '2018-12-01' and '2018-12-25' and nbtn_name like "%手淘%")select count(user_account) as pvfrom a1 函数聚合函数 函数名 定义 count() 个数统计函数 count(distinct ) 统计去重之后的个数 sum() 求和 sum(distinct ) 去重之后的和 avg() 平均值 avg(distinct) 去重之后的平均值 min() 最小值 max() 最大值 corr(A, B) 相关系数 var_pop() 方差 var_samp() 样本方差 stddev_pop() 标准偏差 stddev_samp() 标准样本偏差 covar_pop(A, B) 协方差 covar_samp(A, B) 样本协方差 RAND() 随机数 count(1)、count(*)、count(column) 之间的区别 执行效果上：count(*)包括了所有的列，相当于行数，在统计结果的时候，不会忽略列值为NULLcount(1)包括了忽略所有列，用1代表代码行，在统计结果的时候，不会忽略列值为NULLcount(列名)只包括列名那一列，在统计结果的时候，会忽略列值为空（这里的空不是只空字符串或者0，而是表示null）的计数，即某个字段值为NULL时，不统计。 执行效率上：列名为主键，count(列名)会比count(1)快列名不为主键，count(1)会比count(列名)快如果表多个列并且没有主键，则 count(1) 的执行效率优于count(*)如果有主键，则 select count(主键)的执行效率是最优的如果表只有一个字段，则 select count(*)最优。 时间函数 函数名 定义 语句 NOW ( ) 当前时间 select now() extract() 抽取具体的年、月、日 date() 返回时间的日期部分 year() 返回时间的年份 month() 返回时间的月份 day() 返回日期的天 hour() 返回时间的小时 minute() 返回时间的分钟 second() 返回时间的秒 week () 第几周 dayofweek() 返回星期几，1为星期天 dayofyear() 一年中的第几天 sec_to_time ( ) 秒数转成时间 date_add() 时间相加 date_add(dt,interval 1 day ) date_sub(date,INTERVAL expr（时间间隔） type（时间类型，天、月、年）) 时间相减 date_sub(‘2018-05-01’,interval -1 year) datediff() 时间的差值 date_format() 输出指定时间格式 date_format(hit_date, “%Y-%m-%d) datename() 返回日期部分的参数 datepart() 返回日期、时间的单独部分 求留存率 datediff-求留存率 1234567891011121314151617181920212223242526272829---一次性求次1日，次3日， 次7日留存，此方法不能计算pv，会造成笛卡尔积with a1 as (select hit_date, user_accountfrom computer_view.datawhere hit_date between '2019-04-25' and '2019-05-13' and btn_information is not null),a2 as (select hit_date, user_accountfrom computer_view.datawhere hit_date between '2019-04-25' and '2019-05-13' and btn_information is not null)select a1.hit_date,count(distinct a1.user_account) uv,count(distinct case when datediff(a2.hit_date, a1.hit_date) = 1 then a1.user_account else null end ) next_day,count(distinct case when datediff(a2.hit_date, a1.hit_date) = 3 then a1.user_account else null end ) three_day,count(distinct case when datediff(a2.hit_date, a1.hit_date) = 7 then a1.user_account else null end ) seven_dayfrom a1 join a2 on a1.user_account = a2.user_accountgroup by a1.hit_dateorder by a1.hit_datelimit 100 date_add 求留存率 12345678910111213141516171819202122232425262728293031323334---步骤1：统计每天的uv---步骤2： - 统计10-15号每天的次日留存数， 统计次3、7日留存只需将1换为3、7with a1 as ( select user_account, hit_date from computer_view.data where hit_date between '2018-11-10' and '2018-11-15'),a2 as ( select user_account, hit_date from computer_view.data where hit_date between '2018-11-10' and '2018-11-25')select a1.hit_date, count(distinct a1.user_account) as uvfrom a1 join a2 on a1.user_account = a2.user_accountWHERE a2.hit_date = date_add(a1.hit_date, 1) group by a1.hit_dateorder BY a1.hit_date--步骤3：计算留存率 计算留存率的其他写法-迷神 1234567891011121314151617181920212223242526-- 留存sql优化select count(1)from( select userid, count(1) from( select t1.userid, t1.statdate from table1 t1 where t1.statdate = $&#123;上30天日期&#125; and t1.statdate &lt;= $&#123;上一天日期&#125; group by t1.userid, t1.statdate ) s1 group by userid having count(1) 2 ) R1--此sql为一个样例，计算连续跟任意都适用，至于计算第N天，只需要更改下日期过滤条件，变成=$[上N天日期]，=$&#123;上一天日期&#125;。 --另外，这种方式适合跑当前周期数据，如果跑历史数据，可以写个循环。当然，最暴力还是直接用userid 关联。--这种写法，更多是针对现在大部分分布式处理平台的特性，尽可能将数据合理均匀分片，每台服务器各自运算自己的，最后汇总。 尽可能少用 count distinct 这种写法，因为无法利用分片的特性。 留存率的另一种写法-勇哥 123456789101112131415161718192021222324252627282930313233343536373839404142with a1 as (select hit_date, user_account, count(1) as hit_countfrom apache_computer_view.client_android_logWHERE hit_date between '2020-04-01' and '2020-04-07' and btn_navigation like "%查询办理%"group by 1,2),a2 as (select hit_date, user_account, count(1) as hit_countfrom apache_computer_view.client_android_logWHERE hit_date between '2020-04-01' and '2020-04-07' and btn_navigation like "%查询办理%"group by 1,2)select a1.hit_date as one, a2.hit_date as two, datediff(a2.hit_date, a1.hit_date) as cha, count(distinct a2.user_account), sum(a2.hit_count)from a1 left join a2 on a1.user_account = a2.user_accountgroup by 1,2having cha &gt; 0order by 1,2 计算月留存率的简单写法：筛选出在两个月份出现的用户 12345678910111213141516171819202122232425262728with a1 as (select user_account, count(distinct month (hit_date)) as cfrom apache_computer_view.client_android_log where hit_date between '2019-03-01' and '2019-04-31'group by user_accounthaving c = 2union select user_account, count(distinct month (hit_date)) as cfrom apache_computer_view.client_ios_log where hit_date between '2019-03-01' and '2019-04-31'group by user_accounthaving c = 2 )select count(distinct user_account) as uv from a1 条件判断：case when 与 if IF( expr , v1 , v2 )函数 查出班级所有学生，如果年龄小于20，就标准为少年，否则标记为青年。12345select * if(age&lt;20,'少年','青年') AS ifage from student ifnull(V1,V2)函数 如果v1不为空，则直接返回v1;如果v1为空，则返回参数v2123select ifnull(1,2), ifnull(null,10); case when 函数 对不同字母进行省份转换 12345678910111213141516171819202122232425selectcase when province like 'ah' then '安徽' when province like 'fj' then '福建' when province like 'gd' then '广东' else 'm' end as province , count(distinct user_account) uv, count(page_name) pvfrom android_logwhere hit_date between '&#123;&#125;' and '&#123;&#125;'and page_name like '%Kefujh%'group by case when province like 'ah' then '安徽' when province like 'fj' then '福建' when province like 'gd' then '广东' else 'm' end order by case when province like 'ah' then '安徽' when province like 'fj' then '福建' when province like 'gd' then '广东' else 'm' end limit 1000 统计各部门男女分别有多少人 姓名 部门 性别 甲 A 男 乙 A 男 丙 B 女 丁 A 女 张 B 男 赵 B 女 1234567select 部门， sum (case 性别 when '男' then 1 else 0 end ) as male_count, sum (case 性别 when '女' then 1 else 0 end ) as male_countfrom table1group by 部门 范围转换12345678910select case when population &lt; 250 then '1' when population = 250 and population &lt; 500 then '2' when population = 500 and population &lt; 750 then '3' when population = 750 then '4' else null end as pop_classs, count(*) as cntfrom popgroup by district; 行转列 函数 case when concat(string A/col, string B/col…) ：函数在连接字符串时，只要其中一个是NUll，则返回NUll concat_ws(separator, str1, str2,…): 函数需要指定分隔符，只能接收 string或string类型的数组，只要有一个字符串不是NUll， 则不会返回NULL。 collect_set(col): 函数值接受基本数据类型，主要作用是将某字段的值进行去重汇总，产生array类型字段。 案例 多行转多列 年 季度 销售量 1991 1 11 1991 2 12 1991 3 13 1991 4 14 1992 1 21 1992 2 22 1992 3 23 1992 4 24 查询结果如下： 年 一季度 二季度 三季度 四季度 1991 11 12 13 14 1992 21 22 23 24 12345678910select 年, sum(case when 季度=1 then 销售量 else 0 end ) as 一季度, sum(case when 季度=2 then 销售量 else 0 end ) as 二季度, sum(case when 季度=3 then 销售量 else 0 end ) as 三季度, sum(case when 季度=4 then 销售量 else 0 end ) as 四季度,from salesgroup by 年 多行转单列 省-城市 uv 河北省-保定 11189 山西省-阳泉市 13 河南省-信阳 7462 1234567891011121314select concat(province,'-', city), uv --concat_ws('-', province, city), uv from (select province, city, count(distinct user_account) as uv from apache_computer_viewwhere hit_date = '2020-03-01'group by province, city) 多行转单列-复杂 name contellation blood_type 孙悟空 白羊座 A 猪八戒 射手座 A 宋宋 白羊座 B 唐僧 白羊座 A 张帅 射手座 A 把星座和血型一样的人归类到一起： 。。。 。。。 射手座,A 猪八戒\张帅 白羊座，A 孙悟空\唐僧 白羊座，B 宋 123456789101112select t1.c_b concat_ws("\", collect_set (t1.name))from ( select concat_ws(',', constellation, blood_type) c_b, name from person_info) t1group by t1.c_b;) 求将每个省的城市列出来 12345678910111213select province, collect_set(city)from apache_computer_view.client_android_log where hit_date = '2020-03-01'and nbtn_name is not null group by province---辽宁省 ["营口市","大连","大连市","抚顺市","铁岭","盘锦","锦州","沈阳市","辽阳","鞍山","铁岭市","本溪市","丹东市","丹东","沈阳","朝阳市","锦州市","辽阳市","阜新市","鞍山市","盘锦市","葫芦岛","营口","抚顺","葫芦岛市","阜新","本溪","朝阳"] 求出一个月内活跃天数大于20天的用户数 1234567891011121314151617--先列出每个用户的所有登陆时间--选出需要的时间段select count(distinct user_account) as uv from (select user_account, collect_set(hit_date) as t from apache_computer_view.client_android_log where hit_date between '2020-03-01' and '2020-03-31' group by user_account) as awhere size(a.t) &gt;= 20--手机号对应日期长度 &gt;= 20 列转行 函数 explode(col): 将hive列中复杂的array或者map结构拆分成多行 lateral view用法： lateral view udtf(expression) tableAlias as columnAlias说明： 用户和split,explode 等UDTF一起使用，能够将一列数据拆分成多行数据， 在此基础上可以对拆分的数据进行聚合计算. 形成一个新的表，并对原来的表进行侧写 案例 需求1 movie category 《疑犯追踪》 悬疑,动作,科幻,剧情 《lie to me》 警匪,动作,心理 要求： movie category 《疑犯追踪》 悬疑 《疑犯追踪》 动作 《疑犯追踪》 科幻 《疑犯追踪》 剧情 《lie to me》 警匪 《lie to me》 动作 《lie to me》 心理 123456789select movie, category_namefrom movie_infolateral view explode(category) tmpTable as category_name---用分开的表，对要求的数据进行测写-- select movie,explode(category) from movie_info 会生成笛卡尔积，不能执行 需求2： 将 表 table 中的 adid_list 转换为单独的行。 表-table： pageid adid_list front_page [1,2,3] contact_page [3,4] 输出结果为： pageid adid_list front_page 1 front_page 2 front_page 3 contact_page 3 contact_page 4 12345SELECT pageid, adidFROM tablelateral view explode(adid_list) adTable as adid 需求3： 计算特定广告的展现次数 1234567SELECT adid, count(1)FROM tablelateral view explode(adid_list) adTable as adidGROUP BY adid 输出结果为： adid count(1) 1 1 2 1 3 2 4 1 需求4： 多个 lateral view 查询 表： table2 array col2 [1,2] [“a”，”b”] [3,4] [“c”, “d”] 输出结果为： myCol1 myCol2 1 “a” 1 “b” 2 “a” 2 “b” 3 “c” 3 “d” 4 “c” 4 “d” 123456SELECT myCol1, myCol2FROM baseTableLATERAL VIEW explode(col1) myTable1 AS myCol1LATERAL VIEW explode(col2) myTable2 AS myCol2 窗口函数 函数 函数名 定义 over() 指定分析函数工作的数据窗口大小，这个数据窗口大小可能会随着行的变化而变化 常跟的函数 说明 — — current row 当前行 n preceding 往前n行数据 n following 往后n行数据 unbounded 起点 uvbounded preceding 表示从前面的起点开始 unbounded following 表示到后面的终点 lag(col, n) 往前第n行数据 lead(col, n) 往后第n行数据 ntile(n) 把有序分区中的行分发到指定数据的组中， 各个组有编号，编号从1开始，ntile返回此行所属组的编号 first_value() 返回组中数据窗口的第一个值 last_value() 返回组中数据窗口的最后一个值 案例 name orderdate cost jack 2017-01-01 10 tony 2017-01-02 15 jack 2017-01-03 23 tony 2017-01-04 29 jack 2017-01-05 46 jack 2017-04-06 42 tony 2017-01-07 50 jack 2017-01-08 55 mart 2017-04-08 62 mart 2017-04-09 68 neil 2017-05-10 12 mart 2017-04-11 75 neil 2017-06-12 80 mart 2017-04-13 94 查询在2017年4月购买的顾客及总人数12345678select name,count(1)over() ----over全量， 如果不加over，就会按照name来划分from businesswhere substring_index(orderdate,'-',2) = '2017-04'group by name name c1 不加over jack 2 1 mart 2 4 查询顾客的购买明细及月购买总额 123456select *, sum(cost) over (distribute by month(orderdate))--- sum(cost) over (partition by month(orderdate))from business 要将cost按照日期进行累加 12345select *, sum(cost) over(order by orderdate rows between unbounded preceding and current row)from business 按照日期进行排序，并将当前日期和前一天、后一天数据求和 12345select *, sum(cost) over(order by orderdate rows between 1 preceding and 1 following)from business 求每个人将按照日期进行累加的消费金额 12345select *, sum(cost) over (partition by name order by orderdate rows between unbounded preceding and current row )from business 要将cost按照日期进行倒序累加 12345select *, sum(cost) over (order by orderdate rows between current now and unbounded following )from business 查询顾客上次购买的时间, 与下次购买时间。相邻两个时间戳如何相减，求时间 123456select *, lag(orderdate, 1) over (partition by name order by orderdate), lead(orderdate,1) over (partition by name order by orderdate)from business 查询前20%时间的订单信息 1234567891011select * from ( select name, orderdate, cost, ntile(5) over(order by orderdate) gid from business ) twhere git =1 ntile函数详解ntile函数可以将有序数据，根据指定的组数进行分组处理。 编号从1开始，对于每一行，ntile将返回此行所属的组编号。ntile函数的分组依据： 每组包含的数据个数不能大于它上一组 包含的数据个数 计算规则：1. 检查能不能对所有满足条件的记录进行平均分组，若能则直接平均分配完成分组。2. 若不能，则会先分出一个组，此组个数为（总个数/总组数）+1。3. 分配之后系统会继续比较余下的记录数与未分配的组数能不能进行平均分配，若不能，则根据上面条件再分配。 例如：将6个记录分为4组， 不能平均分配则，第一组记录数为 （6/4)+1 = 2条记录。剩余4条记录分为3组，不能平均分配，则第二组记录数为（4/3)+1=2条记录。剩余2条记录分为2组，则剩余2组各1条记录。 排序函数 函数 SQl 中用于排序的函数有：rank、dense_rank、row_number、ntile函数,其语法为：1234567891011rank() over ([partition by A] order by B DESC)dense_rank() over ([partition by A] order by B DESC)row_number() over ([partition by A] order by B DESC )ntile() over([partition by A] order by B desc)-- partition by A 表示 按照A进行分区。-- order by B 表示按照B进行排序。-- DESC 表示 从大到小降序排列。-- 其中[partition by col1]若不需要则可省略不写。 明确各函数之间的不同点rank函数， 数值相等的排序则会留下空位： 1、2、2、4dense_rank函数，数值相等的排序不会留下空位: 1、2、2、3row_number函数，则不区分数值是否相等，默认排序为： 1、2、3、4ntile函数，对有序行进行分组处理 **2.需求 如何找出各省点击人数Top10的按钮？ 对于这个问题，首先要理清自己的思路：1. 取出 省份、按钮和 uv;2. 各省分组内，按照uv进行从大到小排序，并输出一列排序序号;3. 根据排序序号，取出排序前10的按钮和省份。 1234567891011121314151617181920212223242526select province, nbtn_name from (select province, --省份 nbtn_name, --按钮 uv, --uv dense_rank()over(partition by province order by uv DESC) as ran --排序from (select province, nbtn_name, count(distinct user_account) as uvfrom apache_computer_view.client_android_log where nbtn_name is not null and hit_date = '2020-03-10'group by province, nbtn_name))where ran &lt;= 10 求连续4个月活跃的用户数 123456789101112131415161718192021---1月活跃的用户数， 在2月、3月、4月一直活跃的用户有多少？with a1 as(select user_account , month(hit_date) as monthfrom compu_view.ios_log_viewwhere hit_date between '2019-01-01' and '2019-04-30'group by user_account, month(hit_date) ),a2 as ( select user_account,a1.month, row_number() over(partition by user_account order by a1.month) as pxfrom a1) select count(distinct user_account) as uvfrom a2where a2.px = 4 求4月连续7天进行签到的用户数 12 字符串函数 函数 函数名 定义 concat() 拼接字符串 length() 计算字符串的长度，一个汉字算三个字符 instr (A ,B ) 返回字符B首次在A中出现的位置,不存在返回0 lcase() 转换成小写 left(string2 ,length ) 从string2中的左边起取length个字符 lower() 将字串转化为小写 upper() 将字符转化为大写 replace() 替换字符 split() hive字符串分割函数 substr() 返回字符串A从start位置开始，长度为len的字符串 substring() 截取字符串 substring_index() 通过截取获取不同索引位的字符 LTRIM (string2 ) 去除前端空格 RTRIM (string2 ) 去除后端空格 函数详解 substr函数与 substring函数用法相同: 1substr/substring( A, k开始截取的位置，截取长度) 举例：1234substr(string,4): 从右第4位置截取到最后，结果为：ingsubstr(string,1,3):取左边第1位置起，3字长的字符串，结果为：strsubstr(string,-3,3):取右边第1位置起，3字长的字符串,右边第一位置往右不够3字长，结果为：gsubstr(string,-3,3):取右边第1位置起，3字长的字符串，结果为：ing substring_index函数1substring_index(A, 分割的字符,截取字符的位置) 举例：123456789substring_index(&apos;15,151,152,16&apos;,&apos;,&apos;,1)：取第一个逗号前面的字符串，结果为：15substring_index(&apos;15,151,152,16&apos;,&apos;,&apos;,2)：取第二个逗号前面部分，结果为：15,151substring_index(&apos;15,151,152,16&apos;,&apos;,&apos;,-1)：取目标字符串中最后一个含 “,” 位子的后的部分，结果为：16substring_index(substring_index(&apos;15,151,152,16&apos;,&apos;,&apos;,2),&apos;,&apos;,-1):取第二个逗号前面部分,然后最后逗号的前面部分，结果为：151substring_index(substring_index(&apos;15,151,152,16&apos;,&apos;,&apos;,-2),&apos;,&apos;,1)：取倒数第二个逗号后面部分字符串，再去这部分里第一个都号前的部分，结果为：152 split函数 1split(A, 分割的字符) 举例： 12345678910split(&apos;a,b,c,d&apos;,&apos;,&apos;):根据逗号进行分割，结果为： [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;]split(&apos;a,b,c,d&apos;,&apos;,&apos;)[0]： 取结果数组中的某一项，结果为： asplit(&apos;192.168.0.1&apos;,&apos;\\.&apos;)： 点号这种特殊字符的时候需要做特殊的处理，结果为：[&quot;192&quot;,&quot;168&quot;,&quot;0&quot;,&quot;1&quot;]&quot;.... split(&apos;192.168.0.1&apos;,&apos;\\\\.&apos;) ... &quot;: split包含在 &quot;&quot; 之中时 需要加4个\,不然得到的值是null同样的 | 等特殊符号也需要做类似 处理。 3.区分函数之前的区别 substr函数与 substring函数是根据截取的位置来进行分割。 substring_index和split是根据特定的字符来进行分割。 需求 将一些字段拆解出来进行使用，比如：Syjh-sjsy-zygn-3_1字段，我们只需要Syjh-sjsy-zygn位置的所有按钮。 1234567891011select substring_index(nbtn_position, &apos;-&apos;,3) as position, count(distinct user_account) as uv from apache_computer_viewwhere hit_date = &apos;2020-03-01&apos; and nbtn_position like &apos;%Syjh%&apos;group by substring_index(nbtn_position, &apos;-&apos;,3) 空字段赋值NVL：给值为NULL的数据赋值，格式为NVL（string1, replace_with),功能为：如果string1为null，则NVL函数返回replace_with的值，否则返回string1的值，如果两个参数都为NULL，则返回NULL。1select nvl(comm, -1) from student; 查看系统内置函数 查看系统自带的函数 1show functions 显示自带的函数的用户 1desc function 函数名; 详细显示自带的函数用法 1desc function extended 函数名 Hive避免数据倾斜 数据倾斜：当我们在Hive上进行查询时，因为数据的分散度不够， 导致大量数据集中在一台或者几台服务器上， 导致数据的计算速度远远低于平均计算速度， 计算过程特别耗时。 数据倾斜的表现：任务进度长时间维持在99%，查看任务监控页面，发现只有少量子任务未完成。 小表Join大表 Hive 会假定查询中最后一个表是最大的表， 在对每行记录进行连续操作时， 它会尝试将其他表缓存起来，然后扫描最后那个表进行计算。因此，我们在查询时，要保证连续查询中的表的大小从左到右依次是增加的。 假如，在 a, b 两个表中，b表最小， 则 写sql时需让b表在左，a表在右： 123456789101112131415161718SELECT a.price_close, b.price_closeFROM b JOIN a ON b.ymd = a.ymd AND b.symbol = a.symbolWHERE a.symbol = 'APPLE'---Hive支持使用/*+STREAMTALBE*/语法指定哪张表是大表， 不需要排序SELECT /*+3`'LKLLGFG Streamtable(a)*/ a.price_close, b.price_closeFROM a JOIN B on a.ymd = b.ymd AND a.symbol = b.symbolWHERE a.symbol = 'Apple' 大表JOIN大表 空key过滤有时join超时是因为某些key对应的数据太多，而相同key对应的数据都会发送到相同的reducer上，从而导致内存不够。此时我们应该仔细分析这些异常的key，很多情况下，这些key对应的数据是异常数据，我们需要在sql语句中进行过滤。 123456789101112131415Select *From a Join bOn a.user_id is not nullAnd a.user_id = b.user_idUnion allSelect * from awhere a.user_id is null 空key转换有时虽然某个key为空对应的数据很多，但是相应的数据不是异常数据，必须要包含在join的结果中，此时我们可以表a中key为空的字段赋一个随机值，是的数据随机均匀地分布到不同的reducer上。 把空值的 key 变成一个字符串加上随机数，就能把倾斜的数据分到不同的 reduce 上 ,解决数据倾斜问题。 需要用到Case When … Else…End语法123select n.*from nullidtable n full join bigtable o oncase when n.id is null then concat('hive', rand()) else n.id end = o.id; count(distinct) 去重统计 数据量大时，由于count distinct 操作需要用一个 reduce task 来完成， 这一个reduce 需要处理的数据量太大，会导致整个job很难完成，一般 count distinct 使用先group by 再 count的方式替换。123select count(distinct id) from bigtableselect count(id) from (select id from bigtable group by id) a 避免笛卡尔积尽量避免产生笛卡尔积，如join时不加on条件，或无效的on条件。hive只能使用1个reducer来完成笛卡尔积 行列过滤 列处理： 在查询中， 避免使用 select *, 使用条件限制取需要的列。 行处理： 在分区剪裁中，当使用join外关联时，如果将副表的过滤条件写在where后面，那么就会先全表关联，之后再过滤, 这样会耗费资源。 123456select o.id from bigtable b join ori o on.id = b.id where o.id &lt;=10;select b.id from bigtable bjoin (select id from ori where id &lt;=10) o on b.id = o.id) 12345678910111213SELECT a.price_close, b.price_closeFROM b JOIN a ON b.ymd = a.ymd AND b.symbol = a.symbolWHERE s.symbol = 'APPLE'--正确的写法是将 where 条件写在 on 后面SELECT a.price_close, b.price_closeFROM b JOIN a ON ( b.ymd = a.ymd AND b.symbol = a.symbol and s.symbol = 'APPLE' union all 子查询避免中使用 group by等 union all 子查询避免中使用 group by【替换 count(distinct) 除外】、count(distinct)、max、min等。 123456789101112131415161718192021222324252627with a1 as ( select user_account, hit_date from data where hit_date between '2018-12-01' and '2018-12-13' and nbtn_name like "%支付宝%" union all select user_account, hit_date from data where hit_date between '2018-12-01' and '2018-12-13' and nbtn_name like "%支付宝%")select hit_date, count(user_account) as pvfrom a1group by hit_date 避免不同数据类型进行关联 使用CAST函数对数据类型进行转换，语法为cast(value AS TYPE)123456789select a.price_close, b.price_closefrom a join b on a.user_id = cast(b.user_id as string)where hit_date between &apos;2018-11-01&apos; and &apos;2018-11-02&apos; and a.symbol = &apos;apple&apos; Hive的查询注意事项以及优化总结： 尽量尽早过滤数据，减少每个阶段的数据量。对于分区表要加分区，同时只选择需要使用到的字段 对历史库的计算经验 尽量原子化操作，尽量避免一个SQL包含复杂逻辑，可以使用中间表来完成复杂的逻辑 join操作 小表要注意放在join的左边，否则会引起磁盘和内存的大量消耗 如果union all的部分个数大于2，或者每个union部分数据量大，应该拆成多个insert into语句，实际测试过程中，执行时间能提升50% 用python脚本连接数据库作为一名数据分析师，日报、周报、月报数据一个也不能少。 相应的， 就要在数据库中提取大量的数据， 并处理大量的Excel表格。 在提取和处理数据的过程中， 对于一些重复性的劳动， 写个Python脚本来实现半自动化， 能够大幅提高自己的工作效率。 以下是自己工作中的一点总结经验。 首先， 用Python连接数据库 对于数据库的ip地址，用户名，密码等， 如果不清楚，或数据库连接不上， 需要和开发人员对接 12345678from pyhive import hive import timeconn = hive.Connection(host='ip地址', port=10000, username='用户名', database = 'default', auth='NOSASL')cursor = conn.cursor()# 获得连接的游标 设置开始和结束时间可以用python中的time函数设置时间 12startdate = '2018-09-01'enddate = '2018-09-19' 用Python中的format函数将日期传入{}中 python中写sql脚本时， 需要用\来进行换行符的转换, \后面不能有空格。 日期用两个{}来代替， 用format函数将开始日期与结束日期传入 123456789101112131415161718192021222324# 提取积分类uv,pv数据sql_jifenxinxi_an = """select count(distinct user_account) as uv, count(1) as pv from computer_view.data where hit_date between "&#123;&#125;" and "&#123;&#125;" and (btn_position like "服务-查询-积分信息%" or btn_home = "积分-扇形左" ) limit 1000""".format(startdate,enddate)# format 插入时间cursor.execute(sql_jifenxinxi_an)# 运行此语句cursor.fetchall()#fetchall():接收全部的返回结果行. 我们可以按照这个格式写工作中需要运行的多个SQL语句。 这样， 当脚本运行的时候， 我们可以腾出时间来去干其他工作， 等过一段时间，所有的SQL语句都跑完了， 我们再进行统一的整理。 其他拓展group by 升级版 需求背景 通过 a1 明细表，获得每个店铺，每个城市，每个省份，每个大区以及全国5月的份的成交量情况。 order_id shop city province area hit_date 1 A 西安 陕西 西北大区 2019-05-04 2 B 上海 上海 华东大区 2019-05-01 3 C 安康 陕西 西北大区 2019-05-02 4 D 北京 北京 华中大区 2019-05-21 5 E 延安 陕西 西北大区 2019-05-03 6 F 成都 四川 西南大区 2019-05-19 7 G 汉中 陕西 西北大区 2019-06-04 … … … … … … 10000 H 郑州 河南 西北大区 2019-05-29 解法1： 分别写5个sql 1234567-- 全国成交量selectcount(order_id) as salesfroma1where hit_date between '2019-05-01' and '2019-05-31' 12345678910-- 大区成交量selectarea,count(order_id) as salesfrom a1where hit_date between '2019-05-01' and '2019-05-31'group byarea 123456789101112-- 省成交量selectarea,province,count(order_id) as salesfrom a1where hit_date between '2019-05-01' and '2019-05-31'group byarea,province 1234567891011121314-- 城市成交量selectarea,province,city,count(order_id) as salesfrom a1where hit_date between '2019-05-01' and '2019-05-31'group byarea,province,city 12345678910111213141516-- 店铺成交量selectarea,province,city,shop,count(order_id) as salesfrom a1where hit_date between '2019-05-01' and '2019-05-31'group byarea,province,city,shop 这种方法太低效了， 还需要在excel中进行合并，比较麻烦。 解法2： 通过 union 和 union all 对查询结果进行纵向合并 union: 对合并后的结果进行去重处理 union all : 返回合并后的所有数据 1234567891011121314151617select null,null,null,null,count(order_id) as sales from a1 where hit_date between '2019-05-01' and '2019-05-31' union all select area, null , null ,null, count(order_id) as sales from a1 where hit_date between '2019-05-01' and '2019-05-31' group by areaunion all select area, province , null ,null, count(order_id) as sales from a1 where hit_date between '2019-05-01' and '2019-05-31' group by area, provinceunion all select area, province, city ,null, count(order_id) as sales from a1 where hit_date between '2019-05-01' and '2019-05-31' group by area, province, cityunion all select area, province, city ,shop, count(order_id) as sales from a1 where hit_date between '2019-05-01' and '2019-05-31' group by area, province, city, shop 上述式中有很多 null, 这是因为 union all 拼接的两个表的列数需要相等。 结果如下： 解法3： 利用 union all 比写出5个sql 再在 Excel 中处理简单很多，但是代码比较冗余。可以用grouping sets来进行优化。 此函数可以根据不同维度组合进行聚合。 将union all 语句用grouping sets 进行改写： 1234567891011121314151617181920212223242526select null, area, province, city, shop, count(orderid) as sales, grouping_idfrom a1where hit_date between '2019-05-01' and '2019-05-31'group by null, area, province, city, shopgrouping sets (null, area, (area,province), (area,province,city), (area,province,city,shop)order by grouping_id 得到结果与利用 union all拼接结果相同。group by后面的字段表示要分组聚合的全部字段， grouping sets后面为 group by 后面各种字段的组合。 grouping_id表示每个分组的序号。 1 表示第一个分组、2表示第二个分组。我们可以根据grouping_id 选取我们需要的组合。如果我们需要全国的成交量，则让 grouping_id = 1, 需要每个省的成交量，让 grouping_id = 3。 解法4： cube函数， 对group by的维度的所有组合进行聚合。 123456789101112131415select area, province, count(orderid) as sales, grouping_idfrom a1where hit_date between '2019-05-01' and '2019-05-31'group by area, provincewith cubeorder by grouping_id 以上代码对区域和省份进行了聚合， cube 会先对全部数据进行聚合，即 null, null， 再对area,null进行聚合，然后再对null, province进行聚合，最后再对area,province进行聚合。 解法5：rollup函数， 和cube类似，是针对 group by所有维度的部分组合。 123456789101112131415select area, province, count(orderid) as sales, grouping_idfrom a1where hit_date between '2019-05-01' and '2019-05-31'group by area, provincewith rolluporder by grouping_id 对比cube和rollup得到的结果，我们发现rollup少了null province 这个组合，rollup 是以最左侧指标为主进行组合聚合。 参考资料：讲讲 group 的plus版-张俊红]]></content>
      <categories>
        <category>数据分析技能</category>
      </categories>
      <tags>
        <tag>Hive</tag>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常见的分析思维方法]]></title>
    <url>%2F2019%2F03%2F26%2F%E6%96%B9%E6%B3%95-%E5%B8%B8%E8%A7%81%E7%9A%84%E5%88%86%E6%9E%90%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[数据分析方法 使用频率按照顺序排列 1.对比分析法 对比分析是给单独的数据一个参考系， 否则孤立的数据毫无意义。 时间上的同比环比 环比、环比增长率 同比、同比增长率 竞争对手对比 与其他维度结合，进行对比 活动促销前后的对比 细拆维度之间的对比 各渠道之间的对比等 2.多维度拆解法 多维分解是指从业务需求出发，将指标从多个维度进行拆分。 说明： 为什么需要进行多维拆解? 有时候一个非常笼统或者最终的指标你是看不出什么问题来的，但是进行拆分之后，很多细节问题就会浮现出来。 举个例子，某网站的跳出率是0.47、平均访问深度是4.39、平均访问时长是0.55分钟。如果你要提升用户的参与度，显然这样的数据会让你无从下手;但是你对这些指标进行拆解之后就会发现很多思路。 补充：维度拆解不够， 容易导致辛普森悖论 3. 漏斗分析法漏斗分析法， 还原用户转化的路径， 分析每一步的转化率， 针对性的优化和改善 说明：漏斗分析是一套流程式数据分析，它能够科学反映用户行为状态以及从起点到终点各阶段用户转化率情况的重要分析模型。 漏斗分析模型已经广泛应用于网站用户行为分析和APP用户行为分析的流量监控、产品目标转化等日常数据运营与数据分析的工作中 漏斗分析要注意的两个要点： 不但要看总体的转化率，还要关注转化过程每一步的转化率; 漏斗分析也需要进行多维度拆解，拆解之后可能会发现不同维度下的转化率也有很大差异。 4. 留存分析 留存分析是一种用来分析用户参与情况/活跃程度的分析模型，考察进行初始行为的用户中，有多少人会进行后续行为。 衡量留存的常见指标有：次日留存率、7日留存率、30日留存率等等 说明： 这是用来衡量产品对用户价值高低的重要方法 留存分析可以帮助回答以下问题： 一个新客户在未来的一段时间内是否完成了您期许用户完成的行为？如支付订单等； 某个社交产品改进了新注册用户的引导流程，期待改善用户注册后的参与程度，如何验证？ 想判断某项产品改动是否奏效，如新增了一个邀请好友的功能，观察是否有人因新增功能而多使用产品几个月？ 5. 趋势分析通常我们在数据分析产品中建立一张数据指标的线图或者柱状图，然后持续观察，重点关注异常值。 说明： 在这个过程中，我们要选定第一关键指标，而不要被虚荣指标所迷惑。 以社交类APP为例，如果我们将下载量作为第一关键指标，可能就会走偏;因为用户下载APP并不代表他使用了你的产品。在这种情况下，建议将DAU(Daily Active Users，日活跃用户)作为第一关键指标，而且是启动并且执行了某个操作的用户才能算上去;这样的指标才有实际意义，运营人员要核心关注这类指标。 6.用户分群用户分群主要有两种分法：维度和行为组合。 第一种根据用户的维度进行分群，比如从地区维度分，有北京、上海、广州、杭州等地的用户;从用户登录平台进行分群，有PC端、平板端和手机移动端用户。 第二种根据用户行为组合进行分群，比如说每周在社区签到3次的用户与每周在社区签到少于3次的用户的区别. 7.公式法 将一切问题皆可量化，拆解成最小的维度，通过 +、-、*、/ 进行计算 8.用户细查用户行为数据是观察用户在你产品内的行为路径是一种非常直观的分析方法。 在用户分群的基础上，一般抽取3-5个用户进行细查，即可覆盖分群用户大部分行为规律。 绝大多数产品都或多或少存在一些反人类的设计或者BUG，通过用户细查可以很好地发现产品中存在的问题并且及时解决。 9.A/B测试与A/A测试 A/B测试是为了达到一个目标，采取了两套方案，一组用户采用A方案，一组用户采用B方案。通过实验观察两组方案的数据效果，判断两组方案的好坏。 说明： 在A/B测试方面，谷歌是不遗余力地尝试;对于搜索结果的显示，谷歌会制定多种不同的方案(包括文案标题，字体大小，颜色等等)，不断来优化搜索结果中广告的点击率。 这里需要注意的一点，A/B测试之前最好有A/A测试或者类似准备。什么是A/A测试?A/A测试是评估两个实验组是否是处于相同的水平，这样A/B测试才有意义。其实这和学校里面的控制变量法、实验组与对照组、双盲试验本质一样的。 10.假设法 假设-验证-判断。 当没有直观数据时， 以假设先行的方式进行推断。 说明： 例如： 如果商品提价后， 公司收益会不会变化？ 假设流量不会发生变化， 那么商品价格会影响转化率，确定转化率的下降。 计算日常的转化率， 针对不同的用户，如：忠诚用户、普通用户、羊毛用户， 预估各类别用户提价后的转化率变化。 11.指数法指定一个标准， 解决衡量的问题 线性加权： 反比例： 1-1/n， 范围为0-1 log指数法 热度公式： log(uv+ 5*评论,2) +(time -初始时间) / 10 参考资料： 数据分析的基本方法论]]></content>
      <categories>
        <category>数据分析方法</category>
      </categories>
      <tags>
        <tag>数据分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL面试题]]></title>
    <url>%2F2019%2F03%2F24%2F%E6%8A%80%E8%83%BD-Hive%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[结合两个表 问题描述： 表1：Preson Column Name Type PersonId int FirstName varchar LastName varchar 表2： Address Column Name Type AddressId int PersonId int City varchar State varchar 要求： 为Person表中的每个人提供以下信息，无论每个人都有一个地址：1FirstName, LastName, City, State 答案： 12345678SELECT Person.FirstName, Person.LastName, Address.City, Address.StateFROM Person LEFT join Address on Person.PersonId = Address.PersonId; 考查点： 使用 join 对两表进行连接查询。 取出排名第 2 高的数据 问题描述 表： Employee Id Salary 1 100 2 200 3 300 要求： 根据上面的 Employee 表，查询返回 薪水工资第二高的数据：200, 如果没有第二高的薪水， 返回Null。 SecondHighestSalary 200 答案 答案1 解法： 在除过第一名薪水中，找出最高的薪水，也就是第二名。 123456SELECT MAX(Salary) as SecondHighestSalaryFROM EmployeeWHERE Salary &lt; (SELECT MAX(Salary) FROM Employee); 答案2 解法： 跳过排名第一的数据， 并取出1条数据，即读取第2条数据。 123456789SELECT DISTINCT Salary as SecondHighestSalaryFROM Employeeorder by Salary DESC limit 1 offset 1-- 可缩写为limit 1,1 但上式写法错误， 因为如果表中没有第二薪水的话，那sql运行报错，而不是返回Null。 我们将其作为临时表可解决此问题： 12345678SELECT (SELECT DISTINCT Salary FROM Employeeorder by Salary DESClimit 1 offset 1) AS SecondHighestSalary 或者使用 IFNULL 1234567891011SELECT IFNULL( (SELECT DISTINCT Salary FROM Employeeorder by Salary DESClimit 1,1), NULL ) AS SecondHighestSalary 延伸 找出排名第三的薪水 1234567891011SELECT IFNULL( (SELECT DISTINCT Salary FROM Employeeorder by Salary DESClimit 2 offset 1), NULL ) AS SecondHighestSalary 对数据进行排序 问题： 表： Scores Id Score 1 3.50 2 3.65 3 4.00 4 3.85 5 4.00 6 3.65 要求： 对以下 Scores 表中的分数进行排名，如果两数相同，则有相同的排名， 排名相等的不会留下空位。 输出结果为： Score Rank 4.00 1 4.00 1 3.85 2 3.65 3 3.65 3 3.50 4 答案 答案1： 步骤1： 返回不同的成绩 1Select Distinct Score from Scores 步骤2： 统计并计算排名 1Select Count(1) + 1 From (Select Distinct Score from Scores) as uniqeScores where Score &gt; sc.Score 步骤3： 汇总 12345678910Select sc.Score, (Select Count(1) + 1 From ( Select Distinct Score from Scores) as uniqeScores where Score &gt; sc.Score) as rank From Scores sc Order by sc.Score Desc; 答案2： 123456select s1.Score, COUNT(DISTINCT s2.Score) Rankfrom Scores s1 inner join Scores s2 on s1.Score &lt;= s2.Scoregroup by s1.Idorder by s1.Score desc 答案3： 12345select Score, dense_rank() over(order by Score) as Rankfrom Scores 延伸 rank、dense_rank、 row_number 的区别 rank函数， 返回数据项在分组中的排名， 排名相等的会留下空位。 如1、2、2、4 dense_rank函数， 返回数据项在分组中的排名， 排名相等的不会留下空位。 如1、2、2、3 row_number函数， 返回数据项在分组中的排名， 排名不管数据是否相等。 如1、2、3、4 留存率 问题： 写出6月5-10号每日客户端活跃用户的次1日、次3日、次7日留存 答案 答案1：123456789101112131415161718192021222324with a1 as (select dt, user_accountfrom computerwhere dt between '2019-06-01' and '2019-06-17'),a2 as (select dt, user_accountfrom computerwhere dt between '2019-06-01' and '2019-06-17')select a1.dt,count(distinct a1.user_account) uv,count(distinct case when datediff(a2.dt, a1.dt) = 1 then a1.user_account else null end ) next_day,count(distinct case when datediff(a2.dt, a1.dt) = 3 then a1.user_account else null end ) three_day,count(distinct case when datediff(a2.dt, a1.dt) = 7 then a1.user_account else null end ) seven_dayfrom a1 join a2 on a1.user_account = a2.user_accountgroup by a1.dtorder by a1.dtlimit 100 输出结果为： 日期 uv 次1日 次3日 次7日 2019/6/1 50231 6578 6642 5154 2019/6/2 42000 6293 5027 4304 2019/6/3 44312 6760 8331 5042 2019/6/4 37852 5298 7133 0 2019/6/5 30678 6082 4648 0 2019/6/6 39405 8173 4972 0 2019/6/7 31267 5352 4920 0 2019/6/8 25614 4451 0 0 2019/6/9 24113 4568 0 0 2019/6/10 26242 0 0 0 答案2：步骤1：1234567891011SELECT dt, count(distinct user_account) as uvFROM computerWHERE dt between '2019-06-01' and '2019-06-17'group BY dtorder BY dt 步骤2：123456789101112131415161718192021222324252627282930-- 统计10-15号每天的次日留存数， 统计次3、7日留存只需将1换为3、7with a1 as ( select user_account, dt from computer where dt between '2019-06-01' and '2019-06-17'),a2 as ( select user_account, dt from computer_view.client_android_log_view where dt between '2019-06-01' and '2019-06-17')select a1.dt, count(distinct a1.user_account) as uvfrom a1 join a2 on a1.user_account = a2.user_accountWHERE a2.dt = date_add(a1.dt, 1) group by a1.dtorder BY a1.dt 步骤3：1留存率 = 用步骤2结果/ 步骤1 结果 连续出现三次的数字 问题： 查找出连续出现至少三次的所有数字 表 Logs 如下： Id Num 1 1 2 1 3 1 4 2 5 1 6 2 7 2 得到如下结果： ConsecutiveNums 1 答案 答案1： 12345678910select distinct a1.Num as ConsecutiveNumsfrom Logs as a1left join Logs as a2 on a1.Id = a2.Id-1left join Logs as a3 on a1.Id = a3.Id -2where a1.Num = a2.Num and a2.Num = a3.Num 答案2： 1234567891011121314select distinct a1.Num as ConsecutiveNumsfrom Logs a1, Logs a2, Logs a3where a1.Id = a2.Id -1 and a2.Id = a3.Id -1 and a1.Num = a2.Num and a2.Num = a3.Num 答案3：1234567891011121314---连续 N 次出现， 则将 3 改为 N 即可。SELECT distinct num as ConsecutiveNumsFROM(SELECT id, num, @pre := @cur, @cur := num, @rep_ct := IF(@pre = @cur, @rep_ct + 1, 1) as rep_ctFROM `Logs` l, (SELECT @pre := null, @cur := 0, @rep_ct := 1) init) temp WHERE rep_ct &gt;= 3 连续 4 个月活跃的用户明细 问题：求出 1-4 月每月连续登陆客户端的用户数 思路 将用户登录的月份按从小到大排序， 找出排序等于 4 的用户 答案 1234567891011121314151617181920212223242526with a1 as(select id, month(dt) as monthfrom datawhere dt between '2019-01-01' and '2019-04-30'group by id, month(dt) ),a2 as ( select id, a1.month, row_number() over(partition by id order by a1.month) as numfrom a1) select count(distinct id) as uvfrom a2where a2.num= 4 查询比经理薪资高的员工姓名 问题 表：Employee 包含员工和经理的Id 与薪水 Id Name Salary ManagerId 1 Joe 70000 3 2 Henry 80000 4 3 Sam 60000 NULL 4 Max 90000 NULL 要求： 查找收入高于经理的员工，得到如下结果： Employee Joe 前3列 来自a1, 后两列来自a2 答案 答案1： 利用 join 对表进行合并前3列 来自a1, 后两列来自a2 Name Salary ManagerId Id Salary Joe 70000 3 3 60000 Henry 80000 4 4 90000 1234567select a1.name as Employeefrom Employee as a1 join employee as a2 on a1.ManagerId = a2.Idwhere a1.Salary &gt; a2.Salary 答案2： 123456789101112131415161718with a1 as ( select name,salary, ManagerId from Employee),a2 as ( select managerid, Id from Employee)select a1.namefrom a1 join a2 on a1.ManagerId = a2.Idwhere a1.Salary &gt; a2.Salary 答案3： 步骤1： 12SELECT *FROM Employee AS a1, Employee AS a2 此步骤输出结果为： 结果将获得这两个标的笛卡尔积，输出结果将使 4*4 = 16条记录， 我们对输出结果进行过滤。 12345678SELECT a.Name AS 'Employee'FROM Employee AS a, Employee AS bWHERE a.ManagerId = b.Id AND a.Salary &gt; b.Salary 找出重复邮件 问题 表： Person Id Email 1 a@b.com 2 c@d.com 3 a@b.com 要求： 找出Person 表中所有重复电子邮件，得到如下结果： Email a@b.com 答案 答案1： 123456789101112select a1.Emailfrom(select Email, count(Email) as numfrom Persongroup by Email) as a1where a1.num !=1 答案2： 12345678select Emailfrom Persongroup by Emailhaving count(Email) !=1 5月中连续7天登陆的用户数 问题:根据用户登录表 data，取出连续登录了K天的用户uid id dt A 2019-06-01 B 2019-06-03 B 2019-06-04 B 2019-06-05 B 2019-06-06 C 2019-06-05 C 2019-06-06 C 2019-06-07 答案： 将用户按照电话号进行排序 id dt num A 2019-05-01 1 B 2019-05-03 1 B 2019-05-04 2 B 2019-05-05 3 B 2019-05-06 4 C 2019-05-05 1 C 2019-05-06 2 C 2019-05-07 3 1234567891011select id, dt, row_number() over(partition by id order by dt) as numfrom Datawhere dt between '2019-05-01' and '2019-05-07'group by id, dt 将日期与排序进行相减 id dt num diff A 2019-05-01 1 2019-04-30 B 2019-05-03 1 2019-05-02 B 2019-05-04 2 2019-05-02 B 2019-05-05 3 2019-05-02 B 2019-05-06 4 2019-05-02 C 2019-05-05 1 2019-05-04 C 2019-05-06 2 2019-05-04 C 2019-05-07 3 2019-05-04 12345678910111213141516171819202122232425with a1 as ( select id, dt, row_number() over(partition by id order by dt) as num from computer_view.client_android_log_view where dt between '2019-06-01' and '2019-06-03' group by id, dt)select id, dt, num, (DATE_SUB(dt, num )) as diff from a1group by id, dt, numlimit 100 统计差值相同的数字个数，并大于等于3 1234567891011121314151617181920212223242526272829303132333435with a1 as ( select user_account, hit_date, row_number() over(partition by user_account order by hit_date) as num from computer_view.client_android_log_view where hit_date between '2019-06-01' and '2019-06-05' group by user_account, hit_date),a2 as (select user_account, hit_date, num, (DATE_SUB(hit_date, num )) as diff from a1group by user_account, hit_date, num)select diff, max(num), count(distinct user_account)from a2group by diffhaving max(num) &gt;= 1limit 100 找出连续登录4天以上的用户数 123456789101112131415161718192021222324252627282930313233343536with a1 as ( select id, dt, row_number() over(partition by id order by dt) as num from computer_view.client_android_log_view where dt between '2019-06-01' and '2019-06-05' group by id, dt),a2 as (select id, dt, num, (DATE_SUB(dt, num )) as diff from a1group by id, dt, num)select id, diff, count(diff) from a2group by id, diff having count(diff) &gt;= 4limit 100 id diff count(diff) B 2019-05-02 4 C 2019-05-04 3 求连续任意天数的用户数 sql分三层第一层：根据条件查询一个时间区间的数据 cha_day 统一计算出一个时间差，然后和当前行数相减。连续的天数和行数相减，结果是一样的第二层：分组求出每个用户的连续天数， rows:排序找出一个用户最大连续天数第三层：连续天数分组，求出人数。 分组天数总人数，应该等于总人数 1234567891011121314151617181920212223242526272829303132333435363738select lx_day, count(user_account)from( select user_account, cha_day, count(cha_day) as lx_day, row_number() over(partition by user_account order by count(cha_day) desc) as rows from ( select datediff(hit_date,'2000-01-01')-row_number() over(partition by user_account order by hit_date) as cha_day, hit_date, user_account from apache_computer_view.client_ios_log where hit_date between '2019-10-15' and '2019-10-20' and nbtn_name = '签到有礼' group by hit_date, user_account )v group by user_account, cha_day)vwhere rows = 1group by lx_dayorder by lx_daylimit 1000 找出未订购任何内容的用户 问题： 表： Customers Id Name 1 Joe 2 Henry 3 Sam 4 Max 表： Orders Id CustomerId 1 3 2 1 要求： 根据上面两个表，找出从未订购任何内容的所有客户。输出结果如下： Customers Henry Max 答案 答案1： 123456SELECT Name as CustomersFROM Customers left JOIN Orders on Customers.Id = Orders.CustomerIdwhere Orders.CustomerId is NULL 答案2： 12345678910select customers.name as Customersfrom customerswhere customers.Id not in (select CustomerId from Orders) 找出各部门薪水最高的员工 问题： 表： Employee Id Name Salary DepartmentId 1 Joe 70000 1 2 Jim 90000 1 3 Henry 80000 2 4 Sam 60000 2 5 Max 90000 1 表： Department Id Name 1 IT 2 Sales 要求：找出各部门薪水最高的员工 Department Employee Salary IT Max 90000 IT Jim 90000 Sales Henry 80000 答案 步骤1： 查出各部门最高薪水 1234567SELECT DepartmentId, MAX(Salary)from Employeegroup by DepartmentId 步骤2： 12345678910111213141516171819selectEmployee.Name as Department,Department.Name as Employee,Salary from Employee join Department on Employee.DepartmentId= Department.Idwhere ((Employee.DepartmentId, Salary) in (SELECT DepartmentId, MAX(Salary)from Employeegroup by DepartmentId))group by Department,Employee,Salary 获取每个部门中薪水前三名的员工 问题： 表：Employee Id Name Salary DepartmentId 1 Joe 85000 1 2 Henry 80000 2 3 Sam 60000 2 4 Max 90000 1 5 Janet 69000 1 6 Randy 85000 1 7 Will 70000 1 表： Department Id Name 1 IT 2 Sales 要求： 找出各部门薪水前三的员工， 输出结果如下： Department Employee Salary IT Max 90000 IT Randy 85000 IT Joe 85000 IT Will 70000 Sales Henry 80000 Sales Sam 60000 答案 步骤1：对各部门薪水进行排序 合并12345678910select Employee.Name AS Employee, Employee.Salary AS Salary, Department.Name AS Department from Employee join Department on Employee.DepartmentId = Department.Id group by Employee, Salary, Department Employee Salary Department Joe 85000 IT Henry 80000 Sales Sam 60000 Sales Max 90000 IT Janet 69000 IT Randy 85000 IT Will 70000 IT 步骤2 ： 找出排名前三的 思路： 再添加一张Employee 表，与步骤1中的 A 表进行对比， 令 B 表中的 salary 大于 A 表中的 salary 条件限制：B表中 salary 大于 A 表中salary 的个数小于3 123456789101112131415select A.Name AS Employee, A.Salary AS Salary, Department.Name AS Department from Employee as A join Department on A.DepartmentId = Department.Id WHERE (select count(distinct B.Salary) from Employee as B WHERE B.Salary &gt; A.Salary and B.DepartmentId = A.DepartmentId) &lt;3 sql题 学生-课程-成绩案例 内容：表： student id name 1 zy 2 hz 3 zy 4 lx 5 lx 表： course id name 1 match 2 python 3 java 表: student_course sid cid score 1 1 60 1 2 50 2 2 80 4 3 90 2 2 80 3 3 50 问题 问题1： 查询 student表中重名的学生， 结果包含id 和name, 按 name 升序 12345678910select name, idfrom studentwhere name in (select name from student group by name having count(name) &gt; 1)order by name 问题2： 查询 student_course 表中的平均份不及格的学生， 列出学生的 id 和平均分 123456789select sid, avg(score) as avg_scorefrom student_coursegroup by sidhaving avg_score &lt; 60 问题3： 查询每门课成绩都不低于80的学生id 123456789101112select distinct sidfrom student_coursewhere sid not in (select score from student_course where score &lt;80) 问题4： 查询每个学生的总成绩，列出学生名称和总成绩 12345select student.name, sum(student_course.score)from student left join student_course on student.id = student_course.sid 问题5：查出总成绩最高的学生 123456789select sid, sum(score)from student_coursegroup by sidorder by sum(score) desclimit 1; 问题6： 查询课程1,成绩第二高的学生 方法1：123456789101112---在除过第一高的成绩中，找出最高的成绩select cid, max(score)from stuent_scorewhere cid =1 and score &lt; (select max(score) from student_score) 方法2： 12345678910111213---跳过排名第一的数据， 取1条数据select max(score)from stuent_scorewhere cid = 1 group by score order by score desc limit 1 offset 1 --limit 1,1 问题7： 查看各科成绩最高的学生id与课程id 1234567891011121314select cid, sid, scorefrom student_course as a1where score &gt;= (select max(score) from stuent_score as a2 where a1.id = ax.id) 错误写法： 12345678select sid, cid, max(score)from student_scoregroup by cid 问题8： 在student_course 表中查询每门课的前2名，结果按照课程id 升序， 同一课程按照成绩降序。 123456789101112131415select *from student_course xwhere 2 &gt;( select count(*) from student_course y where y.cid = x.cid and y.score &gt; x.score)order by cid, score DESC 对每季度数据进行汇总 问题： 表： sales 年 季度 销售 1991 1 11 1991 2 12 1991 3 13 1991 4 14 1992 1 21 1992 2 22 1992 3 23 1992 4 24 要求： 通过 SQL 语句显示以下结果： 年 一季度 二季度 三季度 四季度 1991 11 12 13 14 1992 21 22 23 24 答案： 123456select 年, sum(case when 季度=1 then 销售量 else 0 end) as 一季度, sum(case when 季度=2 then 销售量 else 0 end) as 二季度, sum(case when 季度=3 then 销售量 else 0 end) as 三季度, sum(case when 季度=4 then 销售量 else 0 end) as 四季度 from sales group by 年 解释 lateral view 函数 描述： lateral view 用于和 split、explode、collect_set 函数 等一起使用， 能够将一行数据拆成多行数据，在此基础上对拆分后的数据进行聚合。 问题1：将 表 table 中的 adid_list 转换为单独的行。 表： table pageid adid_list front_page [1,2,3] contact_page [3,4] 答案： 12345SELECT pageid, adidFROM tablelateral view explode(adid_list) adTable as adid 输出结果为： pageid adid_list front_page 1 front_page 2 front_page 3 contact_page 3 contact_page 4 问题2：要求： 计算特定广告的展现次数 答案： 1234567SELECT adid, count(1)FROM tablelateral view explode(adid_list) adTable as adidGROUP BY adid 输出结果为： adid count(1) 1 1 2 1 3 2 4 1 问题3： 多个 lateral view 查询 表： table2 array col2 [1,2] [“a”，”b”] [3,4] [“c”, “d”] 答案： 123456SELECT myCol1, myCol2FROM baseTableLATERAL VIEW explode(col1) myTable1 AS myCol1LATERAL VIEW explode(col2) myTable2 AS myCol2 输出结果为： myCol1 myCol2 1 “a” 1 “b” 2 “a” 2 “b” 3 “c” 3 “d” 4 “c” 4 “d” 删除重复的电子邮箱 问题 表：Person Id Email 1 zhang@qq.com 2 yu@gmailc.om 3 zhang@qq.com 要求: 删除 Person 表中所有重复的电子邮箱，只保留 Id 最小的那个。 Id Email 1 zhang@qq.com 2 yu@gmailc.om 答案： 答案1： 步骤1：找出 Id 大的重复邮箱 1234567select a1.*from Person a1 join Person a2 on a1.Email = a2. Emailwhere a1. Id &gt; a2.Id 步骤2： 删除 Id 较大的重复邮箱。 123456DELETE a1FROM Person a1 join Person a2 on a1.Email = a2. Emailwhere a1. Id &gt; a2.Id 答案2： 123456DELETE a1FROM Person a1, Person a2 where a1.Email = a2. Email and a1. Id &gt; a2.Id 上升的温度 问题 表： Weather Id(INT) RecordDate(DATE) Temperature(INT) 1 2015-01-01 10 2 2015-01-02 25 3 2015-01-03 20 4 2015-01-04 30 要求：查找与昨天日期相比温度更高的所有日期的 Id, 返回结果如下： Id 2 4 答案： 答案1： datediff 函数 123456SELECT a1.Idfrom Weather a1 join Weather a2 on datediff(a1.RecordDate, a2.RecordDate) = 1 and a1.Temperature &gt; a2.Temperature 答案2： ADDDATE 函数 123456SELECT a1.Idfrom Weather a1 join Weather a2 on a1.RecordDate= date_add(a2.RecordDate,1) and a1.Temperature &gt; a2.Temperature 游戏玩家分析1此表显示某些游戏玩家的活动。每一行都是某天用某些设备登陆并玩多个游戏的玩家记录。 表： Activity player_id device_id event_date games_played 1 2 2016-03-01 5 1 2 2016-05-02 6 2 3 2017-06-25 1 3 1 2016-03-02 0 3 4 2018-07-03 5 要求： 显示每个玩家的第一次登陆日期， 输出如下结果 player_id first_login 1 2016-03-01 2 2017-06-25 3 2016-03-02 答案： 123SELECT a1.player_id, a1.event_date as first_loginFROM activity a1 left join activity a2 on a1.player_id=a2.player_id and a1.event_date&gt;a2.event_dateWHERE a2.event_date is NULL 12345678910select player_id, to_char(event_date, 'yyyy-mm-dd') as first_loginfrom (select player_id, event_date, row_number() over (partition by player_id order by event_date asc) rn from Activity)where rn = 1 https://codeday.me/bug/20190309/737795.html 游戏玩家分析2表： Activity player_id device_id event_date games_played 1 2 2016-03-01 5 1 2 2016-05-02 6 2 3 2017-06-25 1 3 1 2016-03-02 0 3 4 2018-07-03 5 要求： 写取出每个玩家第一次玩游戏的设备号 输出结果如下： player_id device_id 1 2 2 3 3 1 答案： 123456789SELECT a1.player_id, a1.device_idFROM activity a1 left join activity a2 on a1.player_id=a2.player_id and a1.event_date&gt;a2.event_dateWHERE a2.event_date is NULL 12345678select player_id, device_id from ( select * from Activity where (player_id,event_date) in (select player_id, min(event_date) from Activity group by player_id) ) as t 123456789select player_id, device_idfrom (select player_id, device_id, row_number() over(partition by player_id order by event_date asc) rn from Activity)where rn = 1 游戏分析3表：Activity player_id device_id event_date games_played 1 2 2016-03-01 5 1 2 2016-05-02 6 1 3 2017-06-25 1 3 1 2016-03-02 0 3 4 2018-07-03 5 要求： 取出每个玩家在不同日期下的累积玩游戏次数。 例如： 玩家 id 为 1 的玩家， 在 2016-05-02 时，玩游戏的总次数为 5+6=11， 在2017-06-25 时，玩游戏的总次数为 5+6+1=12。 输出结果如下： player_id event_date games_played_so_far 1 2016-03-01 5 1 2016-05-02 11 1 2017-06-25 12 3 2016-03-02 0 3 2018-07-03 5 答案： 12345select player_id, to_char(event_date, 'yyyy-mm-dd') as event_date, sum(games_played) over(partition by player_id order by event_date) games_played_so_farfrom activity 1select a.player_id ,a.event_date,(case when @player_id=a.player_id then @value:=@value+a.games_played when @player_id:=a.player_id then @value:=a.games_played end ) as games_played_so_far from (select * from Activity order by player_id,event_date) a, (select @player_id:=Null,@value:=0)s 游戏分析4表： Activity player_id device_id event_date games_played 1 2 2016-03-01 5 1 2 2016-03-02 6 2 3 2017-06-25 1 3 1 2016-03-02 0 3 4 2018-07-03 5 要求： 查询在首次登陆后第二天再次登陆的玩家比例， 四舍五入到小数点后两位。 换句话说： 你需要计算从首次登陆日期开始至少连续两天登陆的玩家数量， 然后将该数量除以玩家总数。 输出结果如下： fraction 0.33 12345678--- 错误select CAST( count(b.player_id) / count(distinct a.player_id) as decimal(38, 2)) as fractionfrom Activity as aleft join Activity as b on a.player_id = b.player_id and a.event_date = b.event_date+1 123456789101112131415select round(count(if(datediff(a2.event_date ,a1.event_date )=1,1,null))/count(distinct a1.player_id ),2) as fractionfrom Activity a1, Activity a2where a1.player_id =a2.player_id and (a1.player_id,a1.event_date) in ( select player_id , min(event_date) event_date from Activity a3 group by player_id ) 求中位数表： Employee Id Company Salary 1 A 2341 2 A 341 3 A 15 4 A 15314 5 A 451 6 A 513 7 B 15 8 B 13 9 B 1154 10 B 1345 11 B 1221 12 B 234 13 C 2345 14 C 2645 15 C 2645 16 C 2652 17 C 65 要求：查找每个公司的薪水中位数 Id Company Salary 5 A 451 6 A 513 12 B 234 9 B 1154 14 C 2645 答案：https://www.cnblogs.com/jxlwqq/p/5868206.htmlhttps://www.oschina.net/translate/how-to-calculate-median-value-in-mysql-using-a-simple-sql-query 进行排序123456789select Id, Company, Salary, ROW_NUMBER ( ) OVER (PARTITION BY Company order by Salary) as rank_name, count(1) over (partition by company) as numfrom Employee Id Company Salary rank_name num 3 A 15 1 6 2 A 341 2 6 5 A 451 3 6 6 A 513 4 6 1 A 2341 5 6 4 A 15314 6 6 8 B 13 1 6 7 B 15 2 6 12 B 234 3 6 9 B 1154 4 6 11 B 1221 5 6 10 B 1345 6 6 17 C 65 1 6 13 C 2345 2 6 14 C 2645 3 6 15 C 2645 4 6 16 C 2652 5 6 找到中位数 12345678910select id, company, salaryfrom (select id, company, salary, row_number() over (partition by company order by salary) as rank_name, count(1) over (partition by company) as num from employee )where abs(rank_name - (num+1)/2) &lt; 1 -- 顺序编号在公司薪水记录数中间的，即为中位数 查找至少有5名直接下属的经理表：Employee Id Name Department ManagerId 101 John A null 102 Dan A 101 103 James A 101 104 Amy A 101 105 Anne A 101 106 Ron B 101 要求： 查询来查找至少有5名直接下属的经理 输出结果为： Name John 答案： 123456789select a2.Namefrom Employee a1 join Employee a2on a1.ManagerId = a2.Idgroup by a1.ManagerIdhaving count(*) &gt;=5 给定数字的频率查中位数表： Numbers Number Frequency 0 7 1 1 2 3 3 1 要求： 数字为 0, 0, 0, 0, 0, 0, 0, 1, 2, 2, 2, 3，所以中位数是 (0 + 0) / 2 = 0，输出结果如下 median 0.0000 答案： 1234567891011121314151617181920select avg(n2.number) medianfrom (select min(n.number) numberfrom (select number, frequency, (@cumsum:=@cumsum+frequency) 'cumsum'from numbers ,(select @cumsum:=0) temp order by number) nwhere n.cumsum &gt;= (floor(((SELECT SUM(frequency) FROM numbers) +1 ) / 2))union select min(n1.number) numberfrom (select number, frequency, (@cumsum1:=@cumsum1+frequency) 'cumsum'from numbers ,(select @cumsum1:=0) temp order by number) n1where n1.cumsum &gt;= (ceil(((SELECT SUM(frequency) FROM numbers) +1 ) / 2))) n2; 找出当选最多的人名称表： Candidate id Name 1 A 2 B 3 C 4 D 5 E 表： Vote id CandidateId 1 2 2 4 3 3 4 2 5 5 表 Candidate 为候选人名称表， 表 Vote 中CandidateId 是 Candidate表中的 id。 要求： 找出当选者的名称，返回结果为当选者B。输出结果如下：| Name ||——|| B | 答案：12345678910111213141516select Namefrom Candidatewhere id = ( select CandidateId from Vote group by CandidateId order by count(*) DESC LIMIT 1 ) 选出所有 bonus &lt; 1000的员工的 name 以及 bonus表：Employee empId name supervisor salary 1 John 3 1000 2 Dan 3 2000 3 Brad null 4000 4 Thomas 3 4000 表：Bonus empId bonus 2 500 4 2000 要求： 选出所有 bonus &lt; 1000的员工的 name 以及 bonus。输出结果如下 name bonus John null Dan 500 Brad null 答案： 123456789select a1.name, a2.bonusfrom Employee as a1 left join Bonus as a2 on a1.empid = a2.empid where ifnull (bonus, 0) &lt; 1000 12345678910select a1.name, a2.bonusfrom Employee as a1 left join Bonus as a2 on a1.empid = a2.empid where nvl (bonus, 0) &lt; 1000 谁有最多的好友表： request_accepted 表中存储了所有好友申请通过的数据记录，其中，requester_id 和 accepter_id 都是用户的编号。 requester_id accepter_id accept_date 1 2 2016_06-03 1 3 2016-06-08 2 3 2016-06-08 3 4 2016-06-09 要求： 求出谁拥有最多的好友和他拥有的好友数目。输出结果如下 id num 3 3 答案： 1234567891011121314select id as id, ucnt as numfrom( select id, count(1) as ucnt from ( select requester_id as id from request_accepted union all select accepter_id as id from request_accepted ) group by id order by ucnt desc)where rownum = 1 找出人流量的高峰期表：stadium id visit_date people 1 2017-01-01 10 2 2017-01-02 109 3 2017-01-03 150 4 2017-01-04 99 5 2017-01-05 145 6 2017-01-06 1455 7 2017-01-07 199 8 2017-01-08 188 要求： 找出人流量的高峰期。高峰期时， 至少连续三行记录中的人流量不少于100。得出结果如下 id visit_date people 5 2017-01-05 145 6 2017-01-06 1455 7 2017-01-07 199 8 2017-01-08 188 答案： 1234567SELECT distinct a.*FROM stadium as a,stadium as b,stadium as cwhere ((a.id = b.id-1 and b.id+1 = c.id) or (a.id-1 = b.id and a.id+1 = c.id) or (a.id-1 = c.id and c.id-1 = b.id)) and (a.people&gt;=100 and b.people&gt;=100 and c.people&gt;=100)order by a.id; 12345678910111213141516select id, to_char(visit_date, 'yyyy-mm-dd') as visit_date, peoplefrom (select id, visit_date, people, count(1) over (partition by offset) cnt from (select id, visit_date, people, (row_number() over (order by id) - id) offset from stadium where people &gt;= 100 ) )where cnt &gt;= 3 -- 连续 3 天（及以上）order by id 预约连续空余座位表：cinema seat_id free 1 1 2 0 3 1 4 1 5 1 要求：获取所有空余座位，并将它们按照 seat_id 排序。输出结果如下 连续空余座位的定义是大于等于 2 个连续空余的座位。1 表示空余，0 表示已被占据。 seat_id 3 4 5 答案： 1234567891011121314151617181920select seat_idfrom(select seat_id, count(1) over (partition by num) as cumfrom( select seat_id, (row_number() over (order by seat_id) - seat_id) as numfrom cinemawhere free = 1))where cum &gt;= 2order by seat_id 找出符合条件的电影表：cinema id movie description rating 1 War great 3D 8.9 2 Science fiction 8.5 3 irish boring 6.2 4 Ice song Fantacy 8.6 5 House card Interesting 9.1 要求： 找出所有影片描述为非 boring (不无聊) 的并且 id 为奇数 的影片，结果请按等级 rating 排列。输出结果如下 id movie description rating 5 House card Interesting 9.1 1 War great 3D 8.9 答案1：12345678910select *from cinemawhere mod(id, 2) = 1 and description != 'boring'order by rating DESC 答案2：12345678910select *from cinemawhere description != 'boring' and id % 2 !=0order by rating DESC 表：Sales sale_id product_id year quantity price 1 100 2008 10 5000 2 100 2009 12 5000 7 200 2011 15 9000 表：Product product_id product_name 100 Nokia 200 Apple 300 Samsung 要求： 编写sql查询， 选择每个销售产品的第一年的数据， 输出结果如下 product_id first_year quantity price 100 2008 10 5000 200 2011 15 9000 答案：123456789101112131415select product_id, year as first_year, quantity, pricefrom ( select product_id, year, quantity,price, rank() over(partition by product_id order by year) rn from sales)where rn=1 找到购买所有产品的顾客表1： customer customer_id product_key 1 5 2 6 3 5 3 6 1 6 表2： product | product_key |+————-+| 5 || 6 | 要求： 找出从 customer 表中购买了 product 表所有产品的客户id。 输出结果如下 customer_id 1 3 答案：123456789101112select customer_idfrom customergroup by customer_idhaving count(distinct product_key) = (select count(distinct product_key) from product ) 12345678910111213141516select customer_idfrom (select customer_id, count(distinct product_key) as num from customer group by customer_id) as a1join ( select count(product_key) as num from product) as a2on a1.num = a2.num 查询关注者的关注数据表：follow followee (博主) follower(关注者) A B B C B D D E 要求： 查询每个关注者， 被多少人关注。 输出结果如下： follower num B 2 D 1 B 和 D 都在在 follower 字段中出现，作为博主，B 被 C 和 D 关注，D 被 E 关注。A 不在 follower 字段内，所以A不在输出列表中。 答案： 123456789101112select f1.follower, count(distinct f2.follower) as numfrom follow f1inner join follow f2 on f1.follower = f2.followeegroup by f1.followerorder by f1.follower 如何用python操作mysql步骤 安装 mysql-connector 1pip install mysql-connector 连接数据库 通过 connection 对数据库的连接进行管理， 通过 cursor 创建游标对数据库中的数据进行操作。 12345678910111213import mysql.connector# 创建数据库连接db = mysql.connector.connect( host='ip地址', user = "root", passwd = "1234", # 数据库密码 database = 'default', # 连接的数据库 auth_plugin = 'mysql_native_password" )# 获取操作游标cursor = db.cursor() 编写sql语句 123456789# 输出sql 语句sql = """select btn_namefrom cinemawhere hit_date = "2019-07-26" """ 执行sql语句并返回结果 1234567891011121314# 执行sql语句cursor.execute(sql)# 获取数据集中的所有行cursor.fetchall()# 获取数据中的第一行# cursor.fetchone()# 获取数据集中的n条数据# cursor.fetchmany(n)# 返回数据集中中的行数# cursor.rowcount 关闭游标和数据库连接 12345# 关闭游标cursor.close()# 关闭数据连接db.close() 延伸： 捕获异常信息。 在对数据进行增加、删除和修改时， 可能会出现异常，需要对异常数据进行捕获。 123456789101112131415161718import tracebacktry: sql = """INSER INTO player (team_id, player_name, height) VALUES (%s, %s, %s)""" val = (1000, "zhangyu", 1.95) # 执行sql语句 cursor.execute(sql, val) # 进行提交 db.commit() print(cursor.rowcount, "记录插入成功。")except Exception as e: # 打印异常信息 traceback.print_exc() # 回滚 db.rollback()finally: # 关闭数据库连接 db.close() 参考资料： 极客时间-sql必知必会 求出每个项目中经验最丰富的员工表：Project table project_id employee_id 1 1 1 2 1 3 2 1 2 4 表：Employee table employee_id name experience_years 1 Khaled 3 2 Ali 2 3 John 3 4 Doe 2 要求： 求出每个项目中经验最丰富的员工， 输出结果如下 ID为1和3的员工，在第一个项目中拥有最丰富的经验， 对于第二个项目， ID为1的员工拥有最丰富的经验 project_id employee_id 1 1 1 3 2 1 答案： 1234567891011select project_id, employee_idfrom (select p.project_id, e.employee_id, rank() over(partition by p.project_id order by e.experience_years desc) rn from project p, employee e where p.employee_id = e.employee_id)where rn = 1 求所有员工的平均工作经验，保留2位小数。表： Project project_id employee_id 1 1 1 2 1 3 2 1 2 4 +————-+————-+ 表：Employee employee_id name experience_years 1 Khaled 3 2 Ali 2 3 John 1 4 Doe 2 要求： 求每个部门所有员工的平均工作年限， 保留两位小数。输出结果如下 第一个项目的平均工作年限为（3+2+1）/ 3 = 2.00第二个项目的平均工作年限为（3+2）/ 2 = 2.50 project_id average_years 1 2.00 2 2.50 答案1：123456789select project_id, round(avg(experience_years),2) as average_yearsfrom Project, Employeewhere Project.employee_id = Employee.employee_idgroup by project_id 查询每个专业的学生人数 一所大学有 2 个数据表，分别是 student 和 department ，这两个表保存着每个专业的学生数据和院系数据。 表：student student_id student_name gender dept_id 1 Jack M 1 2 Jane F 1 3 Mark M 2 表：department dept_id dept_name 1 Engineering 2 Science 3 Law 要求： 查询 department 表中每个专业的学生人数 （即使没有学生的专业也需列出）。将你的查询结果按照学生人数降序排列。 如果有两个或两个以上专业有相同的学生数目，将这些部门按照部门名字的字典序从小到大排列。输出结果如下 dept_name student_number Engineering 2 Science 1 Law 0 答案1： 1234567891011SELECT a1.dept_name, COUNT(student_id) AS student_number FROM department a1 LEFT JOIN student a2 ON a1.dept_id = a2.dept_id GROUP BY a1.dept_nameORDER BY student_number DESC, a1.dept_name 答案2：12345678910111213141516select dept_name, (case when student_num is null then 0 else student_num end) student_numberfrom(select dept_id, count(*) student_numfrom studentgroup by dept_id) t1right join department t2 on t1.dept_id=t2.dept_idorder by student_number desc, dept_name asc 表：salesperson 表 salesperson 存储了所有销售员的信息。每个销售员都有一个销售员编号 sales_id 和他的名字 name 。 sales_id name salary commission_rate hire_date 1 John 100000 6 4/1/2006 2 Amy 120000 5 5/1/2010 3 Mark 65000 12 12/25/2008 4 Pam 25000 25 1/1/2005 5 Alex 50000 10 2/3/2007 表：company 表 company 存储了所有公司的信息。每个公司都有一个公司编号 com_id 和它的名字 name 。 com_id name city 1 RED Boston 2 ORANGE New York 3 YELLOW Boston 4 GREEN Austin 表： orders 表 orders 存储了所有的销售数据，包括销售员编号 sales_id 和公司编号 com_id 。| order_id | order_date | com_id | sales_id | amount ||———-|————|———|———-|——–|| 1 | 1/1/2014 | 3 | 4 | 100000 || 2 | 2/1/2014 | 4 | 5 | 5000 || 3 | 3/1/2014 | 1 | 1 | 50000 || 4 | 4/1/2014 | 1 | 4 | 25000 | 要求： 根据给定的三个表，salesperson， company， orders。输出所有表 salesperson 中，没有向公司 ‘RED’ 销售任何东西的销售员。 根据表 orders 中的订单 ‘3’ 和 ‘4’ ，容易看出只有 ‘John’ 和 ‘Pam’ 两个销售员曾经向公司 ‘RED’ 销售过。所以我们需要输出表 salesperson 中所有其他人的名字。 输出： name Amy Mark Alex 答案1： 1234567891011121314SELECT a1.nameFROM salesperson a1 LEFT JOIN orders a2 ON a1.sales_id = a2.sales_id LEFT JOIN company a3 ON a2.com_id = a3.com_idGROUP BY a1.nameHAVING SUM(IF(a3.name = 'RED', 1, 0)) = 0ORDER BY a1.sales_id 答案2： 12345678910111213select a1.namefrom salesperson a1where not exists (select * from orders a2 join company a3 on a2.com_id=a3.com_id where a3.name='RED' and a1.sales_id=a2.sales_id) 答案3：123456789101112SELECT name FROM salesperson WHERE sales_id not in (SELECT DISTINCT a1.sales_id FROM orders a1 LEFT JOIN company a2 ON a1.com_id = a2.com_id WHERE a2.name = 'RED') LeetCodeAnimation https://github.com/MisterBooo/LeetCodeAnimation leetcode 题解 https://github.com/azl397985856/leetcode LeetCode所有题目 http://leetcode.liangjiateng.cn/leetcode/game-play-analysis-ii/description SQL语句数据分析面试必备 https://mp.weixin.qq.com/s/ol-jheA3TTv0qqtFtEt_ow]]></content>
      <categories>
        <category>数据分析技能</category>
      </categories>
      <tags>
        <tag>Hive</tag>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常见的分析思维模型]]></title>
    <url>%2F2019%2F02%2F26%2F%E6%96%B9%E6%B3%95-%E5%B8%B8%E8%A7%81%E7%9A%84%E5%88%86%E6%9E%90%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[分析思维模型 使用频率按顺序排列 1.AARRR 模型 2.基于用户生命周期的数据分析体系 对应的关键指标 3. 5W2H 分析法 什么原因 (why) 导致 什么事情 (what), 需要哪些人 (who) 在什么时间完成 (when),在什么地点 (where) 用什么方法 (how)完成, 预算是多少 (how much)? 4. 象限法 通过象限法， 找到问题的共同原因， 从而建立分组优化策略。 内外因素分解法 用户分群 RFM 用户分群 5. 二八法则 / 帕累托法则 将对象分为重要和不重要两类， 20%的用户贡献了80%的销售额。 数据中， 20% 的变量将直接产生 80% 的效果，数据分析应该围绕这20%的变量来进行。 和业务和KPI紧密相关，花费很少的精力就能达到不错的效果。 在条件允许的状况下， 依旧不能放弃全局，否则会让思维变得狭隘。补充： 升级版本： ABC 分析法 与之对应： 长尾理论 6. SWOT方法指定发展战略前，对自身进行全面的分析及竞争优势定位。 对自己进行解析 指定相应的对策 7.麦肯锡七步分析法 界定问题 将问题分解成议题 去除不重要的议题（优先排序） 制定详细工作计划 分析重要议题 汇总研究成果 准备你的故事 8.SMART原则 意义：人们在制定工作目标或者任务目标时，考虑一下目标与计划是不是SMART化的。只有具备SMART化的计划才是具有良好可实施性的，也才能指导保证计划得以实现。 说明： S代表具体(Specific)，指绩效考核要切中特定的工作指标，不能笼统； M代表可度量(Measurable)，指绩效指标是数量化或者行为化的，验证这些绩效指标的数据或者信息是可以获得的； A代表可实现(Attainable)，指绩效指标在付出努力的情况下可以实现，避免设立过高或过低的目标； R代表现实性(realistic)，指绩效指标是实实在在的，可以证明和观察； T代表有时限(time bound)，注重完成绩效指标的特定期限。 9.4P 与 STP 理论市场营销与市场定位 4P 理论 STP 理论 10.PEST分析方法企业的战略外部环境分析。 11. PDCA模型 12.时间管理 A、重要且紧急 紧急状况迫切的问题限期完成的工作你不做其他人也不能做 B、重要不紧急准备工作预防措施价值观的澄清计划人际关系的建立真正的再创造增进自己的能力 C、紧急不重要造成干扰的事、电话、信件、报告会议许多迫在眉捷的急事符合别人期望的事 D、不重要不紧急忙碌琐碎的事广告函件电话逃避性活动等待时间 13. 任务分解法 目标→任务→工作→活动。 WBS分解的原则：将主体目标逐步细化分解，最底层的任务活动可直接分派到个人去完成；每个任务原则上要求分解到不能再细分为止。 WBS分解的方法：至上而下与至下而上的充分沟通；一对一个别交流；小组讨论。 WBS分解的标准：分解后的活动结构清晰；逻辑上形成一个大的活动；集成了所有的关键因素包含临时的里程碑和监控点；所有活动全部定义清楚 14. AISAS-用户行为决策分析模型 注意- 兴趣-搜索-行动-分享 15. 延伸： 个人IPO模型 16. 波特五种竞争力分析模型 17. KANO模型 对用户需求分类和优先排序 将影响用户满意度的因素划分为五个类型，包括： 魅力因素：用户意想不到的，如果不提供此需求，用户满意度不会降低，但当提供此需求，用户满意度会有很大提升; 期望因素(一维因素)：当提供此需求，用户满意度会提升，当不提供此需求，用户满意度会降低; 必备因素：当优化此需求，用户满意度不会提升，当不提供此需求，用户满意度会大幅降低; 无差异因素：无论提供或不提供此需求，用户满意度都不会有改变，用户根本不在意; 反向因素：用户根本都没有此需求，提供后用户满意度反而会下降; 18. SCP模型 分析在行业或者企业收到表面冲击时，可能的战略调整及行为变化。 19. SPACE-战略地位与行动评价矩阵 企业的内部因素与外部因素 参考资料 分析和解决问题的7种武器]]></content>
      <categories>
        <category>数据分析方法</category>
      </categories>
      <tags>
        <tag>数据分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据分析师-岗位与具备能力介绍]]></title>
    <url>%2F2018%2F12%2F22%2F%E6%96%B9%E6%B3%95-%E5%B2%97%E4%BD%8D%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[超级菜鸟如何入门数据分析 1. 数据分析师岗位介绍 什么是数据分析师？ 数据分析师， 就是专门从事数据收集、研究分析，并依据数据来指导业务决策的人员。 岗位分类 其中的数据收集、研究分析、业务指导刚好可以将数据分析的岗位分为三个大的部分： 数据收集——数据研发工程师 主要职能是搭建数据处理的基础设置，让大数据的存储、处理、计算能按要求完成，包括数据仓库搭建、数据存储、计算处理、报表开发等。 数据挖掘、算法工程师 主要是应用机器学习和数据挖掘算法，进行用户行为分析和用户属性挖掘，建立模型，预测、用户画像等为业务场景提供支持。 业务数据分析师 分析业务数据， 发现问题，分析问题，得出分析结论，为决策提供支持，主要支持市场运营部门。 如需详细了解数据分析师的岗位划分，可以参考秦路老师的文章：数据分析的职业规划 业务数据分析师的日常工作有哪些? 业务前期： 建立业务数据指标， 梳理业务数据口径， 确定数据埋点方案， 进行埋点测试，确保数据采集的准确性。 日常工作： 公司的日报、周报、月报数据支持，业务方临时性数据支持， 数据异常原因分析， 业务专题分析。 业务数据分析师的技能要求 数据分析思维和对公司业务的理解程度， 是业务数据分析的主要核心技能。 必备技能有： Excel, Hive/Sql, 统计学，PPT 软技能有： 逻辑思维能力，分析方法论， 数据敏感度， 沟通协调能力 加分技能： Python, R, 机器学习算法 业务数据分析的发展方向 业务数据分析是入门相对容易， 但要精通比较困难， 在公司属于比较基础的岗位。如果专精于业务方向， 可以往管理方面发展， 如数据运营经理/总监。也可往数据挖掘工程师方面发展， 需要进一步掌握Python和机器学习算法等知识，后面也可以往数据产品经理的方向发展。 对于我自己来说，目前的职业发展方向是业务数据分析师， 主要任务是不断学习和完善业务数据分析的所有技能， 加强互联网运营的业务理解能力，打好职业发展的基础，未来的期望是往数据挖掘方面发展。 业务数据分析师的考量标准 产品理解能力： 熟悉业务的各种核心数据，明白用户从哪里来，进来之后做了什么，了解用户反馈最多的问题是什么。 了解产品功能渗透率和关键路径，再以这些数据为切入点，思考当前产品有哪些问题，并与产品经理沟通如何优化，同时看竞品数据和行业数据，深入了解业务数据。 深入了解： 要有自己的洞见，对于整个行业，各个不同阶段的领头羊是谁，他们靠什么成为领头羊，又因为什么出现增长瓶颈，当前各自的大法测试什么，对我们自身的app有什么借鉴，后续我们要监控哪些数据。 分析方法论： 能够快速从一个较全面、逻辑性、价值性的角度去分析，而不是单点无架构分析。所有方法论都是通过不断提炼、总结、实践得出来的。 指标体系方法论 流量分析方法论 路径分析方法论 产品分析方法论 营销活动分析方法论 用户流失分析方法论 A/B 测试 可视化能力： PPT 制作能力 PPT专题报告之间的逻辑性 内容是否符合金字塔原理 数据可视化内容美观性 演讲能力： 表达能力 讲故事能力 形象化能力 协作沟通能力： 跟产品、业务、研发沟通时的软技能 如何在团队中定义好自己的位置并让其他人感到舒服 逻辑思维能力： 分析推导过程的全面性、合理性、价值型 技术能力： excel的常规操作 统计知识是否能够熟练应用 hive、sql的熟练程度 python 中常用的数据分析库能否熟练应用 算法模型是否熟练搭建并知道有哪些坑。 对数据进行分析的最佳途径： 业务梳理——了解业务需求 确定业务目标——弄清产品目标以及当下的首要问题 事件设计——记录和目标相关的用户行为，并定义为相应事件 数据采集——保证采集质量，确定好事件采集时机，和开发进行沟通 构建指标体系——确定想要看的指标，想要达到的分析粒度，建立产品的第一关键指标 数据分析——业务人员根据自己的经验，进行数据分析，迭代优化 2. 如何避免数据分析中的坑要避开哪些坑？ 不要重复无意义的工作。许多刚入行的小伙伴喜欢把清理数据作为主要工作，纪敏认为这只是让你接触数据的一种方法，每天重复地提出需求、整理表格，会磨灭掉许多对于分析师岗位的热情。 不要“全手动”，要寻找代替的工具。既然不能重复地做无意义的工作，那么就要学会用工具去代替人工，选择合适的用户行为模型和工具，能把分析师的主要精力放在规律和策略的探索上，才能充分发挥一名数据分析师应有的价值。 数据分析只是一种辅佐手段，它无法从根本上改变产品方向、功能价值，主要辅佐和支持的产品，探索更有价值的数据意义。 https://www.sensorsdata.cn/blog/20181107/ 避免数据偏见在分析数据时受个人偏见和动机的影响，即仅选择支持你声明的数据，同时丢弃不支持声明的部分。“数据偏见”将让数据的客观性荡然无存。 避免这种谬误的方法是在分析数据时，尽可能收集相关数据，并询问他人意见 避免数据疏浚数据疏浚（Data Dredging）是指未能确认相关性，实际上是偶然的结果。 在寻找问题的原因时，很容易被数据蒙蔽。乍一看，这些数据可能具有统计学意义，但进一步测试（例如，检查趋势是否持续，查看相关指标等）可能会发现只是偶然结果。 避免这种谬误的方法是在分析数据时，从假设开始检查相关指标和观察数据变化趋势。 区分因果关系和相关性 在数据分析时很容易将两个事件同时发生（相关），判断为因果关系。 避免这种谬误的方法是，收集更多数据并查看可能的第三方原因，有时会发现他们的相关关系可能与第三个独立因子相关，而不是彼此相关。 例如，我们发现放弃其在线购物车的潜在客户往往具有较低的总购物车价值（放弃时购物车中物品的总成本）。此时，我们没有足够的数据来确定这是一致的相关性，是偶然结果，还是由其他因素引起的。深入挖掘我们可能会发现运输成本导致购物车到下单的流失率上升，因为免费送货仅适用于超过特定最低购物车价值的订单。 解决问题，做出明智的决定在找到数据支持的结论后，你需要记下一个简短的摘要（包括问题，数据显示的内容以及由此产生的决策 / 行动），这样做有两个目的： 1.将你所分析的数据和结论告知可能涉及或受影响的任何其他团队，为其他人提供有价值的背景信息。 2.这个记录也将使你在将来出现类似情况时更容易参考和以防其他人想要查看数据本身。 最终，问题解决了，也总结了有价值的经验。 https://www.sensorsdata.cn/blog/20180929/ https://www.geckoboard.com/learn/data-literacy/basic-data-analysis-guide/ 一个提升用户体验的绝好方法：触点管理]]></content>
      <categories>
        <category>数据分析方法</category>
      </categories>
      <tags>
        <tag>数据分析</tag>
        <tag>岗位介绍</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[统计学学习]]></title>
    <url>%2F2018%2F10%2F20%2F%E6%8A%80%E8%83%BD-%E7%BB%9F%E8%AE%A1%E5%AD%A6%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[描述统计集中趋势分析 平均数将所有数据进行平均分配 1234import numpy as npa = [1, 3, 3, 4, 5, 7, 7, 15, 15, 15]# 均值np.mean(a) 中位数n个数据由大到小排列时，位于正中间的那个数 1234import numpy as npa = [1, 3, 3, 4, 5, 7, 7, 15, 15, 15]# 中位数np.median(a) 众数n个数据中，出现次数最多的那个数。 12345678import numpy as npa = [1, 3, 3, 4, 5, 7, 7, 15, 15, 15]#方法1# np.bincount, 计算非负的int数组中，每个值出现的次数counts = np.bincount(a)#[0 1 0 2 1 1 0 2 0 0 0 0 0 0 0 3]#返回沿轴最大值的索引np.argmax(counts) 12345import numpy as npa = [1, 3, 3, 4, 5, 7, 7, 15, 15, 15]# 方法2from scipy import statsstats.mode(a)[0][0] 变异性 极差n个数据中，最大数与最小数之差 123import numpy as npa = [1, 3, 3, 4, 5, 7, 7, 15, 15, 15]b = max(a) - min(a) 四分位数将数据从小到大排列并分成4等份后，处于3个分割点上的数。箱型图 123456import numpy as npa = [1, 3, 3, 4, 5, 7, 7, 15, 15, 15]# 中位数np.median(a)# 45%分位数np.percentile(a, 45) 方差度量随机变量与期望值（平均值）之间的偏离程度。 公式：$\sigma ^{2} = \frac{ \sum_{i=1}^{N}(x_{i}-\mu)^{2}}{N}$ 计算步骤： 求平均值 求 (各数值 - 平均值) 的值 以 (各数值 - 平均值) 的平均数为标准，无法看出以平均数为基准数据的离散程度。因为两数相减结果有正有负，相加之后会互相抵消。 为使 (各数值 - 平均值) 的差值即使为负也能显示出差值，可以将 (各数值 - 平均值)的值平方之后，再取平均值。 求 (各数值 - 平均值)² 的值 求 (各数值 - 平均值)² 的平均值 方差问题： 数值时有会过大 单位为原先单位的平方 123import numpy as npa = [1, 3, 3, 4, 5, 7, 7, 15, 15, 15]np.var(a) 标准差标准差越小，说明数据大多数集中于平均值附近，偏差不大。公式：$\sigma = \sqrt{\sigma ^{2}} =\sqrt{\frac{ \sum_{i=1}^{N}(x_{i}-\mu)^{2}}{N}} $计算步骤： 计算出方差后开根号 123import numpy as npa = [1, 3, 3, 4, 5, 7, 7, 15, 15, 15]np.std(a) 相关性 常见的因果关系 某个原因导致的结果唯一，导致某个结果的原因也是唯一的。 某个原因导致的结果唯一，导致某个结果的原因不唯一。 某个原因导致的结果不唯一，导致某个结果的原因唯一。 某个原因导致的结果不唯一，导致某个结果的原因也不唯一。 相关系数表示相关关系的正负与强弱的系数相关系数r的范围是-1≤r≤1判断相关关系强弱的标准： 123456789101112131415# 写法1a = [1,2,3,4]b = [2,4, 6,9]import numpy as npnp.corrcoef([a,b])# 写法2import scipy.stats as statsstats.pearsonr(a,b)# 结果的第一个数为相关系数# 写法3import pandas as pddf= pd.DataFrame()df['a'] = [1,2,3,4]df['b'] = [2,4, 6,9]df.corr() 概率排列与组合 排列从N项中任取n项，并进行排列，决策的顺序的结果有影响。公式：$P_{n}^{N} = \frac{N!}{(N-n)!}$ 12from scipy.special import comb, permperm(5,2) 组合从N项中任取n项,不考虑顺序。公式：$c_{n}^{N} = \frac{N!}{n!(N-n)!}$ 12from scipy.special import comb, permcomb(5,2) 补充资料： 5分钟彻底了解排列组合 事件 事件的补: $P(A) = 1 - P (A^{c})$ 事件的并：$P(A\bigcup B ) = P(A) + P(A) - P(A\bigcap B )$ 互斥事件：$P(A\bigcup B ) = P(A) + P(B)$ 独立事件：$P(A\bigcap B) = P(A) * P(B)$ 条件概率 在事件B发生的条件下， A条件发生的概率 公式： $P(A|B ) = \frac{P(A\bigcap B)}{P(B)}$ 二项分布 概念： 成功率为P的实验，独立重复 n 次后的成功次数为 x 的概率分布。 公式： 案例：在各类促销活动中， 抽奖是一种常见的促销方式。现在希望运营方设计一个抽奖模式。用户能够抽10次，中奖概率是10%。如果用户抽中了3次及以上， 则公司会亏本。那么公司亏本的概率是多少？ 正态分布 性质： 均值 = 中位数 = 众数 沿中心线对称，一半在平均值左侧，一半在平均值右侧。 特点： 69%的数值在离平均值一个标准差之内 95%的数值在离平均值2个标准差之内 99.7%的数值在离平均值3个标准差之内 补充资料： 正态分布为什么常见？ 正态分布 数据标准化-Z-Score 公式： z = (x - u) / 方差 目的：消除指标之间的量纲和取值范围差异的影响 补充资料：数据规范化（归一化）、及Z-score标准化 切比雪夫定理 至少有75%的数据在两个标准差之内 至少有89%的数据在三个标准差之内 至少有95%的数据在5个标准差之内 举例： 若一班有36个学生，而在一次考试中，平均分是80分，标准差是10分，我们便可得出结论：少于50分（与平均相差3个标准差以上）的人，数目不多于4个（=36*1/9） 作用： 用于异常值检测 贝叶斯定理 如何判断她喜欢你的概率贝叶斯定理计算方法： 先假定一个概率， 然后根据样本获得新的信息， 根据这些信息对 原先假设的概率进行修正， 得到准确的概率。公式：$P(A|B) = \frac{P(A) * P(B|A)}{P(B)}$ 假设 你是一名女生， 在情人节这天， 一名男生送给你一盒巧克力， 你可能会有疑问，他是不是喜欢你， 他喜欢你的概率是多大？ 因为你没有证据来说明你就是他喜欢的类型， 所以， 我们假设 你或者是他喜欢的类型， 或者是一名路人。 假设各有50%的概率。 通过调查， 我们发现 一个男生对心意女生送出巧克力的概率为 45% 对路人送出巧克力的概率 为 20%， 那他现在送给你一盒巧克力， 在他已经送你巧克力的这件事情已经确定了， 所以他们现在是一个整体。他喜欢你的概率是多少呢。 45% / (45% + 20%) = 69.2%当他送你巧克力时，大概有69、2%的概率会喜欢你 当然， 贝叶斯概率 能够计算出这个概率， 但是否要继续， 取决与你。 贝叶斯概率在我们生活中的应用是非常广泛的， 常见的， 比如 在邮件中的反垃圾邮件。 这是一种贝叶斯概率非常好的使用案例。 在上面的推理中， 我们总会觉得贝叶斯定理有些“牵强”,牵强的原因主要是因为先验概率。 这种主观上假定或者大概的概率， 会让人感觉牵强。 但也正是由于设定了先验概率， 贝叶斯定理才会有即是只有少量信息， 也能够进行推理。 当然， 贝叶斯定理有另一学习功能， 就是信息越多， 推理结果就越精确。 快速理解贝叶斯定理 假设一家商城， 顾客分为： 想买商品的顾客，和随便逛逛的顾客。 假设， 随机走进来一个顾客，他为有意愿度的顾客占20%， 为随便逛逛的顾客占80%。 现在增加了一个主动询问店员的动作。 假设有意愿度购买的顾客， 向店员询问的概率为70%， 不询问的概率为30%。 随便逛逛的客户， 主动询问店员的购买概率为 10%， 不询问的概率为 90%。 现在问 如果一顾客主动向店员询问， 那么他是有意愿购买的顾客的概率是多少。 有意向且询问的概率为 14%。 有意向不询问的概率为 6% 无意向且询问的概率为 8%， 无意向且不询问的概率为 72% 现在 主动询问这个动作已经做出了， 所以总体为两部分： 有意向且询问， 和无意向且询问 14:8 = 7:4。 所以她有意向且愿意购买的概率为 7/11 63.6% 贝叶斯： 通过结果来反推原因 参加活动的人群中，女性只占30%， 是否说明女性不喜欢参加此类活动？ 某种疾病的发病率为千分之一。现在有一种试纸，它在患者得病的情况下，有99%的准确率判断患者得病，在患者没有得病的情况下，有5%的可能误判患者得病。现在试纸说一个患者得了病，那么患者真的患病的概率是多少？ 某城市有两种颜色的出租车，蓝车和绿车市场比率为15:85。 一辆出租车肇事逃逸，当时有一位目击者证人，这位证人认定肇事的出租车是蓝色的。但是他的目击未必可信，公安人员经过在相同环境下对该目击者进行“蓝绿”测试得到：80%的情况下识别正确，20%的情况下不正确。那么实际为蓝车的可能性是多少？ 我们经常会受到垃圾短信，假设1000条正常短信中，包含【澳门赌场】的短信有2条，而在垃圾短信中，包含澳门短信的短信有400条。现在我们接受到了一条新短信，在不浏览内容的情况下，假定它的正常几率是50%。现在对短信内容进行解析，发现澳门赌场这个词，那么它是垃圾短信的概率有多高。 补充资料： 数学之美番外篇：平凡而又神奇的贝叶斯方法 《统计学关我什么事》 贝叶斯推断及其互联网应用（一）：定理简介 贝叶斯学习与未来人工智能 前言：为什么应该学点统计学 统计学是人类发明用来研究我们自身的科学，它与我们的生活息息相关。 小到支付宝根据用户个人消费数据判断其消费水平，从而有针对性进行限额借贷。大到国家通过国民生产总值这样的统计数据分析，来研究国家经济发展趋势等， 都需要用到统计学知识。 我们可以从统计大师 Hans Rolling 的演讲中， 来看下 1960 年到 2003 年的世界各国出生率与经济发展是如何变化的。 Hans Rolling —— 统计的魅力 有人会问，统计学那么多高深的概念和复杂的算术， 在平时的生活中自己也应用不到。 这种想法其实是错误的。我们学习统计学， 不光是学习怎么对数据进行统计计算，更重要的是学会运用统计思维去更理性地看待周围的事物。 比如， 最近报道的一名美国公民在 10 月 23 号中了 16 亿美元的彩票， 看到这则消息，你会不会也有点心动， 也想去买个彩票。其实， 关于是否要买彩票，统计学有一个重要的概念来衡量：期望值 即同一种行为多次重复之后，所能得到的平均收益 举例来说， 假如某彩票规则为：每次买张彩票需要 2 元，假设 200 次抽奖可以中奖一次，奖金为 300 元。 期望值 = 300 (1/200) + 0 (199/200) = 1.5。 期望值是 1.5 元， 但是每次抽奖成本为 2 元， 于是每次净亏损 0.5 元。如果你偶尔买一次就算了， 但如果你长期买彩票，就肯定会亏很多钱。 况且现实生活中，中奖的概率远远低于 1/200 你可能会觉得，概率那么低， 那我怎么感觉天天有人中奖呢， 这背后其实是媒体的选择性报道， 也就是统计学中的幸存者偏差问题。 例如：二战期间，盟军为减少飞机在敌人防空炮火中的损失，军方决定为飞机加装防护，多数人认为，应该在机身中弹多的地方加强防护。但统计学家沃德认为，应该给那些没有中弹的油箱和驾驶部位进行防护，因为这些部位中弹的飞机根本没有机会飞回来。 现实生活中，也往往会存在一些幸存者偏差的数据，我们生活中接触的数据越来越多， 解读数据背后的信息， 辨析数据真伪就显得非常的重要，这则视频对此有更深入的讲解。 成功学有用吗？幸存者偏差，一个活着就该明白的事！李永乐老师 那么统计学到底要学什么呢？统计学主要学习两个方面: 描述统计， 描述数据的基本情况 通过研究数据的平均值，中位数，标准差等指标， 来了解数据的整体分布状况，从杂乱的数据中得出有用的信息 推理统计，根据样本数据来对总体进行估计 通过对样本数据的研究， 来对总体数据进行估计，评估推理数据的准确度，统计学中就会通过置信度， 卡方分布等来对总体进行估计。 统计学是我们将客观数据转化成有用信息的一把钥匙， 运用统计概念对一些更为广泛而大致的信息及规律进行思考， 可以改善我们做出的判断和决定。我们当然不能指望这些判断不出错误， 但每一个好的决策都会帮助你更有效的利用这些信息，积少成多，把事情做成的概率会大很多。 视频资料补充：Hans Rolling —— 东方崛起 为什么应该学点统计学 数据的乐趣 统计学网站 看见统计学 数学很好玩 数据可视化-博客 数学公式转换为markdown格式 《写给所有人的极简统计学》]]></content>
      <categories>
        <category>数据分析技能</category>
      </categories>
      <tags>
        <tag>数据分析</tag>
        <tag>统计学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[思考系统]]></title>
    <url>%2F2018%2F10%2F14%2F%E9%80%9A%E7%94%A8-%E6%80%9D%E8%80%83%E8%83%BD%E5%8A%9B-%E6%80%9D%E8%80%83%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[批判性思维图尔敏模型 举例： 小明出生在北京，所以小明是中国人。 论题： 小明出生在北京 前提： 在北京出生的是中国人 支撑： 现有法律规定 逻辑推理： 在北京出生的是中国人，小明在北京出生，所以小明是中国人。 反例：小明后来移民加拿大。 对推理的限定： 小明并非一定就是中国人 结论：因为小明出生在北京，所以小明可能是中国人。 对各个模块进行解释 论题论题是要讨论的问题或争议。 论题分为两种形式： 一种是对事实的讨论，比如：服用中药 是不是 能治好疾病，杨教授的学术研究水平 怎么样？ 人口出生率下降的原因 是什么？ 另一种是对价值主张的讨论， 比如：大学生 应不应该 读研， 对全民医疗 应该 采取什么样的态度？ 不同类型的论题，做出的评价是不同的，我们在讨论一件事情时，要检查两点： 我们是在讨论某个事实，还是讨论价值主张。 我有没有正面回答问题。 结论结论是要让你相信的观点和信息, 必须是有论证支撑的观点。 没有论据支撑的观点不能叫结论。 当某人说出他的观点时， 我们应该马上问：你这个看法有什么依据？ 注意问题： 偷换结论用一个相关性很强的结论来换掉正面回答问题的结论。原理：默认预设，认为结论只能二选一。 鱼和熊掌不可兼得，我拿不到鱼，所以我会拿到熊掌。 年轻人不愿意生孩子，所以养猫的人会越来越多。 先有结论，再证明合理人先作了决定，然后给出的理由并不是来推导这个决定，而是想办法维护这个决定。 在作一些决定和选择时，要先问自己：影响决策的是理性判断还是情绪等影响。 论证前应明确的两个问题明确对方是在进行论证，还是在进行解释。 解释并没有证明论证确实成立，而是把结论变成了默认前提。论证是指：我还没有相信或者认同你，你得证明你的判断。 将 因为 用 根据…、基于…、理由是… 来进行替换， 将 所以 用 得出…、推断…、证明… 来进行替换，看语句是否通顺。 我在吃饭，因为我往嘴里塞食物。 解释是指：我们已经承认了事实，视图说明为什么事实是这样的。 将 因为 用 归因于… 来进行替换， 将 所以 用 导致… 来进行替换，看语句是否通顺。 我在吃饭，因为我饿了。 识别概念的定义区别 在论题、论证和结论中出现的概念是一致的吗,这些观念会误导别人吗？ 关键概念的定义准确吗？ 在思考和论证的过程中，把一件事定义清楚。参考：《学会提问》第4章 挖掘论证中两种隐藏假设 事实判断型的假设， 这个世界是什么样的？一个理由是否能证实结论，主要取决于我们能否找到没有明说出来的想法，将理由和结论从逻辑上联系起来。比如：每天一个鸡蛋，能补充蛋白质。假定：鸡蛋是富含蛋白质的。 如何找出描述性假设 不断思考理由和结论之间的关系，寻找支持理由的想法、 把自己放到相反立场 价值判断型的假设， 这个世界应该如何选择？价值观假设是认为某些价值观中一个比另一个更重要，并且选择的价值观会对结论产生重大影响，同时也影响他捍卫结论的方式，但是这种价值取向并没有说明。比如价值观冲突： 忠诚-诚实、竞争-合作、媒体自由-国家安全、平等-个人主义、秩序-言论自由、理性-冲动。 如何找出价值观假设 言论者的背景是什么，他代表了哪方的利益？ 注意作者用来证实结论的各种理由，然后判断哪些价值取向会导致作者认为这些理由比另一些理由更可取，而另一些理由其实可以从论题的另一方面进行论证。 如果我和作者站在相反的立场，我会如何反驳 判断假设 这个假设和我的个人经验冲突不？ 这个假设是来自哪里的，消息来源可靠吗？ 我自己想法，背后的隐藏假设是什么？ 支撑 支撑是双方都公认的法则或常识。 法律法规 经检验的科学研究 注意类比的质量。 反例 对相反观点的论证，以达到论证的全面性。 常见谬误：参考下文：常见谬误详解 用图尔敏模型进行议论文写作 对文章主题进行介绍 介绍能够引起读者注意的内容 对要表述的问题进行陈述 表达你的结论，并给出使用范围。 提出证据来支撑论证 证据1、2 提供支撑保证的理由和事实，根据个人实践和理论来说明保证的合理性。 支撑1、2 回答反驳 反驳1 对反驳1的回答… 结论 概括论证和结论的要点，指出论证的意义，能够让读者印象深刻。 用图尔敏模型进行分析性写作对某一文章质量进行评判 理解主题论点，澄清概念的意义。 审查理由质量，挖掘潜在的假设。 分析论证结构，评估推理的强弱。 考虑替代论证， 提出完善的建议。 学习资料 课程-中国青年政治学院：批判性思维（谷振诣教授） Toulmin method 《逻辑新引.怎样辨别是非》 《beyond feelings》 《简单的逻辑学》 《学会提问》 《蔡钰-批判性思维15讲》 Justice – What’s the right thing to do? 结构化思维 对信息进行识别、归纳、概括、总结和表达。 识别信息 纵向上的总分结构 识别结论 识别理由 识别事实参考:上文批判性思维 归纳信息 横向上的分类结构 MECE 分类法： 不重不漏 二分法 过程法： 发展时间、运作流程 要素法：从上到下、从外到内、从整体到局部 公式法：按照公式的要素去分类。 矩阵法 特定场景模型：常见的分析思维模型 总结概括信息 归纳法 根据许多个别事物的特殊性来概括出同类事物的特性。 描述性概括 找出事物属性上的共同点。 行动性概括 最终结果是什么，找出事物结果的共性。 演绎法 将某一事实与对应的某个规律联系再一起，得出结论。 注意事项： 大前提一定要无可争议，避免主观判断，并且罗列不能过长。 小前提是一个已经发生的事实。 清晰表达1.结论先行 表达时先说结论 2.以上统下 上一层次要点必须是下一层次的概括 3.归类分组 每一组要点必须属于同一范畴 4.逻辑递进 每个要点必须按照一定的逻辑顺序排列。 演绎推理 时间/步骤顺序 空间顺序 重要性顺序 注意事项： 结论先行，重要的理由说三点。 参考资料 《得到-有效训练你的结构化思维》 《金字塔原理》 如何解决问题1. 明确和理解问题 明确问题的本质到底是什么 跟领导确认希望达到的目标 明确可以利用的资源 2.拆分和定位问题 用公式思维拆解问题 逻辑树-金字塔原理（mece法则) 假设驱动-假设问题可能出现在某个细分的问题点上。 3.提出解决方案并总结 结论先行参考上文：结构化思维 4. 工作中解决问题的方法 快速按照理解去做拆解，去做思维导图， 能想到多少是多少 拿着拆解思维导图去跟业务方的人去请教，一定要找到业务方真正关心的点 结合业务方给出的具体建议， 修改第一步的思维框架， 做完后，请教你的领导 再改一次， 回报给业务方领导 遇到坑之后， 一定要文档详细记录下来。 让团队中其他人知道， 节省团队时间。 知道自己在哪块花了大量时间，为后续分析节省时间。 5. 生活中问题解决的4个层次 有没有找到真正的问题， 人都是有逃避心理的。 想到了问题的第几层 想到了最后一层， 并且去执行解决问题 做到了，并且分享帮助别人 常见谬误详解1.幸存偏误 在生活中更容易看到成功者的故事，看不到失败， 你会系统性地高估成功的概率。 2.游泳选手身材错觉 你看到游泳选手的身材好，因此你觉得游泳就可以练就这样的身材。你觉得用这个护肤品的模特都好漂亮， 因此你觉得用了这个护肤品自己也可以变漂亮。 其实是因为他们有这样的好身材， 所以他们才能被选为游泳运动员。 和游泳能够练就这样的身材没有直接的关系。 用这个护肤品的模特好看， 是因为这个模特好看， 所以她才能被选做拍这个护肤品的广告， 和这个护肤品可以让自己更漂亮没有直接关系。 3.过度自信效应 系统性地高估自己的学识和能力 过度自信会令你忽视你真正掌握的能力与你已知的知识之间的区别 这个怎么理解呢， 就是你很多知识， 你只是了解， 而并非已经内化成你的能力， 而你会错误的把它归为你能力的一部分。 比如你说你会python, 但当你真正写的时候， 你却写不出来， 其实你没有掌握 4.诉诸结果 依据某观点成立所产生的结果好坏，来判断一个观点是否正确。 5.稻草人谬误 有意地模仿他人观点，以达到攻击模仿出来的观点而非实际论点的目的。 6.诉诸无关权威 诉诸不是问题专家的人， 其观点更可能是错误的。 例如：信仰中医，而不相信现代医学 7.虚假两难 给出一个有两种范畴组成的有限集合， 并假设讨论范围内的一切事物都必须属于该集合。因此 若拒绝其中一个范畴，便只好接受另一个。 例如： 世界上只有两种人，男人和女人， 你既然不是女人， 那么你一定是男人。 8.人身攻击 通过攻击一个人本身，而不是攻击其论点，以转移讨论话题，最终达到诋毁其论点的目的。 “侮辱性人身攻击” ： 你又不是专家， 你有什么资格发言 “处境类人身攻击” ： 对他们的动机作出判断。 你又不是真正关心降低城市犯罪率， 你只是想要人们投票给你。 9.循环论证 你完全错了， 因为你说得没有道理。 你应该相信上帝， 否则你会下地狱。 10.从众心理 11.纠缠于沉迷成本 我已经买了电影票了， 电影再烂也要看完。 我已经在这段恋情中投入了那么多感情， 现在离开她是不明智的。 我已经在这支股票中投了那么多钱了， 现在就收手会亏本的， 说不定以后会涨的。 你应该看的是现在的形势以及你对未来的评估。 12.互惠偏误 先送你一束花， 然后让你捐赠。 诉诸公众 诉诸感情 滑坡谬误 偷换概念 转移话题 因果混淆：相关并不能证明因果。 事后归因参考资料： 《简单的逻辑学》第5章 《有用的逻辑学》]]></content>
      <categories>
        <category>个人系统</category>
      </categories>
      <tags>
        <tag>逻辑</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python-Pandas库学习]]></title>
    <url>%2F2018%2F09%2F27%2F%E6%8A%80%E8%83%BD-Python-pandas%E5%BA%93%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[Pandas简介 Pandas是python数据分析中一个非常核心的数据库， 在日常的工作中经常需要使用Pandas库来对数据进行处理分析。Pandas的核心为两大数据结构， Series和DataFrame，Series用于存储一维数据， 而DataFrame存储多维数据。 常用的软件-Anaconda是数据分析中运行python的一款利器， 安装教程可参考Anaconda入门使用指南 读取与写入Excel数据 相对路径与绝对路径 读取文件夹内容 r（转义符）避免路径中的\被转义。路径中不加 \ 则需要把所有的\写成/。 1234567891011import pandas as pdimport numpy as npfrom pandas import Series, DataFrameimport osfile_list = os.listdir(r'E:\工作文件\周报\周数据\测试\0902-0908')print(file_list, '\t')# 读取当前文件夹地址os.getcwd() 读取xls格式Excel表 123df = pd.read_excel('E:/工作文件/an-商品汇总-uv.xls')df = pd.read_excel(r'E:\工作文件\an-商品汇总-uv.xls') 读取csv格式Excel表 1234567df = pd.read_csv('E:/工作文件/周报/周数据/测试/0902-0908/商品汇总.csv')# 读取csv文件，并用 分隔符分割df = pd.read_csv(r'E:\商品汇总.csv', sep = " ")# 只读取文件前两行df = pd.read_csv(r'E:\商品汇总.csv', nrows = 2) 读取显示编码错误 123456789101112131415# 显示错误为：# UnicodeDecodeError: 'utf-8' codec can not decode byte 0xb5 in position 0: invalid start byte# 修改方式df = pd.read_csv(path + '登记用户 20191127.csv',encoding="gbk" )# 当文件路径包含中文解析错误时，设置 engine 参数来消除这个错误# 错误原因， 当调用read_csv方法时，默认使用C语言作为解析语言，只需要将默认值c语言更改为python# 如果文件格式是 csv usf-8, 那么编码也改为 utf-8-sig# 如果文件格式是 csv格式， 则编码格式为 gbkdf = pd.read_csv('登记用户 20191127.csv', engine = 'python', encoding = 'utf-8-sig') 读取txt格式数据 123456df = pd.read_table(r'C:\Users\Administrator\Desktop\haha.txt', sep = ' ')with open(r'C:\Users\Administrator\Desktop\haha.txt', 'r') as f: df = f.readlines() df = np.loadtxt(r'C:\Users\Administrator\Desktop\haha.txt') # 将txt文件存为numpy数组 读取excel中的sheet名称 12345678910111213141516171819202122232425262728df = pd.read_Excel(r'E:\工作文件\an-商品汇总-uv.xlsx', sheet_name = 'sheet1')# 传入sheet的顺序，从0开始计数df = pd.read_Excel(r'E:\工作文件\an-商品汇总-uv.xlsx', sheet_name = 0)# 读取sheet,并制定文件中的第几行做行索引df = pd.read_Excel(r'E:\工作文件\an-商品汇总-uv.xlsx', sheet_name = 0, index_col = 0)# 读取sheet文件， 并制定文件中的第几列做列索引df = pd.read_Excel(r'E:\工作文件\商品汇总.xlsx', sheet_name = 0, head = 1)# 当本地文件过多时，可以通过设定 usecols 参数来指定要导入的列df = pd.read_Excel(r'E:\商品汇总.xlsx', usecols = 0)# uescols = [0,2]# 读取excel中所有sheet，并进行合并rbook = []kong_data = os.listdir(r'F:\省资源位')for file_name in kong_data: data_excel = pd.ExcelFile(r'F:\省资源位\\'+file_name) sheet = data_excel.sheet_names for i in sheet: data_button_rest = pd.read_excel(r'F:\省资源位\\'+file_name, sheet_name= i ) rbook.append(data_button_rest) result_df =pd.concat(rbook)datas_excel = pd.DataFrame(result_df) 将运行的所有数据都展现出来， 而不是只展现最后一条 12from IPython.core.interactiveshell import InteractiveShellInteractiveShell.ast_node_interactivity = "all" 将数据写入Excel表， 并输出 1234567891011121314151617181920212223242526# 写入数据df.to_excel('C:/Users/Administrator/Desktop/'+'商品分类.xlsx')df.to_excel(r'C:\Users\Administrator\Desktop\\'+'商品分类.xlsx')df.to_excel(r'C:\Users\Administrator\Desktop/'+'商品分类.xlsx')# 写入数据，且不带索引df.to_excel('C:/Users/商品分类.xlsx', sheet_name = '首页', index = False)# 设置要导出的列df.to_excel('C:/Users/商品分类.xlsx', sheet_name = '首页', index = False, columns = ['ID', '销量’])# 设置编码格式df.to_excel('C:/Users/商品分类.xlsx', sheet_name = '首页', index = False, encoding = 'utf-8')# 缺失值、无穷值处理df.to_excel('C:/Users/商品分类.xlsx', sheet_name = '首页', index = False, na_rep = 0, # 缺失值用0填充 inf_rep = 0 # 无穷之用0填充 )# 导出csv文件，设置分隔符df.to_excel('C:/Users/商品分类.xlsx', sheet_name = '首页', index = False, sep = ',' ) 将求出的数据存储在excel中的多个sheet中 123456789import pandas as pdfrom openpyxl import load_workbook writer = pd.ExcelWriter('F:/notebooks/zhoushuju.xlsx')btn_navigation.to_excel(writer, sheet_name = '底部导航')shouye_top20.to_excel(writer, sheet_name = '首页top20')writer.save()writer.close() 其他数据格式 12345678910111213141516171819# 从SQL表/库导入数据 import pymysqleng = pymysql.connet(host= '100.129', user = 'root', password = '1234', df = 'db', charset = 'ugf8')query = """select * from android_log """df = pd.read_sql(query, eng)# 导出数据到SQL表 df.to_sql(table_name, eng)``` 8. 常见问题* 当文件有中文时， 可能会出现错误：Initializing from file failed 有中文， 可以用此方法解决```pythonf = open(‘我的文件.csv’)res = pd.read_csv(f) 查看大文件有多少列 1234data = open('E:/用户明细.csv')data1 = pd.read_csv(data, iterator=True)data2 = data1.get_chunk(5)print(data2) 迭代器 对输出数据进行处理pandas的数据输出显示设置 对表中某一列元素进行相同操作 123df[&apos;金额&apos;].apply(lambda x:x+1)df[&apos;金额&apos;] +2 对表中每一个元素进行相同操作 1df.applymap(lambda x:x+1) 123456789101112131415import numpy as npimport pandas as pddf = pd.DataFrame(np.random.randn(150, 150))# pd.set_option('expand_frame_repr', False) #数据超过总宽度后，是否折叠显示pd.set_option('display.width', 100) #数据显示总宽度pd.set_option('max_rows', 100) #显示最多行数，超出该数以省略号表示pd.set_option('max_columns', 100) #显示最多列数，超出该数以省略号表示pd.set_option('max_colwidth', 16) #设置单列的宽度，用字符个数表示，单个数据长度超出该数时以省略号表示pd.set_option('large_repr', 'truncate') #数据超过设置显示最大行列数时，带省略号显示/若是info则是统计信息显示pd.set_option('show_dimensions', True) #当数据带省略号显示时，是否在最后显示数据的维度print(df)pd.set_option('max_info_columns', 100) #当列数超过这个值时，调用df.info()函数时不会统计每列的非空值。print(df.info()) 将数据变成小数形式12345678910import pandas as pd inputfile = '../data/electricity_data.xls'outputfile = './electricity_data_analyze1.xls' data = pd.read_excel(inputfile)data[u'线损率'] = (data[u'供入电量']-data[u'供出电量'])/data[u'供入电量'] #data[u'线损率']的类型为series； data[u'线损率']为小数data[u'线损率'] = data[u'线损率'].apply(lambda x: format(x, '.2%')) #Series.apply()让序列的值依次在lambda函数中执行； data['线损率']由小数转化为百分数 data.to_excel(outputfile, index=False) 描述数据 表信息 1df.info() 显示数据的行列数 1df.shape 查看数据格式dtpyes 1df.dtypes 显示列名、元素 12df.columnsdf.values 添加默认列名 12# 如果数据没有标题行，可用pandas添加默认的列名df = pd.read_excel('x.xlsx', header = None) 显示前数据前5行 12df.head(5)df[['标题', '客户端uv']].head() 显示数据后5行 1df.tail(5) 值 1df.values 读取a列 1df['a'] 找到重复值 1df.duplicated() 显示数据唯一值（unique函数） 12# 数据有0， 是因对缺失值进行了填充df['经纪人级别'].unique() 对第几行数据不读取 12#不读取哪里数据，可用skiprows=[i]，跳过文件的第i行不读取df = pd.read_excel('x.xlsx',skiprows=[2] ) 对缺失值进行识别 12# 所有缺失值显示为Truepd.insull(df) # df.isnull() 计算 1234567891011#计算此data的数量df['data'].value_counts()# 升序计数df['data'].value_counts(ascending = True)# 升序计数并分组df['data'].value_counts(ascending = True, bins = 2)# 计数df['data'].count() 字符和数值之间的转化 1234int() # 转化成整数float() # 转化成浮点数str() # 转化成字符type() # 查看格式 获取数据分布情况 1data.describe() 数据清晰 删除空值 （dropna函数） DataFrame中的空值处理 1234df.dropna(how='any')df.dropna(how = 'all') 123456789用法：DataFrame.drop(labels=None,axis=0, index=None, columns=None, inplace=False)参数说明：labels 就是要删除的行列的名字，用列表给定axis 默认为0，指删除行，因此删除columns时要指定axis=1；index 直接指定要删除的行columns 直接指定要删除的列inplace=False，默认该删除操作不改变原数据，而是返回一个执行删除操作后的新dataframe；inplace=True，则会直接在原数据上进行删除操作，删除后无法返回。 123# 删除包含 集团 二字 的行read_data = df[- df[&apos;所属省份名称&apos;].isin([&apos;集团&apos;])] 数值删除 删除列 1234567# 删除列, axis=1表示删除列df.drop(["销售额", "ID"], axis = 1)df.drop(columns = ["销售额", "ID"])# 传入列位置df.drop(df.columns[[4,5]], axis =1) 删除行 1234567891011# 删除行，筛选行名df.drop([&apos;一&apos;,&apos;二&apos;], axis = 0)df.drop(index = [&apos;一&apos;, &apos;二&apos;])# 删除行，筛选行索引df.drop(df.index[[0,1]], axis = 0)# 只要年龄小于40的用户df[df[&apos;ID&apos;] &lt; 40] 填充（fillna函数） 123456789# 空值用0填充df.fillna(value=0)df.replace(np.NaN, 0)# 用均值对空值进行填充df['时长'].fillna(df['时长'].mean())# 按照不同列进行填充df.fillna(&#123;'性别' : '男'&#125;) 更改数据格式，更改数据类型 123# 将数据格式int64,改为float格式df['大区'].astype('float64') 更改列名称, 修改列名。 123df.columns = [['导航','uv', 'pv','户均点击']]df.rename(columns=&#123;'IM渠道': '渠道'&#125;) 添加修改索引 12345678# 添加索引df.index = [1,2,3,4]# 修改索引,重新设置df = df.set_index['标题']# 重命名索引df.rename (index = &#123;1: '一'&#125;) 重置索引 12345678910DataFrame.reset_index(level=None, drop=False, inplace=False)# 默认将所有index转化成columnsdf.reset_index()#将第0级索引转化为 columnsdf.reset_index(level=0)# 将原索引删除，不加入columnsdf.reset_index(drop = True) 删除重复值 Pandas删除数据的几种情况 12345678# 默认第一次出现的保留，其余删除df['门店'].drop_duplicates()# 最后一次出现的保留，其余删除df['门店'].drop_duplicates(keep = 'last')# 多列去重df.drop_duplicates(subset = ['姓名', '唯一识别码']) 对列表内的值进行替换 123456789# 一对一替换df['ID'].replace('1053', '110')# 多对一替换df['ID'].replace(&#123;'1053': '110', '230': '33'&#125;)df.columns.str.replace(' ', '_') 对数据进行处理 对两个数据进行合并- merge, join, concat函数 merge 123456789101112131415161718192021222324252627# 按照轴把多个对象拼接起来pd.concat(df1, df2)# join函数适合根据索引进行合并，合并索引相同但列不同的对象# merge函数，根据一个或多个键连接多行, 相当于excel中的vlookup# 将left和right进行合并pd.merge(left, right)# 指定以key为键进行合并pd.merge(left, right, on = 'key') pd.merge(name_3, name_1, left_on = ['ming'], right_on = ['标记'])# key2列不相同的部分会直接舍弃掉pd.merge(left, right, on = ['key', 'key2'])# 保留key2列不相同的部分pd.merge(left, right, on = ['key', 'key2'], how = 'outer')# 不相同的部分指定以左表为基准pd.merge(left, right, on = ['key', 'key2'], how = 'left')# 重复列名处理# pd.merge()会自动给这些重复名添加后缀_x、_y，也可以自己命名。pd.merge(df1,df2, on = 'id', suffixes= ['_L', '_R']) concat函数, 按照标题进行拼接 12345678# 普通合并pd.concat([df1, df2])# 索引设置pd.concat([df1, df2], ignore_index= True)# 合并后删除重复值pd.concat([df1, df2], ignore_index = True).drop_duplicates() 对数据进行排序 12345678910111213# 按照ID进行升序排列# 按照ID进行降序排列df.sort_values(by = ['ID'], ascending = False)# 在保证销售额列降序的情况下，对ID列进行升序处理data.sort_values(by = ['销售额', 'ID'],ascending = [False, True], inplace = True)# 默认将ID是缺失值的列显示在最后面df.sort_values(by = ['ID'])# 将ID是缺失值的列显示在最前面df.sort_values(by = ['ID'], na_position = 'first') 对数值进行排名 1234567891011# 对应Excel中的 rank.avg函数df['ID'].rank(method= 'average')# 按值在所有的排列数据中出现的先后顺序排名df['ID'].rank(method = 'first')# 与Excel中rank.eq 函数的功能一样df['ID'].rank(method = 'min')# 与min相反，取重复值对应的最大排名df['ID'].rank(method = 'max') 对数据进行分组 123456789# 如果price列的值&gt;3000，group列显示high，否则显示lowdf[&apos;group&apos;] = np.where(df[&apos;客户当天发送消息数&apos;] &gt; 5,&apos;high&apos;,&apos;low&apos;)# 对符合多个条件进行分组# 符合经纪人级别为A1且经纪人响应时长&gt;24的在sign列显示为1df.loc[(df[&apos;经纪人级别&apos;] == &apos;A1&apos;) &amp; (df[&apos;经纪人响应时长&apos;]&gt;= 24.0), &apos;sign&apos;]=1 对数据进行分列 12345678pd.DataFrame((x.split('网') for x in df['客户注册渠道']), index=df.index,columns=['客户注册渠道','size'])&lt;!-- df = pd.DataFrame((x.split('.') for x in 首页jhrj_1['所属省份编码']), index=df.index,columns=['客户注册渠道','size']) --&gt;# 分列完对数据进行合并df1 = pd.merge(首页jhrj_1, df, left_index = True, right_index = True) 新增一列 123data = data.assign(ration = [4, 2, 5, 6, 7, 8, 2, 9, 4])data[&apos;rations&apos;] = [5, 2, 5, 6, 7, 8, 2, 9, 4] 对数据进行切分 123456# 指明切分区间pd.cut(df[&apos;年龄&apos;], bins = [0,3,6,10])# 将数据切成3份pd.qcut(df[&apos;年龄&apos;],3 ) 取出的数据， 指定取到小数点几位数？ 123456# 取到小数点后3位for i in a : print(&quot;%.3f&quot;%c)# 设置小数点位数，四舍五入df[&apos;cnts&apos;].round( decimals = 2) 将 list 格式转化成 DataFrame 格式 1df = pd.DataFrame(data, columns = [&apos;省份&apos;, &apos;按钮名称&apos;, &apos;uv&apos;, &apos;pv&apos;] ) 数据选择 选择某一列/ 某几列 123456789101112# 普通索引- 根据名称进行选择df['客户端uv']df[['标题', '客户端uv']]# 位置索引 / 切片索引， 根据所在第几列进行选择# : 表示选择所有的行， 逗号后面表示要选择列的位置区域df.iloc[:, [0,2]] # 获取第1列和第3列的数值 选择某一行/某几行 12345678910111213# 普通索引-locdf.loc['第一行']df.log[['第一行', '第二行']]# 位置索引，切片索引 # 选择第一行df.iloc[0]# 选择第一行和第二行df.iloc[[0,1]] 根据指定条件进行筛选 123456789101112131415161718# 选择年龄小于200的数据df[df['年龄'] &lt; 200] #年龄小于200，且id小于300df[(df['年龄'] &lt; 200) &amp; (df['id'] &lt; 300)]df[np.logical_and(df['年龄'] &gt; 10, df['id'] &gt; 5)]# A列值大于10，或 B列值大于5df[(df['A'] &gt; 10) | (df['C'] &gt;20)]df[np.logical_or(df['A'] &gt; 10, df['C'] &gt; 20)]# 当 A列的值大于13时， 显示B，c列的值df[['B','C']][df['A']&gt;13] 行列同时选择 普通索引+普通索引选择指定的行和列 1df.loc[['第一行', '第三行'], ['订单号’, 'ID']] 位置索引 + 位置索引选择指定的行和列 123df.iloc[[0,1], [0,2]]df.iloc[0:2, 1:2] 布尔索引+ 普通索引 1df[df['年龄']&lt; 200][['订单编号', 'ID']] 切片索引+ 普通索引 1df.ix[0:2, ['订单变化', 'ID']] 按条件进行提取 12345678910111213# 用isin函数进行判断# 使用isin函数根据特定值筛选记录。筛选A值等于10或者13的记录df[df.A.isin((10, 13))]# 查看这一列是否包含某个值df['级别'].isin(['A3']) # 先判断是否包含，然后将符合条件的数据提取出来。df.loc[df['级别'].isin(['A3','M4'])] 数据汇总 对数据进行分类 - group by函数 12345678# 按照某列分组求和df.groupby('渠道').sum()# 按照多列分组求和df.groupby(['渠道', 'ID']).sum()# 对分组后的结果进行重新索引df.groupby('渠道').sum().reset_index() aggregate方法 12345678# 对同一列 先做计数汇总运算，再做汇总运算df.group('渠道').aggregate(['count', 'sum'])# 针对不同的列做不同的汇总运算df.groupby('渠道').aggregate(&#123;'ID' : 'count', '销量' : 'sum'&#125;) pivot_table-数据透视表 123# 为方便处理， 一般需要对结果进行重置索引pd.pivot_table(df, values = 'ID', columns = '渠道', index = '客户分类', aggfun = 'count').reset_index() pd.pivot_table(data, values, index, columns, aggfunc, fill_value, margins, dropna, margins_name = ‘All’) data: 数据values: 对应的值index: 对应的行columns: 对应的列aggfunc : 对values的计算类型fill_value : 对空值的填充值margins: 是否显示合计列dropna: 是否删除缺失值，如果为真，则一整行全删除margins_name: 合计列的列名 对数据进行映射 12# 用map函数对字典进行映射， 新加一列data[&apos;upper&apos;] = data[&apos;group&apos;].map(dataUpper) 数据采样 12345678910111213# 简单随机抽取sampledf.sample(n=3)# 设置采样权重# 需要对每一行进行权重设置，列表行数少可行，过多不可行# 假设有4行数据，设置采样权重weights = [0, 0, 0.5, 0.5]df.sample(n=4, weights=weights)## 确定采样后是否放回# 采样后放回，Truedf.sample(n=6, replace=True) 统计计算 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849# 计算每一列的个数df.count()# 计算每一行的个数df.count(axis = 1)# 求和df.sum()df.sum(axis = 1)# 中位数df.median()# 求和df.sum()# 求最大值df.max()# 求最小值df.min()# 求众数df.mode()# 求方差df.var()# 求标准差df.std()# 求分位数df.quantile(0.75, axis = 1)# 描述统计 describe函数#自动生成数据的数量，均值，标准差等数据#round（2）,显示小数点后面2位数，T转置df.describe().round(2).T# 标准差std()df['经纪人响应时长'].std()# 协方差covdf['经纪人当天发送消息数'].cov(df['客户当天发送消息数']# 相关性分析corrdf['客户当天发送消息数'].corr(df['经纪人当天发送消息数']) 数值计数 123456789# 查看不同值出现的次数， #默认进行排列df['ID'].value_counts()# 查看不同值出现的占比, #默认进行排列df['ID'].value_counts(normalize = True)# 查看不同值出现的占比， 不进行排列df['ID'].value_counts(normalize = True, sort = False) 插入数据 12# 在 insert方法中，指明要插入的位置、插入新列的列名，以及要插入的数据df.insert(2, '销售品id', ['01', '02']) 对数据进行转置 1df.T 索引重塑 12345# 将表格型数据转化成树形数据df.stack()# 将树形数据转化成表格型数据df.stack().unstack() 长宽表转换 宽表 长表 将长表转化成宽表,对数据进行透视, 相当于Excel中的数据透视表功能。 1df.pivot_table(index = ['computer','name'], columns = 'year', values = 'sale') 将宽表转换成长表 12# 方法1： melt()df.melt(id_vars = ['company', 'name'], var_name = 'year', value_name = 'sale') 12# 方法1： stack()# 在保持行索引不变的前提下，将列索引转化成行索引 对字符串进行操作 大小写 12a.lower()a.upper() 长度 12# 长度a.len() 去除空格 123a.strip()a.lstrip()alrstrip() 切分与分列、 合并 123456789101112131415161718192021222324252627282930313233343536#切分a.split('_')# 切分， 且成为新列a.split('_', expand = True)# 对切分进行限制, 只切1次a.split('_', expand = True, n=1)# 查看是否包含a.str.contains('A')# 分列s.str.get_dummies(sep= '|')df = 首页jhrj_1['所属省份编码'].str.split('.') # expand=True 可以把用分割的内容直接分列首页jhrj_1["所属省份编码1"]=df[0]# 切分并在原表中进行合并首页jhrj_2 = pd.merge(首页jhrj_1, pd.DataFrame(首页jhrj_1['所属省份编码'].str.split('.', expand = True) ), how = 'left', left_index = True, right_index = True)# pandas对dataframe中的某一列使用split做字符串切割：# words = df['col'].split()# 报错：# AttributeError: 'Series' object has no attribute 'split'# 原因是df['col']返回的是一个Series对象，需要先把Series对象转换为字符串：pandas.Series.str.split# words = df['col'].str.split()对两列数据进行合并df['省份_名称'] = df['省份'].str.cat(df['名称'],sep = '_')首页jdt_1['省份_标题'] = 首页jdt_1['所属省份编码'].astype(str).str.cat(首页jdt_1['标题'],sep = '_') 日期-时间 当前日期 123456789101112131415161718192021import timefrom datetime import datetime, time, timedelta# 返回当前日期和时间datetime.now()# 返回当前时间的年datetime.now().year# 返回当前时间的月份datetime.now().month# 返回当前日期的日期datetime.now().day# 返回当前时刻在周几# python周几默认是从0开始的datatime.now.weekeday() + 1# 返回当前时间所在周的周数datatime.now.isocalendar()[1] 返回指定日期 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263# 只展现日期datetime.now.date()# 只展示时间datetime.now.time()# 显示当前日期datetime.now().strftime('%Y-%m-%d')#2018-12-22datetime.now.strftime('%Y-%m-%d %H:%M:%S")# 将时间格式转化成字符串格式now=str( datetime.now())# 将字符串格式转化为时间格式parse(str_now) # 往后推一天date+ Day(1)# 往后推一个小时date + Hour(1)# 往前推一天date - Day(1)# 昨天ysd = now - timedelta(days = 1)#本月第一天ysd = now.replace(day = now.day-1)# 上月最后一天lastmonth_end = now.replace(day = now.day-1) - timedelta(days=1)# 上月第一天lastmonth_first = now.replace(month = now.month-1, day =1)lastmonth_first = lastmonth_end.replace(day=1)#提取2016年11月2号的数据df['2016-11-02' : '2016-11-02']dt_time = dt.datetime(year = 2018, month=9, day = 17, hour = 22, minute = 43)# 构造时间序列， 构造十个日期， 每12分钟一次pd.Series(pd.date_range(start = '2018-09-17 22:43:00', periods = 10, freq = '12min'))# 取所有8点到12点之间的数据, 不包含8点和12点data[(data.index.hour &gt; 8) &amp; (data.index.hour &lt; 12)]# 包含8点到12点data.between_time('08:00', '12:00')import datetimefrom dateutil.relativedelta import relativedelta begin = datetime.date(2019,1,1)end = datetime.date(2019,1,31)for i in range(1,10): first = d + relativedelta(months=i) last = end + relativedelta(months=i) 处理月与月之间时间不连续问题 1234567891011121314151617181920212223import time from datetime import datetime, time,timedelta# 指定昨天df = datetime.now() - timedelta(days = 1)# 月初第一天startdates = (df.replace(day = 1)).strftime('%Y-%m-%d')# 昨天enddates = (df - timedelta(days = num)).strftime('%Y-%m-%d')# 上月第一天last_moth_f = df.replace(month =df.month-1, day=1).__format__("%Y-%m-%d")# 上月最后一天last_moth_e = df.replace(month = df.month-1, day =1).strftime('%Y-%m-31')# 目标值月份mubiao_dates = startdates[0:7]# 将字符串转换为日期df = datetime.now() - timedelta(days = 1)day1 = (df.replace(day = 1)).strftime('2019-11-%d')first = datetime.strptime(day1, "%Y-%m-%d") 自动发送邮件12import smtplibfrom email import encoders]]></content>
      <categories>
        <category>数据分析技能</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一个好用的插件]]></title>
    <url>%2F2018%2F09%2F25%2F%E7%94%9F%E6%B4%BB-%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93-%E5%A5%BD%E7%94%A8%E7%9A%84%E6%8F%92%E4%BB%B6%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[一个好用的插件神器最近发现了一个特别能够提高生活幸福感的插件：Tampermonkey, 中文翻译过来叫做油猴。 安装好这个插件最大的作用， 就是我们可以从Greasy Fork这个网站来安装我们需要的脚本， 从而极大的提高浏览器的使用效率。 比如：我们在Greasy Fork网站找到智能划词翻译这个脚本， 然后点击安装脚本即可。安装完成脚本之后， 我们打开一个英文网页，对需要翻译的段落进行框选，点击翻译按钮，就可实现在原网页查看中文翻译， 对于我这种英语不好的人来说， 有很大的帮助。 我们还可以安装微博过滤设置脚本，来对微博页面进行个性化设置， 自己设置完成后的微博页面是这个样，相对于原版网页来说简洁了不少。 也可安装微博浮图脚本， 查看微博图片也比较方便， 只需把鼠标光标放在图片上即可 如果想找资料或电影资源的话， 也可以下载豆瓣资源下载大师, 或百度网盘直接下载助手等脚本， 当然，有能力还是要支持正版。 例如：安装豆瓣资源下载大师脚本后， 打开豆瓣电影网页， 页面是这个样子。 在Greasy Fork这个网站还有很多别人写好的脚本， 比如百度文库文字复制、购物党自动比价工具、 Download Youtube videos and subtitles等好用的脚本， 可以根据自己的需要进行安装。]]></content>
      <categories>
        <category>生活资料</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[双拼输入法]]></title>
    <url>%2F2017%2F09%2F17%2F%E7%94%9F%E6%B4%BB-%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93-%E5%8F%8C%E6%8B%BC%E8%BE%93%E5%85%A5%E6%B3%95%2F</url>
    <content type="text"><![CDATA[1. 怎么接触到双拼的？自己第一次接触双拼，是看到李笑来老师的《把时间当朋友》第二章中的“盲打究竟是否值得学会”,里面提到了盲打与双拼帮助他快速进行记录笔记和文字。 于是自己就试着在网上找双拼的学习方法。 2. 什么是双拼？ 维基百科：双拼是汉语拼音输入法的一种编码方案。相对于全拼而言，使用双拼输入汉字时只需输入一个代表声母的字母，一个代表韵母的字母，就可以打出任意一个中文单字了。 理解起来也很简单，比如你要拼写 张 红 这两个字， 用全拼的话可能你得输入 zhang hong， 而用小鹤双拼的话， 你只需要输入vh hs 就可以显示。 v 代表zh , h 代表ang , s代表ong 双拼的语法也有很多种，比如小鹤双拼、自然码双拼、紫光拼音双拼、搜狗拼音双拼、微软拼音双拼、智能ABC双拼。 每种双拼对应的语法也都不一样。 自己学习的是小鹤双拼，语法图是这样的： 在搜狗输入法上点击 设置—— 属性设置 —— 常用 —— 特殊习惯—— 双拼 就可以使用了。 3. 学习的过程刚开始学习小鹤双拼的时候， 自己是完全不习惯的， 因为想要使用小鹤双拼进行文字输入，就得记住每个字母对应的韵母， 自己每输入一个字， 就得想一下这个字的韵母是什么， 对应到按键上的那个字母又是什么。 再去输入，说实话当时输入字的效率低下到令人发指，而且往往记不住，自己只好打印了一张语法表贴在自己的电脑旁， 忘了就在表上找。 好几次忍不住偷偷换成了全拼， 特别是在工作着急的情况下。 就这样别别扭扭用了一周之后， 才发现自己已经能够慢慢不看语法表了。 （这让我都有点怀疑自己的智商，因为网上说基本一周就可以很熟练了）一个月过后自己才做到了输入基本不卡壳，但如果旁边有人一紧张还是会忘掉如何输入了。 现在用了一年多， 自己已经能够无意识的使用双拼了。 如果你现在问我键盘上的字母在双拼中代表哪个韵母，自己可能真的答不上来，但只要自己在键盘上打字，自己就能够无意识的打出来。 4. 学习双拼的优点与缺点( 1 ). 优点 简洁，同样一个词全拼要五六下，双拼只需要两下 感觉节省了时间，更喜欢在键盘上敲字了。 （至于是否真正节省了时间，自己没有做过对比） ( 2 ). 缺点 全拼不会用了， 有时在别人的电脑上输入文字总是很别扭，老出错，总想着把输入法改成双拼 有时大脑短路会想不起来双拼的语法 5. 感悟 任何学习都是不可逆的，当你学了到了一项技能，你就不可能再像从前没学过一样生活。 最可怕的不是自己知道自己不知道，而是不知道自己不知道。 比如自己学习双拼，自己以前根本不知道还有双拼这么一种输入法，就更不会产生要学习这种输入法的冲动。 如何解决自己不知道自己不知道的知识，自己目前能够想到的方法是：多读书，多关注大牛，多了解别人是怎么工作、生活。 有些东西只有自己亲身经历过后才能有所体会，哪怕是坏的体验。 如果只是看别人推荐而不去坚持使用双拼， 我就不能体会到大脑下意识使用双拼输入的快感。当然，也许会出现这种情况， 你付出了时间，付出了精力，而这项技能对你的生活影响并不大。这就需要你前期做一些搜索调查。 延伸到生活上，要是我不来北京生活，不来北京工作，我就没有机会知道来北京到底会面临什么困难，到底对自己的职业发展是否有益。也许最后自己会失败，可那又怎么样，自己的人生自己做主。 2020年2月26：现在在北京已经呆了马上快3年了，自己虽然已经转行做数据分析了，但是现在自己的职业发展并不好，甚至犹豫自己是否还应呆在北京。 学会一项技能，不是只是了解它，而是能够在生活中无意识的使用它 一项技能，只是了解是远远不够的， 你要去不断的磨练，打磨，直到它成为你大脑的一部分。 学会的标准就是：你能否不需要专门思考就能够调用它。 要学习那些你通过短时间学会,就能够一辈子用的上的知识。 6. 延伸 总是听很多的牛人说，写作是非常重要的一项技能，对一个人清晰思考问题是非常有帮助的，然而自己却迟迟没有行动，主要还是觉得自己语言词汇匮乏， 缺乏独立思考，怕自己语无伦次。 其实又想想，写作这东西这就和自己刚开始学习双拼时一样，开始你觉得自己没有可能学会，也许过一段时间你就能够发现自己的进步， 你不去坚持写又怎么能够证明自己一定学不会呢？ 自己认为学习是一个自我验证的过程：你认为自己不可能学会，你就不会坚持去学；你不坚持去学，你就不会有进步， 从而你就不会看到到自己能够学会的结果，也就证明了自己确实学不会。相反， 你认为自己能学会，你就坚持去学，看到自己的进步，最终的确学会了，也证明了自己确实能够学会。 7. 未解决问题 如何运用心智的力量在还没有机会亲身体验的情况下，仅凭心智就可以像真实经历过一样深刻体会？ 如何解决 害怕自己付出了时间，付出了精力，而没有一个好的结果 参考资料： 《把时间当朋友》]]></content>
      <categories>
        <category>生活资料</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
</search>
